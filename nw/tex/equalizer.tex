\nwfilename{src/equalizer.nw}\nwbegindocs{0}% -*- mode: poly-noweb; noweb-code-mode: opascal-mode; -*-% ===> this file was generated automatically by noweave --- better not edit it

\chapter{Equalizer}

Andrzej Trybulec emailed to Freek Wiedijk:
\begin{quote}
\textsc{equalizer} introduce what we call ``aggregated constants'' or
``equating classes'' (we should work on the terminology) and uses them
for instantiation.  An aggregated constant is characterized by the list
of its possible forms and their types (all expressed using aggregated
constants).
\end{quote}

(I think Mizar landed on using ``E classes'' as the terminology, but I
may be mistaken.)

``Requirements'' are processed here, in the equalizer.

In another email, Andrzej Trybulec wrote to Wiedijk:
\begin{quotation}
  What affect aggregation:
  \begin{enumerate}
  \item  explicit equalities
  \item
    ``default equalities'' (``{\tt take}'' and ``{\tt reconsider}'' introduce new constant that
is equal by default to term that is taken or reconsidered)
\item processing structures (if two structures are equal corresponding fields are
equal)
\item requirements; it is quite irregular, but typical is equating $x-0$ and $x$
(requirement {\tt REAL}); not so typical is equating a set that is empty with the
empty set. e.g. $\emptyset\;A$ (\verb#SUBSET_1:def 3#) with $\emptyset$ (\verb#BOOLE:def 1#)
  \end{enumerate}
\end{quotation}

\nwenddocs{}\nwbegincode{1}\sublabel{NW4MEPPp-2tMLZ6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2tMLZ6-1}}}\moddef{kernel/equalizer.pas~{\nwtagstyle{}\subpageref{NW4MEPPp-2tMLZ6-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(******************************************************************************
   This file is part of the Mizar system.
   Copyright (c) Association of Mizar Users.
   License terms: GNU General Public License Version 3 or any later version.
******************************************************************************)

unit equalizer;

interface
\LA{}Equalizer interface~{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}\RA{}

implementation
\LA{}Equalizer implementation~{\nwtagstyle{}\subpageref{NW4MEPPp-1WFdzs-1}}\RA{}
end;
\nwnotused{kernel/equalizer.pas}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Interace}

There is one public-facing type declaration for values.

\nwenddocs{}\nwbegincode{3}\sublabel{NW4MEPPp-3tHI3f-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}}\moddef{Equalizer interface~{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-2tMLZ6-1}}\nwprevnextdefs{\relax}{NW4MEPPp-3tHI3f-2}\nwenddeflinemarkup
uses mobjects,limits,numbers,correl;

type
 \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1} = record
      Determined: boolean;
      NumericValue: RComplex;
     end;
\nwindexdefn{\nwixident{ValRec}}{ValRec}{NW4MEPPp-3tHI3f-1}\eatline
\nwalsodefined{\\{NW4MEPPp-3tHI3f-2}\\{NW4MEPPp-3tHI3f-3}\\{NW4MEPPp-3tHI3f-4}}\nwused{\\{NW4MEPPp-2tMLZ6-1}}\nwidentdefs{\\{{\nwixident{ValRec}}{ValRec}}}\nwendcode{}\nwbegindocs{4}\nwdocspar


There are two constants.
\nwenddocs{}\nwbegincode{5}\sublabel{NW4MEPPp-3tHI3f-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-2}}}\moddef{Equalizer interface~{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-2tMLZ6-1}}\nwprevnextdefs{NW4MEPPp-3tHI3f-1}{NW4MEPPp-3tHI3f-3}\nwenddeflinemarkup
const
  \nwlinkedidentc{One}{NW4MEPPp-3tHI3f-2}: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1} = (Determined:true;
                 NumericValue:(Re:(Num:'1'; Den:'1'); Im:(Num:'0'; Den:'1')));
  \nwlinkedidentc{ImUnit}{NW4MEPPp-3tHI3f-2}: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1} = (Determined:true;
                 NumericValue:(Re:(Num:'0'; Den:'1'); Im:(Num:'1'; Den:'1')));

\nwindexdefn{\nwixident{One}}{One}{NW4MEPPp-3tHI3f-2}\nwindexdefn{\nwixident{ImUnit}}{ImUnit}{NW4MEPPp-3tHI3f-2}\eatline
\nwused{\\{NW4MEPPp-2tMLZ6-1}}\nwidentdefs{\\{{\nwixident{ImUnit}}{ImUnit}}\\{{\nwixident{One}}{One}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-3tHI3f-2}\nwendcode{}\nwbegindocs{6}\nwdocspar
The public-facing variables
\nwenddocs{}\nwbegincode{7}\sublabel{NW4MEPPp-3tHI3f-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-3}}}\moddef{Equalizer interface~{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-2tMLZ6-1}}\nwprevnextdefs{NW4MEPPp-3tHI3f-2}{NW4MEPPp-3tHI3f-4}\nwenddeflinemarkup
var
  \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}:
    array[1..MaxTrmNbr] of
     record
       Term: TrmPtr;
       NumValue: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1};
       PolynomialValues: MSortedCollection;
       EqClass: TrmList;
       XTypClass: MCollection;
       SuperCluster: AttrCollectionPtr;
     end;
  \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3}: integer;
  \nwlinkedidentc{TrmOvfl}{NW4MEPPp-3tHI3f-3}: boolean;
  \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3}: integer;
  \nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3}: integer;
  \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3},\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}: MCollection;

\nwindexdefn{\nwixident{TrmS}}{TrmS}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{TrmOvfl}}{TrmOvfl}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{Contr}}{Contr}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{EqClassNbr}}{EqClassNbr}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{NegBas}}{NegBas}{NW4MEPPp-3tHI3f-3}\nwindexdefn{\nwixident{PosBas}}{PosBas}{NW4MEPPp-3tHI3f-3}\eatline
\nwused{\\{NW4MEPPp-2tMLZ6-1}}\nwidentdefs{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{EqClassNbr}}{EqClassNbr}}\\{{\nwixident{NegBas}}{NegBas}}\\{{\nwixident{PosBas}}{PosBas}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmOvfl}}{TrmOvfl}}\\{{\nwixident{TrmS}}{TrmS}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-3tHI3f-3}\nwendcode{}\nwbegindocs{8}\nwdocspar
The public-facing procedures.

\nwenddocs{}\nwbegincode{9}\sublabel{NW4MEPPp-3tHI3f-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-4}}}\moddef{Equalizer interface~{\nwtagstyle{}\subpageref{NW4MEPPp-3tHI3f-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-2tMLZ6-1}}\nwprevnextdefs{NW4MEPPp-3tHI3f-3}{\relax}\nwenddeflinemarkup
procedure \nwlinkedidentc{Equate}{NW4MEPPp-3NW9rx-1}(var fEval:NatFunc);

procedure \nwlinkedidentc{DispEquations}{NW4MEPPp-4Or4Va-1};
procedure \nwlinkedidentc{DispEqClassInTrms}{NW4MEPPp-2VDfy8-1};

procedure \nwlinkedidentc{InsertNonEmpty}{NW4MEPPp-1o3Qsj-1}(fTrmInfo1,fTrmInfo2:integer);
procedure \nwlinkedidentc{InsertNonZero}{NW4MEPPp-372vgv-1}(fTrmInfo1,fTrmInfo2:integer);

procedure \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(i: integer);

\nwused{\\{NW4MEPPp-2tMLZ6-1}}\nwidentuses{\\{{\nwixident{DispEqClassInTrms}}{DispEqClassInTrms}}\\{{\nwixident{DispEquations}}{DispEquations}}\\{{\nwixident{Equate}}{Equate}}\\{{\nwixident{InsertNonEmpty}}{InsertNonEmpty}}\\{{\nwixident{InsertNonZero}}{InsertNonZero}}\\{{\nwixident{SetContr}}{SetContr}}}\nwindexuse{\nwixident{DispEqClassInTrms}}{DispEqClassInTrms}{NW4MEPPp-3tHI3f-4}\nwindexuse{\nwixident{DispEquations}}{DispEquations}{NW4MEPPp-3tHI3f-4}\nwindexuse{\nwixident{Equate}}{Equate}{NW4MEPPp-3tHI3f-4}\nwindexuse{\nwixident{InsertNonEmpty}}{InsertNonEmpty}{NW4MEPPp-3tHI3f-4}\nwindexuse{\nwixident{InsertNonZero}}{InsertNonZero}{NW4MEPPp-3tHI3f-4}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-3tHI3f-4}\nwendcode{}\nwbegindocs{10}\nwdocspar


\section{Implementation}

\nwenddocs{}\nwbegincode{11}\sublabel{NW4MEPPp-1WFdzs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1WFdzs-1}}}\moddef{Equalizer implementation~{\nwtagstyle{}\subpageref{NW4MEPPp-1WFdzs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-2tMLZ6-1}}\nwenddeflinemarkup
uses errhan,builtin,lexicon,enums,identify,polynom,ellipses,prechecker,mscanner
\{$IFDEF MINI_PROFILER\},miniprof \{$ENDIF\}
\{$IFDEF CH_REPORT\},req_info,prephan\{$ENDIF\}
\{$IFDEF MDEBUG\},info,outinfo\{$ENDIF\};

type
\LA{}Types internal to the equalizer~{\nwtagstyle{}\subpageref{NW4MEPPp-54Dll-1}}\RA{}
\nwused{\\{NW4MEPPp-2tMLZ6-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

There are some internal types used within the equalizer. Specifically, a
collection of constants {\Tt{}ConCllection\nwendquote}, constructor items (?), and a ch
\nwenddocs{}\nwbegincode{13}\sublabel{NW4MEPPp-54Dll-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-54Dll-1}}}\moddef{Types internal to the equalizer~{\nwtagstyle{}\subpageref{NW4MEPPp-54Dll-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1WFdzs-1}}\nwenddeflinemarkup
   \nwlinkedidentc{ConCollection}{NW4MEPPp-54Dll-1} =
      object(TIntKeyCollection)
         procedure \nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm:TrmPtr);
         function \nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm:TrmPtr): TrmPtr;
      end;
   
   \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1} = ^\nwlinkedidentc{ChConstrObj}{NW4MEPPp-54Dll-1};
   \nwlinkedidentc{ChConstrObj}{NW4MEPPp-54Dll-1} =
      object(TIntItem)
         fTerms: MSortedList;
         constructor Init(aTrm:TrmPtr);
         destructor Done; virtual;
      end;
\nwindexdefn{\nwixident{ConCollection}}{ConCollection}{NW4MEPPp-54Dll-1}\nwindexdefn{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-54Dll-1}\nwindexdefn{\nwixident{ChConstrObj}}{ChConstrObj}{NW4MEPPp-54Dll-1}\eatline
\nwused{\\{NW4MEPPp-1WFdzs-1}}\nwidentdefs{\\{{\nwixident{ChConstrObj}}{ChConstrObj}}\\{{\nwixident{ConCollection}}{ConCollection}}\\{{\nwixident{ConstrItem}}{ConstrItem}}}\nwidentuses{\\{{\nwixident{AllocTerm}}{AllocTerm}}\\{{\nwixident{FindTerm}}{FindTerm}}}\nwindexuse{\nwixident{AllocTerm}}{AllocTerm}{NW4MEPPp-54Dll-1}\nwindexuse{\nwixident{FindTerm}}{FindTerm}{NW4MEPPp-54Dll-1}\nwendcode{}\nwbegindocs{14}\nwdocspar
I think {\Tt{}\nwlinkedidentq{SetContr}{NW4MEPPp-2F63Xo-1}\nwendquote} is short for ``set contradiction code'', but I
cannot adequately understand ``contr''.

\nwenddocs{}\nwbegincode{15}\sublabel{NW4MEPPp-2F63Xo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2F63Xo-1}}}\moddef{Set contr~{\nwtagstyle{}\subpageref{NW4MEPPp-2F63Xo-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(i: integer);
\{$IFDEF TEST_CONTR\}
var
   f_contr: text;
\{$ENDIF\}
begin
   \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3}:=i;
   \{$IFDEF TEST_CONTR\}
   if i > 0 then
   begin
      assign(f_contr,'contr.txt');
 \{$I-\}append(f_contr);\{$I+\}
      if IOResult <> 0 then rewrite(f_contr);
      writeln(f_contr,i);
      close(f_contr);
   end;
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{SetContr}}{SetContr}{NW4MEPPp-2F63Xo-1}\eatline
\nwnotused{Set contr}\nwidentdefs{\\{{\nwixident{SetContr}}{SetContr}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-2F63Xo-1}\nwendcode{}\nwbegindocs{16}\nwdocspar
\nwenddocs{}\nwbegincode{17}\sublabel{NW4MEPPp-1OzTEP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1OzTEP-1}}}\moddef{Write equality class information to info file~{\nwtagstyle{}\subpageref{NW4MEPPp-1OzTEP-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{$IFDEF MDEBUG\}
procedure \nwlinkedidentc{InfoEqClass}{NW4MEPPp-1OzTEP-1}(e: integer);
var
   i: integer;
begin
   //  writeln(infofile,' -------------------------------');
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[e] do
      if EqClass = nil then
      begin
         writeln(infofile,'Trms[',e,'] = Trms[',Term^.TrmInfo,']');
         //  writeln(infofile,'EqClass=nil');
      end
      else
      begin
         write(infofile,'Trms[',e,'] ');
         //  writeln(infofile,'EqClassNr=',Term^.TrmInfo);
         infoterm(Term);
         infonewline;
         with NumValue do
         begin
            if  Determined then
            begin
               write(infofile,' determined: ');
               infocomplex(NumericValue);
               infonewline;
            end;
            //    writeln(infofile,' wartosc wielomianowa');
            for i:=0 to PolynomialValues.Count-1 do
            begin
               write(infofile,' ',i,':-- ');
               infopolynomial(PolynomialValues.Items^[i]);
               infonewline;
            end;
         end;
         write(infofile,' eqlista termow: ');
         infotermlist(EqClass);
         infonewline;
         write(infofile,' eqlista typow: ');
         InfoTypeColl(XTypClass);
         infonewline;
         write(infofile,' supercluster: ');
         infocluster(SuperCluster);
         infonewline;
      end;
end;
\nwindexdefn{\nwixident{InfoEqClass}}{InfoEqClass}{NW4MEPPp-1OzTEP-1}\eatline
\nwnotused{Write equality class information to info file}\nwidentdefs{\\{{\nwixident{InfoEqClass}}{InfoEqClass}}}\nwidentuses{\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1OzTEP-1}\nwendcode{}\nwbegindocs{18}\nwdocspar
\nwenddocs{}\nwbegincode{19}\sublabel{NW4MEPPp-3njkGZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3njkGZ-1}}}\moddef{Write all equality classes information to file~{\nwtagstyle{}\subpageref{NW4MEPPp-3njkGZ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InfoEqClasses}{NW4MEPPp-3njkGZ-1};
var
   e: integer;
begin
   InfoNewLine;
   for e := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do \nwlinkedidentc{InfoEqClass}{NW4MEPPp-1OzTEP-1}(e);
   flush(infofile);
end;
\nwindexdefn{\nwixident{InfoEqClasses}}{InfoEqClasses}{NW4MEPPp-3njkGZ-1}\eatline
\nwnotused{Write all equality classes information to file}\nwidentdefs{\\{{\nwixident{InfoEqClasses}}{InfoEqClasses}}}\nwidentuses{\\{{\nwixident{InfoEqClass}}{InfoEqClass}}\\{{\nwixident{TrmNbr}}{TrmNbr}}}\nwindexuse{\nwixident{InfoEqClass}}{InfoEqClass}{NW4MEPPp-3njkGZ-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-3njkGZ-1}\nwendcode{}\nwbegindocs{20}\nwdocspar
Write the functor terms to the file, then ``Fr operators'' to the file,
and finally choice terms to the file.

\nwenddocs{}\nwbegincode{21}\sublabel{NW4MEPPp-13aFp2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-13aFp2-1}}}\moddef{Write function term list information to file~{\nwtagstyle{}\subpageref{NW4MEPPp-13aFp2-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InfoFuncTrmList}{NW4MEPPp-13aFp2-1};
var
   e: FuncTrmExprKind;
   i,z: integer;
begin
   InfoNewLine;
   InfoString('InfoFuncTrmList');
   InfoNewLine;
   for e := Low(FuncTrmExprKind) to High(FuncTrmExprKind) do
      with FuncTrmList[e] do
         for z := 0 to Count-1 do
            with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(Items^[z])^.fTerms do
               for i := 0 to Count-1 do
               begin
                  InfoTerm(At(i)); 
                  InfoNewLine;
               end;
   
   InfoNewLine;
   InfoString('InfoFrOper');
   InfoNewLine;
   with FrOper do
      for i := 0 to Count-1 do
      begin
         InfoTerm(At(i));
         InfoNewLine;
      end;
   
   InfoNewLine;
   InfoString('InfoChoiceTerm');
   InfoNewLine;
   with ChoiceTerm do
      for i := 0 to Count-1 do
      begin
         InfoTerm(At(i));
         InfoNewLine;
      end;
   
   flush(InfoFile);
end;
\{$ENDIF\}
\nwindexdefn{\nwixident{InfoFuncTrmList}}{InfoFuncTrmList}{NW4MEPPp-13aFp2-1}\eatline
\nwnotused{Write function term list information to file}\nwidentdefs{\\{{\nwixident{InfoFuncTrmList}}{InfoFuncTrmList}}}\nwidentuses{\\{{\nwixident{ConstrItem}}{ConstrItem}}}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-13aFp2-1}\nwendcode{}\nwbegindocs{22}\nwdocspar
Checking if two list of terms are equal amounts to iterating through the
list, checking term-by-term.

\nwenddocs{}\nwbegincode{23}\sublabel{NW4MEPPp-40vpaW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-40vpaW-1}}}\moddef{Check if term lists are equal~{\nwtagstyle{}\subpageref{NW4MEPPp-40vpaW-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} ( fTrm1,fTrm2:TrmPtr ): boolean; FORWARD;
function \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1} ( fTyp1,fTyp2:TypPtr ): boolean; FORWARD;
function \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} ( fFrm1,fFrm2:FrmPtr ): boolean; FORWARD;

function \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(FTL1,FTL2: TrmList): boolean;
begin
   while (FTL1 <> nil) and (FTL2 <> nil) do
   begin
      if not \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(FTL1^.XTrmPtr,FTL2^.XTrmPtr) then
      begin
         \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1} := false;
      exit
      end;
      FTL1 := FTL1^.NextTrm;
      FTL2 := FTL2^.NextTrm;
   end;
   \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1} := FTL1 = FTL2;
end;
\nwindexdefn{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-40vpaW-1}\eatline
\nwnotused{Check if term lists are equal}\nwidentdefs{\\{{\nwixident{EqTrmLists}}{EqTrmLists}}}\nwidentuses{\\{{\nwixident{EqFrms}}{EqFrms}}\\{{\nwixident{EqTrms}}{EqTrms}}\\{{\nwixident{EqTyps}}{EqTyps}}}\nwindexuse{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-40vpaW-1}\nwindexuse{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-40vpaW-1}\nwindexuse{\nwixident{EqTyps}}{EqTyps}{NW4MEPPp-40vpaW-1}\nwendcode{}\nwbegindocs{24}\nwdocspar
\nwenddocs{}\nwbegincode{25}\sublabel{NW4MEPPp-GMQ7O-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-GMQ7O-1}}}\moddef{Check if term lists are equal, except for the last item~{\nwtagstyle{}\subpageref{NW4MEPPp-GMQ7O-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqButLast}{NW4MEPPp-GMQ7O-1}(FTL1,FTL2: TrmList): boolean;
begin
   mizassert(2000,(FTL1 <> nil) and (FTL2 <> nil));
   while (FTL1^.NextTrm <> nil) and (FTL2^.NextTrm <> nil) do
   begin
      if not \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(FTL1^.XTrmPtr,FTL2^.XTrmPtr) then
      begin
         \nwlinkedidentc{EqButLast}{NW4MEPPp-GMQ7O-1} := false;
         exit;
      end;
      FTL1 := FTL1^.NextTrm; FTL2 := FTL2^.NextTrm;
   end;
   \nwlinkedidentc{EqButLast}{NW4MEPPp-GMQ7O-1} := FTL1^.NextTrm=FTL2^.NextTrm;
end;
\nwindexdefn{\nwixident{EqButLast}}{EqButLast}{NW4MEPPp-GMQ7O-1}\eatline
\nwnotused{Check if term lists are equal, except for the last item}\nwidentdefs{\\{{\nwixident{EqButLast}}{EqButLast}}}\nwidentuses{\\{{\nwixident{EqTrms}}{EqTrms}}}\nwindexuse{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-GMQ7O-1}\nwendcode{}\nwbegindocs{26}\nwdocspar
\nwenddocs{}\nwbegincode{27}\sublabel{NW4MEPPp-3UkYuK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3UkYuK-1}}}\moddef{Test if two attributes are equal~{\nwtagstyle{}\subpageref{NW4MEPPp-3UkYuK-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1}(fAttr1, fAttr2: AttrPtr): boolean;
var
   lAttrNr1,lAttrNr2: integer;
   lArgs1,lArgs2: TrmList;
begin
   fAttr1^.AdjustAttr(lAttrNr1,lArgs1);
   fAttr2^.AdjustAttr(lAttrNr2,lArgs2);
   \nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1} := (lAttrNr1 = lAttrNr2) and
      (fAttr1^.fNeg = fAttr2^.fNeg) and
      \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgs1,lArgs2);
end;
\nwindexdefn{\nwixident{EqAttrs}}{EqAttrs}{NW4MEPPp-3UkYuK-1}\eatline
\nwnotused{Test if two attributes are equal}\nwidentdefs{\\{{\nwixident{EqAttrs}}{EqAttrs}}}\nwidentuses{\\{{\nwixident{EqTrmLists}}{EqTrmLists}}}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-3UkYuK-1}\nwendcode{}\nwbegindocs{28}\nwdocspar
\nwenddocs{}\nwbegincode{29}\sublabel{NW4MEPPp-141Af5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-141Af5-1}}}\moddef{Test if two types are equal~{\nwtagstyle{}\subpageref{NW4MEPPp-141Af5-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(fTyp1,fTyp2: TypPtr): boolean;
var
   ModNr1,ModNr2: integer;
   A1,A2: TrmList;
begin
   \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1} := false;
   if fTyp1^.TypSort=fTyp2^.TypSort then
      case fTyp1^.TypSort of
         ikTypMode:
            begin
               fTyp1^.AdjustTyp(ModNr1,A1);
               fTyp2^.AdjustTyp(ModNr2,A2);
               if (ModNr1=ModNr2) and EqualClusters(fTyp1,fTyp2,\nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1}) then
                  \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1} := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(A1,A2);
            end;
         ikTypStruct:
            if (fTyp1^.ModNr = fTyp2^.ModNr) and
                  EqualClusters(fTyp1,fTyp2,\nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1}) then
               \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1} := EqTrmlists(fTyp1^.ModArgs,fTyp2^.ModArgs);
      else RunTimeError(2020);
      end;
end;
\nwindexdefn{\nwixident{EqTyps}}{EqTyps}{NW4MEPPp-141Af5-1}\eatline
\nwnotused{Test if two types are equal}\nwidentdefs{\\{{\nwixident{EqTyps}}{EqTyps}}}\nwidentuses{\\{{\nwixident{EqAttrs}}{EqAttrs}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}}\nwindexuse{\nwixident{EqAttrs}}{EqAttrs}{NW4MEPPp-141Af5-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-141Af5-1}\nwendcode{}\nwbegindocs{30}\nwdocspar
\nwenddocs{}\nwbegincode{31}\sublabel{NW4MEPPp-3iPvQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3iPvQ-1}}}\moddef{Test two formulas for equality~{\nwtagstyle{}\subpageref{NW4MEPPp-3iPvQ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(fFrm1,fFrm2: FrmPtr): boolean;
var
   PredNr1,PredNr2,i: integer;
   lFlag: Boolean;
   lTrmList,lTrmList1,A1,A2: TrmList;
begin
   \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := false;
   with fFrm1^ do IF FrmSort=fFrm2^.FrmSort then
      case FrmSort of
         ikFrmNeg:
            \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(NegFrmPtr(fFrm1)^.NegArg,NegFrmPtr(fFrm2)^.NegArg);
         ikFrmQual:
            if \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(QualFrmPtr(fFrm1)^.QualTrm,QualFrmPtr(fFrm2)^.QualTrm) then
               \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(QualFrmPtr(fFrm1)^.QualTyp,QualFrmPtr(fFrm2)^.QualTyp);
         ikFrmConj:
            with ConjFrmPtr(fFrm1)^.Conjuncts do
            if Count = ConjFrmPtr(fFrm2)^.Conjuncts.Count then
            begin
               for i := 0 to Count-1 do
                  if not \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(FrmPtr(Items^[i]),FrmPtr(ConjFrmPtr(fFrm2)^.Conjuncts.Items^[i])) then
                     exit;
               \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := true;
            end;
         ikFrmSchPred,ikFrmPrivPred:
            if PredFrmPtr(fFrm1)^.PredNr=PredFrmPtr(fFrm2)^.PredNr then
               \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(PredFrmPtr(fFrm1)^.PredArgs,PredFrmPtr(fFrm2)^.PredArgs);
         ikFrmAttr:
            begin
               AdjustAttrFrm(PredFrmPtr(fFrm1),PredNr1,A1);
               AdjustAttrFrm(PredFrmPtr(fFrm2),PredNr2,A2);
               if PredNr1=PredNr2 then
                  \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(A1,A2);
            end;
         ikFrmPred:
            begin
               AdjustFrm(PredFrmPtr(fFrm1),PredNr1,A1);
               AdjustFrm(PredFrmPtr(fFrm2),PredNr2,A2);
               if PredNr1=PredNr2 then
               begin
                  if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(A1,A2) then
                  begin \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := true;
                  exit
                  end;
                  \{ ### To powinno byc nasladowane w innych procedurach porownan
                    - np. schematyzator - ale nie ma analogii dla "connectedness"
                  \}
                  \{ ### This should be emulated in other comparison routines
                    - e.g. schematizer - but there is no analogy for "connectedness"
                  \}
                  if sySymmetry in ConstrPtr( Constr[ coPredicate].At(
                                                 PredFrmPtr(fFrm1)^.PredNr))^.fProperties then
                     with PredFrmPtr(fFrm1)^,ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
                  begin
                     lTrmList := SwitchArgs(fFirstArg,fSecondArg,PredFrmPtr(fFrm1)^.PredArgs);
                     lTrmList1 := AdjustTrmList(ikFrmPred,PredFrmPtr(fFrm1)^.PredNr,lTrmList);
                     lFlag := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lTrmList1,A2);
                     DisposeTrmList(lTrmList);
                     \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := lFlag;
                  end
                  else if sySymmetry in ConstrPtr( Constr[ coPredicate].At(
                                                      PredFrmPtr(fFrm2)^.PredNr))^.fProperties then
                     with PredFrmPtr(fFrm2)^,ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
                  begin
                     lTrmList := SwitchArgs(fFirstArg,fSecondArg,PredArgs);
                     lTrmList1 := AdjustTrmList(ikFrmPred,PredNr,lTrmList);
                     lFlag := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(A1,lTrmList1);
                     DisposeTrmList(lTrmList);
                     \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := lFlag;
                  end
               end;
            end;
         ikFrmUniv:
            if \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(UnivFrmPtr(fFrm1)^.Quantified,UnivFrmPtr(fFrm2)^.Quantified) then
               \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(UnivFrmPtr(fFrm1)^.Scope,UnivFrmPtr(fFrm2)^.Scope);
         ikFrmVerum,ikFrmThesis,ikFrmError:
            \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1} := true;
      else RunTimeError(2021);
      end;
end;
\nwindexdefn{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-3iPvQ-1}\eatline
\nwnotused{Test two formulas for equality}\nwidentdefs{\\{{\nwixident{EqFrms}}{EqFrms}}}\nwidentuses{\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{EqTrms}}{EqTrms}}\\{{\nwixident{EqTyps}}{EqTyps}}}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-3iPvQ-1}\nwindexuse{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-3iPvQ-1}\nwindexuse{\nwixident{EqTyps}}{EqTyps}{NW4MEPPp-3iPvQ-1}\nwendcode{}\nwbegindocs{32}\nwdocspar
\nwenddocs{}\nwbegincode{33}\sublabel{NW4MEPPp-4WdwKE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4WdwKE-1}}}\moddef{Check if two terms are equal~{\nwtagstyle{}\subpageref{NW4MEPPp-4WdwKE-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(fTrm1,fTrm2: TrmPtr): boolean;
var
   FuncNr1,FuncNr2,i: integer;
   A1,A2: TrmList;
begin
   \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := false;
   with fTrm1^ do
   begin
      if TrmInfo<>0 then
      begin
         \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := TrmInfo=fTrm2^.TrmInfo;
         exit;
      end;
      if TrmSort = fTrm2^.TrmSort then
         case TrmSort of
            ikTrmLocus,ikTrmBound,ikTrmConstant,ikTrmInfConst,ikTrmNumeral:
               with VarTrmPtr(fTrm1)^ do
                  \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := VarNr=VarTrmPtr(fTrm2)^.VarNr;
            ikTrmFunctor:
               begin
                  AdjustTrm(fTrm1,FuncNr1,A1);
                  AdjustTrm(fTrm2,FuncNr2,A2);
                  if FuncNr1=FuncNr2 then \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(A1,A2);
               end;
            ikTrmSchFunc,ikTrmPrivFunc,ikTrmAggreg,ikTrmSelector:
               with FuncTrmPtr(fTrm1)^ do
                  if FuncNr=FuncTrmPtr(fTrm2)^.FuncNr then
                     \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(FuncArgs,FuncTrmPtr(fTrm2)^.FuncArgs);
            ikTrmFraenkel:
               with FraenkelTrmPtr(fTrm1)^ do
                  if LambdaArgs.Count = FraenkelTrmPtr(fTrm2)^.LambdaArgs.Count then
                  begin
                     for i := 0 to LambdaArgs.Count-1 do
                        if not \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(LambdaArgs.Items^[i],FraenkelTrmPtr(fTrm2)^.LambdaArgs.Items^[i]) then
                           exit;
                     \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(LambdaScope,FraenkelTrmPtr(fTrm2)^.LambdaScope)
                        and \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(Compr,FraenkelTrmPtr(fTrm2)^.Compr);
                  end;
            ikTrmChoice:
               with ChoiceTrmPtr(fTrm1)^ do
               \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(ChoiceTyp,ChoiceTrmPtr(fTrm2)^.ChoiceTyp);
            ikTrmError: \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1} := true;
         else
         begin
            \{$IFDEF MDEBUG\}
            InfoString('TrmSort='); InfoChar(fTrm1^.TrmSort); flush(InfoFile);
            \{$ENDIF\}
            RunTimeError(2022);
         end;
         end;
   end;
end;
\nwindexdefn{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-4WdwKE-1}\eatline
\nwnotused{Check if two terms are equal}\nwidentdefs{\\{{\nwixident{EqTrms}}{EqTrms}}}\nwidentuses{\\{{\nwixident{EqFrms}}{EqFrms}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{EqTyps}}{EqTyps}}}\nwindexuse{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-4WdwKE-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-4WdwKE-1}\nwindexuse{\nwixident{EqTyps}}{EqTyps}{NW4MEPPp-4WdwKE-1}\nwendcode{}\nwbegindocs{34}\nwdocspar
\nwenddocs{}\nwbegincode{35}\sublabel{NW4MEPPp-2nHUFT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2nHUFT-1}}}\moddef{Allocate a term to a constant collection~{\nwtagstyle{}\subpageref{NW4MEPPp-2nHUFT-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ConCollection}{NW4MEPPp-54Dll-1}.\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm: TrmPtr);
var
   lTrmNr:integer;
begin
   case TrmPtr(fTrm)^.TrmSort of
      ikTrmLocus,ikTrmBound,ikTrmConstant,ikTrmInfConst,ikTrmFreeVar,ikTrmLambdaVar,
      ikTrmNumeral,ikTrmEqConst:
         if Search(addr(VarTrmPtr(fTrm)^.VarNr),lTrmNr) then
            with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(Items^[lTrmNr])^ do
               begin
                  fTerms.Insert(fTrm);
               end
         else AtInsert(lTrmNr,new(\nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}, Init(fTrm)));
      ikTrmSchFunc,ikTrmPrivFunc,ikTrmAggreg,ikTrmFunctor,ikTrmSelector:
         if Search(addr(FuncTrmPtr(fTrm)^.FuncNr),lTrmNr) then
            with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(Items^[lTrmNr])^ do
         begin
            fTerms.Insert(fTrm);
         end
         else AtInsert(lTrmNr,new(\nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}, Init(fTrm)));
   end;
end;
\nwindexdefn{\nwixident{AllocTerm}}{AllocTerm}{NW4MEPPp-2nHUFT-1}\eatline
\nwnotused{Allocate a term to a constant collection}\nwidentdefs{\\{{\nwixident{AllocTerm}}{AllocTerm}}}\nwidentuses{\\{{\nwixident{ConCollection}}{ConCollection}}\\{{\nwixident{ConstrItem}}{ConstrItem}}}\nwindexuse{\nwixident{ConCollection}}{ConCollection}{NW4MEPPp-2nHUFT-1}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-2nHUFT-1}\nwendcode{}\nwbegindocs{36}\nwdocspar
\subsection{Methods for Constant Collection class}

\nwenddocs{}\nwbegincode{37}\sublabel{NW4MEPPp-3r8YNG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3r8YNG-1}}}\moddef{Find a term in a constant collection~{\nwtagstyle{}\subpageref{NW4MEPPp-3r8YNG-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{ConCollection}{NW4MEPPp-54Dll-1}.\nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm:TrmPtr): TrmPtr;
var
   lFuncNr,ii: integer;
begin
   \nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1} := nil;
   if Search(addr(FuncTrmPtr(fTrm)^.FuncNr),lFuncNr) then
      with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(Items^[lFuncNr])^ do
         begin
            //    gStrictCompare := false;
            //    if fTerms.Search(fTrm,ii) then
            for ii := 0 to fTerms.count-1 do
               if \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(fTrm,fTerms.Items^[ii]) then
               begin
                  \nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1} := fTerms.Items^[ii];
                  exit;
               end;
            //    gStrictCompare := true;
         end;
end;
\nwindexdefn{\nwixident{FindTerm}}{FindTerm}{NW4MEPPp-3r8YNG-1}\eatline
\nwnotused{Find a term in a constant collection}\nwidentdefs{\\{{\nwixident{FindTerm}}{FindTerm}}}\nwidentuses{\\{{\nwixident{ConCollection}}{ConCollection}}\\{{\nwixident{ConstrItem}}{ConstrItem}}\\{{\nwixident{EqTrms}}{EqTrms}}}\nwindexuse{\nwixident{ConCollection}}{ConCollection}{NW4MEPPp-3r8YNG-1}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-3r8YNG-1}\nwindexuse{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-3r8YNG-1}\nwendcode{}\nwbegindocs{38}\nwdocspar
\subsection{Other procedures}

\nwenddocs{}\nwbegincode{39}\sublabel{NW4MEPPp-3MAeyg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3MAeyg-1}}}\moddef{Dispose term recurse and list~{\nwtagstyle{}\subpageref{NW4MEPPp-3MAeyg-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(fTrm: FuncTrmPtr);
var
   ll,ll1: TrmList;
begin
   with fTrm^ do
      case TrmSort of
         ikTrmSchFunc,ikTrmPrivFunc,ikTrmAggreg,ikTrmFunctor,ikTrmSelector:
            begin
               ll := FuncArgs;
               while ll <> nil do
               begin
                  ll1 := ll^.NextTrm;
                  dispose(ll);
                  ll := ll1
               end;
               dispose(fTrm)
            end;
      else
      begin
         \{$IFDEF MDEBUG\}
         InfoChar(TrmSort);
         \{$ENDIF\}
         RunTimeError(2136);
      end;
      end;
end;
\nwindexdefn{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}\eatline
\nwnotused{Dispose term recurse and list}\nwidentdefs{\\{{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}}}\nwendcode{}\nwbegindocs{40}\nwdocspar
Choice constructor object(?)
\nwenddocs{}\nwbegincode{41}\sublabel{NW4MEPPp-UuAXD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-UuAXD-1}}}\moddef{Choice constructor~{\nwtagstyle{}\subpageref{NW4MEPPp-UuAXD-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
constructor \nwlinkedidentc{ChConstrObj}{NW4MEPPp-54Dll-1}.Init(aTrm:TrmPtr);
begin
   IntKey := FuncTrmPtr(aTrm)^.FuncNr;
   // fTerms.InitSorted(0,CompRdTrms);
   fTerms.Init(0);
   fTerms.Insert(aTrm);
end;
\nwnotused{Choice constructor}\nwidentuses{\\{{\nwixident{ChConstrObj}}{ChConstrObj}}}\nwindexuse{\nwixident{ChConstrObj}}{ChConstrObj}{NW4MEPPp-UuAXD-1}\nwendcode{}\nwbegindocs{42}\nwdocspar

\nwenddocs{}\nwbegincode{43}\sublabel{NW4MEPPp-UaG4r-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-UaG4r-1}}}\moddef{Choice Constraint destructor~{\nwtagstyle{}\subpageref{NW4MEPPp-UaG4r-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
destructor \nwlinkedidentc{ChConstrObj}{NW4MEPPp-54Dll-1}.Done;
begin
   fTerms.DeleteAll;
   fTerms.Done;
end;
\nwnotused{Choice Constraint destructor}\nwidentuses{\\{{\nwixident{ChConstrObj}}{ChConstrObj}}}\nwindexuse{\nwixident{ChConstrObj}}{ChConstrObj}{NW4MEPPp-UaG4r-1}\nwendcode{}\nwbegindocs{44}\nwdocspar

\nwenddocs{}\nwbegincode{45}\sublabel{NW4MEPPp-qAgRS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-qAgRS-1}}}\moddef{Check if a formula contains bound variables~{\nwtagstyle{}\subpageref{NW4MEPPp-qAgRS-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
var \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1}: boolean;
procedure \nwlinkedidentc{CheckBound}{NW4MEPPp-qAgRS-1}(var fTrm:TrmPtr);
begin
   if (fTrm^.TrmSort=ikTrmBound) and (VarTrmPtr(fTrm)^.VarNr<=BoundVarNbr)
   then \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} := true;
end;
\nwindexdefn{\nwixident{CheckBound}}{CheckBound}{NW4MEPPp-qAgRS-1}\nwindexdefn{\nwixident{ThereAreBound}}{ThereAreBound}{NW4MEPPp-qAgRS-1}\eatline
\nwnotused{Check if a formula contains bound variables}\nwidentdefs{\\{{\nwixident{CheckBound}}{CheckBound}}\\{{\nwixident{ThereAreBound}}{ThereAreBound}}}\nwendcode{}\nwbegindocs{46}\nwdocspar
\nwenddocs{}\nwbegincode{47}\sublabel{NW4MEPPp-Dle7N-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-Dle7N-1}}}\moddef{Insert type~{\nwtagstyle{}\subpageref{NW4MEPPp-Dle7N-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(fTyp:TypPtr; aTrmNr: integer);
\{ zakldamy,ze ftyp, jest zuzywany \} \{ assume that ftype is used \}
var
   x,z,lCount: integer;
   lTypPtr: TypPtr;
label 1;
begin
   with Trms[aTrmNr] do
   begin
      repeat
         for z := 0 to XTypClass.Count-1 do
            with TypPtr(XTypClass.Items^[z])^ do
               if (TypSort = fTyp^.TypSort) and (ModNr = fTyp^.ModNr) and
                     \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(ModArgs,fTyp^.ModArgs) then
               begin
                  if fTyp^.UpperCluster^.IsSubsetOf(SuperCluster,\nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1}) then
                  begin
                     dispose(fTyp,Done);
                     exit;
                  end;
                  with fTyp^.UpperCluster^ do
                     for x := 0 to Count-1 do
                        SuperCluster^.Insert(AttrPtr(Items^[x])^.CopyAttribute);
                  if not SuperCluster^.fConsistent
                  then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(1);
                  dispose(fTyp,Done);
                  exit;
               end;
         \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(fTyp);
         with fTyp^.UpperCluster^ do
            for x := 0 to Count-1 do
               SuperCluster^.Insert(AttrPtr(Items^[x])^.CopyAttribute);
         if not SuperCluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(2);
         fTyp^.LowerCluster^.Done;
         fTyp^.UpperCluster^.Done;
         XTypClass.Insert(fTyp);
         if (fTyp^.TypSort<>ikTypMode) or (fTyp^.ModNr = 1) then break;
         fTyp := fTyp^.Widening;
      until false;
      lCount := XTypClass.Count;
      if fTyp^.TypSort = ikTypStruct then
         repeat
            with StructConstrPtr( Constr[ coStructMode].At( fTyp^.ModNr))^ do
               for z := 0 to fPrefixes.Count-1 do
               begin
                  lTypPtr := TypPtr(fPrefixes.Items^[z])^.InstTyp(fTyp^.ModArgs);
                  \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(lTypPtr);
                  lTypPtr^.LowerCluster^.Done;
                  lTypPtr^.UpperCluster^.Done;
                  for x := 0 to XTypClass.Count-1 do
                     with TypPtr(XTypClass.Items^[x])^ do
                        if (TypSort = lTypPtr^.TypSort) and (ModNr = lTypPtr^.ModNr) and
                              \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(ModArgs,lTypPtr^.ModArgs) then
                        begin
                           dispose(lTypPtr,Done);
                           goto 1
                        end;
                  XTypClass.Insert(lTypPtr);
                  1:
               end;
            if lCount >= XTypClass.Count then break;
            fTyp := XTypClass.Items^[lCount];
            inc(lCount);
         until false;
   end;
end;
\nwindexdefn{\nwixident{InsertType}}{InsertType}{NW4MEPPp-Dle7N-1}\eatline
\nwnotused{Insert type}\nwidentdefs{\\{{\nwixident{InsertType}}{InsertType}}}\nwidentuses{\\{{\nwixident{EqAttrs}}{EqAttrs}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{YType}}{YType}}}\nwindexuse{\nwixident{EqAttrs}}{EqAttrs}{NW4MEPPp-Dle7N-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-Dle7N-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-Dle7N-1}\nwindexuse{\nwixident{YType}}{YType}{NW4MEPPp-Dle7N-1}\nwendcode{}\nwbegindocs{48}\nwdocspar
\subsection{``Y'' Procedures}

\nwenddocs{}\nwbegincode{49}\sublabel{NW4MEPPp-1KdKcq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1KdKcq-1}}}\moddef{Y Procedures~{\nwtagstyle{}\subpageref{NW4MEPPp-1KdKcq-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Y Term list~{\nwtagstyle{}\subpageref{NW4MEPPp-stOEL-1}}\RA{}
\LA{}Y Attribute~{\nwtagstyle{}\subpageref{NW4MEPPp-4KjpLo-1}}\RA{}
\LA{}Y Cluster~{\nwtagstyle{}\subpageref{NW4MEPPp-1RVFLZ-1}}\RA{}
\LA{}Y Formula~{\nwtagstyle{}\subpageref{NW4MEPPp-2R1rnI-1}}\RA{}
\LA{}Y Equality Class~{\nwtagstyle{}\subpageref{NW4MEPPp-Q6gAz-1}}\RA{}
\LA{}Check if formula does not contain equality~{\nwtagstyle{}\subpageref{NW4MEPPp-1jv2gP-1}}\RA{}
\LA{}Y Term~{\nwtagstyle{}\subpageref{NW4MEPPp-1kz7f3-1}}\RA{}
\LA{}YY Term~{\nwtagstyle{}\subpageref{NW4MEPPp-1G6XDl-1}}\RA{}
\LA{}Substitute variable~{\nwtagstyle{}\subpageref{NW4MEPPp-390Yo4-1}}\RA{}
\LA{}Substitute pending variables~{\nwtagstyle{}\subpageref{NW4MEPPp-cNbbp-1}}\RA{}
\LA{}Union terms~{\nwtagstyle{}\subpageref{NW4MEPPp-1zWreN-1}}\RA{}

\nwnotused{Y Procedures}\nwendcode{}\nwbegindocs{50}\nwdocspar

\nwenddocs{}\nwbegincode{51}\sublabel{NW4MEPPp-stOEL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-stOEL-1}}}\moddef{Y Term list~{\nwtagstyle{}\subpageref{NW4MEPPp-stOEL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FTL: TrmList);
begin
   while FTL<>nil do
   begin
      \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(FTL^.XTrmPtr);
      FTL := FTL^.NextTrm
   end;
end;
\nwindexdefn{\nwixident{YTermList}}{YTermList}{NW4MEPPp-stOEL-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YTermList}}{YTermList}}}\nwidentuses{\\{{\nwixident{YTerm}}{YTerm}}}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-stOEL-1}\nwendcode{}\nwbegindocs{52}\nwdocspar
\nwenddocs{}\nwbegincode{53}\sublabel{NW4MEPPp-4KjpLo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4KjpLo-1}}}\moddef{Y Attribute~{\nwtagstyle{}\subpageref{NW4MEPPp-4KjpLo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YAttr}{NW4MEPPp-4KjpLo-1}(aAttr:AttrPtr);
begin
   \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(aAttr^.fAttrArgs);
end;

\nwindexdefn{\nwixident{YAttr}}{YAttr}{NW4MEPPp-4KjpLo-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YAttr}}{YAttr}}}\nwidentuses{\\{{\nwixident{YTermList}}{YTermList}}}\nwindexuse{\nwixident{YTermList}}{YTermList}{NW4MEPPp-4KjpLo-1}\nwendcode{}\nwbegindocs{54}\nwdocspar
\nwenddocs{}\nwbegincode{55}\sublabel{NW4MEPPp-1RVFLZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1RVFLZ-1}}}\moddef{Y Cluster~{\nwtagstyle{}\subpageref{NW4MEPPp-1RVFLZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YCluster}{NW4MEPPp-1RVFLZ-1}(aClu: AttrCollectionPtr);
var
   i: integer;
begin
   with aClu^ do
      for i := 0 to Count-1 do
         \nwlinkedidentc{YAttr}{NW4MEPPp-4KjpLo-1}(AttrPtr(Items^[i]));
end;
\nwindexdefn{\nwixident{YCluster}}{YCluster}{NW4MEPPp-1RVFLZ-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YCluster}}{YCluster}}}\nwidentuses{\\{{\nwixident{YAttr}}{YAttr}}}\nwindexuse{\nwixident{YAttr}}{YAttr}{NW4MEPPp-1RVFLZ-1}\nwendcode{}\nwbegindocs{56}\nwdocspar
\nwenddocs{}\nwbegincode{57}\sublabel{NW4MEPPp-1ByE5t-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1ByE5t-1}}}\moddef{Y Type~{\nwtagstyle{}\subpageref{NW4MEPPp-1ByE5t-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(FTyp: TypPtr);
begin
   if FTyp<>nil then
      with fTyp^ do
   begin
      \nwlinkedidentc{YCluster}{NW4MEPPp-1RVFLZ-1}(LowerCluster);
      \nwlinkedidentc{YCluster}{NW4MEPPp-1RVFLZ-1}(UpperCluster);
      \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(ModArgs);
   end;
end;
\nwindexdefn{\nwixident{YType}}{YType}{NW4MEPPp-1ByE5t-1}\eatline
\nwnotused{Y Type}\nwidentdefs{\\{{\nwixident{YType}}{YType}}}\nwidentuses{\\{{\nwixident{YCluster}}{YCluster}}\\{{\nwixident{YTermList}}{YTermList}}}\nwindexuse{\nwixident{YCluster}}{YCluster}{NW4MEPPp-1ByE5t-1}\nwindexuse{\nwixident{YTermList}}{YTermList}{NW4MEPPp-1ByE5t-1}\nwendcode{}\nwbegindocs{58}\nwdocspar
\nwenddocs{}\nwbegincode{59}\sublabel{NW4MEPPp-2R1rnI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2R1rnI-1}}}\moddef{Y Formula~{\nwtagstyle{}\subpageref{NW4MEPPp-2R1rnI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(FFrm: FrmPtr);
var
   z: integer;
begin
   with FFrm^ do
      case FrmSort of
         ikFrmNeg: \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(NegFrmPtr(fFrm)^.NEGArg);
         ikFrmConj:
            for z := 0 to ConjFrmPtr(fFrm)^.Conjuncts.Count-1 do
               \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(FrmPtr(ConjFrmPtr(fFrm)^.Conjuncts.Items^[z]));
         ikFrmUniv:
            begin
               inc(BoundVarNbr);
               \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(UnivFrmPtr(fFrm)^.Quantified);
               \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(UnivFrmPtr(fFrm)^.Scope);
               dec(BoundVarNbr);
            end;
         ikFrmSchPred,ikFrmPrivPred,ikFrmAttr,ikFrmPred:
            \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(PredFrmPtr(fFrm)^.PredArgs);
         ikFrmQual:
            begin
               \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(QualFrmPtr(fFrm)^.QualTyp);
               \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(QualFrmPtr(fFrm)^.QualTrm)
            end;
         ikFrmFlexConj:
            with FlexFrmPtr(fFrm)^ do
         begin
            \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(nLeftOrigFrm);
            \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(nRightOrigFrm);
            //       \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(nExpansion);
         end;
         ikFrmVerum,ikFrmError: ;
      else
      begin
         \{$IFDEF MDEBUG\}
         InfoChar(FrmSort);
         \{$ENDIF\}
         RunTimeError(2023);
      end;
      end;
end;
\nwindexdefn{\nwixident{YFormula}}{YFormula}{NW4MEPPp-2R1rnI-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YFormula}}{YFormula}}}\nwidentuses{\\{{\nwixident{YTerm}}{YTerm}}\\{{\nwixident{YTermList}}{YTermList}}\\{{\nwixident{YType}}{YType}}}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-2R1rnI-1}\nwindexuse{\nwixident{YTermList}}{YTermList}{NW4MEPPp-2R1rnI-1}\nwindexuse{\nwixident{YType}}{YType}{NW4MEPPp-2R1rnI-1}\nwendcode{}\nwbegindocs{60}\nwdocspar
\nwenddocs{}\nwbegincode{61}\sublabel{NW4MEPPp-Q6gAz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-Q6gAz-1}}}\moddef{Y Equality Class~{\nwtagstyle{}\subpageref{NW4MEPPp-Q6gAz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm: TrmPtr);
begin
   if \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} = MaxTrmNbr then
      \nwlinkedidentc{TrmOvfl}{NW4MEPPp-3tHI3f-3} := true
   else inc(\nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3});
   fTrm^.TrmInfo := \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3};
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3}] do
   begin
      \{ !!!!!!!!!!! kontrola rozmiaru \} \{ size control \}
      inc(\nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3});
      Term := NewVarTrm(ikTrmEqConst,\nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3});
      Term^.TrmInfo := \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3};
      NumValue.Determined := false;
      PolynomialValues.InitSorted(0,4,StdComparePolynomials);
      EqClass := NewTrmList(fTrm,nil);
      XTypClass.Init(4,4);
      \{ initialization with set type (the most general) \} 
      //  inicjalizacja z typem set (najbardziej ogolnym)
      XTypClass.Insert(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                      gBuiltIn[rqAny],nil));
      \{ set - start: throw case from gBuiltIn[rqSetMode] \}
      //!!!set - poczatek: wyrzucic przypadek z gBuiltIn[rqSetMode]
      //   XTypClass.Insert(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
      //                             gBuiltIn[rqSetMode],nil));
      //!!!set - koniec wyrzucic przypadek z gBuiltIn[rqSetMode]
      \{ set - end, throw the case from gBuiltIn[rqSetMode] \}
      SuperCluster := new(AttrCollectionPtr,Init(0,4));
   end;
end;
\nwindexdefn{\nwixident{YEqClass}}{YEqClass}{NW4MEPPp-Q6gAz-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YEqClass}}{YEqClass}}}\nwidentuses{\\{{\nwixident{EqClassNbr}}{EqClassNbr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmOvfl}}{TrmOvfl}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{EqClassNbr}}{EqClassNbr}{NW4MEPPp-Q6gAz-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-Q6gAz-1}\nwindexuse{\nwixident{TrmOvfl}}{TrmOvfl}{NW4MEPPp-Q6gAz-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-Q6gAz-1}\nwendcode{}\nwbegindocs{62}\nwdocspar
\nwenddocs{}\nwbegincode{63}\sublabel{NW4MEPPp-1jv2gP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1jv2gP-1}}}\moddef{Check if formula does not contain equality~{\nwtagstyle{}\subpageref{NW4MEPPp-1jv2gP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
var \nwlinkedidentc{E_free}{NW4MEPPp-1jv2gP-1}: boolean;

procedure \nwlinkedidentc{Check_E}{NW4MEPPp-1jv2gP-1}(var fTrm: TrmPtr);
begin
   if fTrm^.TrmSort=ikTrmEqConst then \nwlinkedidentc{E_free}{NW4MEPPp-1jv2gP-1} := false;
end;

\nwindexdefn{\nwixident{E{\_}free}}{E:unfree}{NW4MEPPp-1jv2gP-1}\nwindexdefn{\nwixident{Check{\_}E}}{Check:unE}{NW4MEPPp-1jv2gP-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{Check{\_}E}}{Check:unE}}\\{{\nwixident{E{\_}free}}{E:unfree}}}\nwendcode{}\nwbegindocs{64}\nwdocspar
\nwenddocs{}\nwbegincode{65}\sublabel{NW4MEPPp-1kz7f3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1kz7f3-1}}}\moddef{Y Term~{\nwtagstyle{}\subpageref{NW4MEPPp-1kz7f3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(var FTrm: TrmPtr);
var
   ii,z: integer;
   AType: TypPtr;
   lCommTrm,lCommTrm1,OrgTrm,lTrm: TrmPtr;
   lArgList,lArgList1,lArgList2: TrmList;
   lFunc,lFunc1,lIndex,lBoundVarNbr,lConstNr: integer;
label toexit;
begin
   //writeln(InfoFile,'  yterm<:',Emb);
   //InfoTerm(fTrm); InfoNewline;
   //inc(Emb);
   with FTrm^ do
   begin
      case TrmSort of
         ikTrmBound,ikTrmEqConst: goto toexit;
         ikTrmInfConst:
            with VarTrmPtr(fTrm)^ do
         begin
            if (VarNr < DTrm.Count) and (DTrm.Items^[VarNr]<>nil) then
            begin
               lConstNr := VarNr;
               dispose(fTrm);
               fTrm := DTrm.Items^[lConstNr];
               goto toexit
            end;
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            DTrm.AtInsert(VarNr,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].Term);
            with ConstDefPtr(InferConstDef.Items^[VarTrmPtr(fTrm)^.VarNr])^ do
               if fDetermined then
                  with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo] do
               begin
                  NumValue.Determined := true;
                  NumValue.NumericValue := fNumericValue;
               end;
            aType := CopyExpTyp(ConstDefPtr(InferConstDef.Items^[VarNr])^.fTyp);
            \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(aType);
            \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(aType,fTrm^.TrmInfo);
            fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].Term;
            goto toexit;
         end;
         ikTrmFunctor:
            with FuncTrmPtr(FTrm)^ do
         begin
            OrgTrm := CopyTerm(FTrm);
            if not YArgList(FuncArgs) then
            begin DisposeTrm(OrgTrm);
            goto toexit
            end;
            lArgList1 := CopyTermList(FuncArgs);
            \nwlinkedidentc{E_free}{NW4MEPPp-1jv2gP-1} := true;
            WithinTerm(OrgTrm,\nwlinkedidentc{Check_E}{NW4MEPPp-1jv2gP-1});
            if \nwlinkedidentc{E_free}{NW4MEPPp-1jv2gP-1} then aType := RoundUpTrmType(OrgTrm)
            else AType := CopyTrmType(OrgTrm);
            AdjustTrm(fTrm,lFunc,lArgList);
            if FuncTrmList[expTrmFunctor].Search(@lFunc,lIndex) then
            begin
               with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmFunctor].Items^[lIndex])^.fTerms do
                  for ii := 0 to Count-1 do
                  begin
                     if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgList,FuncTrmPtr(Items^[ii])^.FuncArgs) then
                     begin
                        \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                        DisposeTrmList(lArglist1);
                        fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[FuncTrmPtr(Items^[ii])^.TrmInfo].Term;
                        //causes loop
                        //::            \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(aType);
                        //::            \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(aType,Trms[FuncTrmPtr(Items^[ii])^.TrmInfo].Term^.TrmInfo);
                        DisposeTrm(OrgTrm);
                        goto toexit;
                     end;
                  end;
            end;
            lTrm := fTrm;
            fTrm := NewFuncTrm(lFunc,CopyTermList(lArgList));
            DisposeTrm(lTrm);
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            FuncTrmList[expTrmFunctor].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
            \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(aType);
            \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(aType,fTrm^.TrmInfo);
            lCommTrm1 := nil;
            with FuncTrmPtr(OrgTrm)^ do
            begin
               if gRevReq[AdjustedFuncNr(fTrm)] = rqZeroNumber then
               begin
                  \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].NumValue.Determined := true;
                  \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].NumValue.NumericValue := CZero;
               end;
               with ConstrTypPtr( Constr[ coFunctor].At(FuncNr))^ do
                  if syCommutativity in fProperties then
                  begin
                     lCommTrm := NewFuncTrm(FuncNr,SwapArguments(lArgList1,fFirstArg,fSecondArg));
                     AdjustTrm(lCommTrm,lFunc1,lArgList2);
                     lCommTrm1 := NewFuncTrm(lFunc1,CopyTermList(lArgList2));
                     DisposeTrm(lCommTrm);
                     lCommTrm1^.TrmInfo := \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3};
                     \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].EqClass^.NextTrm := NewTrmList(lCommTrm1,nil);
                  end;
               DisposeTrm(OrgTrm);
               DisposeTrmList(lArglist1);
            end;
            if lCommTrm1 <> nil then FuncTrmList[expTrmFunctor].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(lCommTrm1);
            fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].Term;
            goto toexit;
         end;
         ikTrmSchFunc:
            begin
               with FuncTrmPtr(fTrm)^ do
                  if not YArgList(FuncArgs) then goto toexit;
               \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            end;
         ikTrmPrivFunc:
            begin
               with FuncTrmPtr(fTrm)^ do
                  if not YArgList(FuncArgs) then goto toexit;
               \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
               FuncTrmList[expTrmPrivFunc].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
            end;
         ikTrmAggreg:
            with FuncTrmPtr(fTrm)^ do
         begin
            if not YArgList(FuncArgs) then goto toexit;
            if FuncTrmList[expTrmAggreg].Search(@FuncNr,lFunc) then
            begin
               with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmAggreg].Items^[lFunc])^.fTerms do
                  for ii := 0 to Count-1 do
                  begin
                     if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(FuncArgs,FuncTrmPtr(Items^[ii])^.FuncArgs) then
                     begin
                        \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                        fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[FuncTrmPtr(Items^[ii])^.TrmInfo].Term;
                        goto toexit;
                     end;
                  end;
            end;
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            FuncTrmList[expTrmAggreg].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
         end;
         ikTrmSelector:
            with FuncTrmPtr(fTrm)^ do
         begin
            if not YArgList(FuncArgs) then goto toexit;
            lTrm := FuncTrmList[expTrmSelector].\nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm);
            if lTrm <> nil then
            begin
               \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
               FTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lTrm^.TrmInfo].Term;
               goto toexit;
            end;
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            FuncTrmList[expTrmSelector].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
         end;
         ikTrmFraenkel:
            with FraenkelTrmPtr(fTrm)^ do
         begin
            lBoundVarNbr := BoundVarNbr;
            for z := 0 to LambdaArgs.Count-1 do
            begin
               inc(BoundVarNbr);
               \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(TypPtr(LambdaArgs.Items^[z]));
            end;
            \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(LambdaScope);
            \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(Compr);
            BoundVarNbr := lBoundVarNbr;
            \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} := false;
            WithInTerm(fTrm,\nwlinkedidentc{CheckBound}{NW4MEPPp-qAgRS-1});
            // Uwaga powinno byc to stala
            \{ Attention this should be constant \}
            mizassert(2027,\nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1});
            if \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} then
            begin \{DisposeTrm(fTrm);\}
               goto toexit
            end;
            WithInTerm(fTrm,ChChangeBound);
            if FrOper.Search(fTrm,ii) then
            begin
               DisposeTrm(fTrm);
               fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[FraenkelTrmPtr(FrOper.Items^[ii])^.TrmInfo].Term;
               goto toexit;
            end;
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            FrOper.Insert(fTrm);
         end;
         ikTrmChoice:
            with ChoiceTrmPtr(fTrm)^ do
         begin
            \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(ChoiceTyp);
            \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} := false;
            WithInTerm(fTrm,\nwlinkedidentc{CheckBound}{NW4MEPPp-qAgRS-1});
            if \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} then
            begin \{DisposeTrm(fTrm);\}
               goto toexit
            end;
            if ChoiceTerm.Search(fTrm,ii) then
            begin
               DisposeTrm(fTrm);
               fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ChoiceTrmPtr(ChoiceTerm.Items^[ii])^.TrmInfo].Term;
               goto toexit;
            end;
            \nwlinkedidentc{YEqClass}{NW4MEPPp-Q6gAz-1}(fTrm);
            ChoiceTerm.Insert(fTrm);
         end;
      else
      begin
         \{$IFDEF MDEBUG\}
         writeln(InfoFile,TrmSort,'|2024');
         \{$ENDIF\}
         RunTimeError(2024);
      end;
      end;
   end;
   AType := CopyTrmType(fTrm);
   \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(AType);
   \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(aType,fTrm^.TrmInfo);
   fTrm := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].Term;
   toexit:
      //dec(Emb);
      //writeln(infofile,'  yterm>: ',Emb);
end;
\nwindexdefn{\nwixident{YTerm}}{YTerm}{NW4MEPPp-1kz7f3-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YTerm}}{YTerm}}}\nwidentuses{\\{{\nwixident{AllocTerm}}{AllocTerm}}\\{{\nwixident{Check{\_}E}}{Check:unE}}\\{{\nwixident{CheckBound}}{CheckBound}}\\{{\nwixident{ConstrItem}}{ConstrItem}}\\{{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}}\\{{\nwixident{E{\_}free}}{E:unfree}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{FindTerm}}{FindTerm}}\\{{\nwixident{InsertType}}{InsertType}}\\{{\nwixident{ThereAreBound}}{ThereAreBound}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{YEqClass}}{YEqClass}}\\{{\nwixident{YFormula}}{YFormula}}\\{{\nwixident{YType}}{YType}}}\nwindexuse{\nwixident{AllocTerm}}{AllocTerm}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{Check{\_}E}}{Check:unE}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{CheckBound}}{CheckBound}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{E{\_}free}}{E:unfree}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{FindTerm}}{FindTerm}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{InsertType}}{InsertType}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{ThereAreBound}}{ThereAreBound}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{YEqClass}}{YEqClass}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{YFormula}}{YFormula}{NW4MEPPp-1kz7f3-1}\nwindexuse{\nwixident{YType}}{YType}{NW4MEPPp-1kz7f3-1}\nwendcode{}\nwbegindocs{66}\nwdocspar
\nwenddocs{}\nwbegincode{67}\sublabel{NW4MEPPp-1G6XDl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1G6XDl-1}}}\moddef{YY Term~{\nwtagstyle{}\subpageref{NW4MEPPp-1G6XDl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{YYTerm}{NW4MEPPp-1G6XDl-1}(fTrm: TrmPtr; var fi: integer);
var
   lArgList,lArglist1,aArgList: TrmList;
   lFunc,lFunc1,lIndex,k,ii,iNr,r: integer;
   lCommTrm,lTrm: TrmPtr;
   lTyp: TypPtr;
begin
   //writeln(InfoFile,' yyterm<:');
   //InfoTerm(fTrm); InfoNewline;
   with FTrm^ do
      case TrmSort of
        ikTrmNumeral:
           with VarTrmPtr(fTrm)^ do
              for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
                 with Trms[ii], NumValue do
                    if (EqClass <> nil) and Determined and
                       IsEQWithInt(NumericValue,VarNr) then
                    begin
                       DisposeTrm(fTrm);
                       fi := Term^.TrmInfo;
                       exit;
                    end;
        ikTrmFunctor:
           with FuncTrmPtr(FTrm)^ do
           begin
              \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FuncArgs);
              lCommTrm := nil;
              with ConstrTypPtr(Constr[coFunctor].Items^[FuncNr])^ do
                 if syCommutativity in fProperties then
                 begin
                    lCommTrm := NewFuncTrm(FuncNr,SwapArguments(FuncArgs,fFirstArg,fSecondArg));
                    AdjustTrm(lCommTrm,lFunc1,lArgList1);
                 end;
              AdjustTrm(fTrm,lFunc,lArgList);
              if FuncTrmList[expTrmFunctor].Search(@lFunc,lIndex) then
                 with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmFunctor].Items^[lIndex])^.fTerms do
                 begin
                    for ii := 0 to Count-1 do
                       with FuncTrmPtr(Items^[ii])^ do
                       begin
                          if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgList,FuncArgs) then
                          begin
                             \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                             fi := TrmInfo;
                             exit;
                          end;
                          if (lCommTrm <> nil) and \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgList1,FuncArgs) then
                          begin
                             \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                             fi := TrmInfo;
                             DisposeTrm(lCommTrm);
                             exit;
                          end;
                       end;
                 end;
           end;
        ikTrmSchFunc:
           with FuncTrmPtr(fTrm)^ do
           begin
              \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FuncArgs);
              lTrm := FuncTrmList[expTrmSchFunc].\nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm);
              if lTrm <> nil then
              begin
                 \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                 fi := lTrm^.TrmInfo;
                 exit;
              end;
           end;
        ikTrmPrivFunc:
           with FuncTrmPtr(fTrm)^ do
           begin
              \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FuncArgs);
              lTrm := FuncTrmList[expTrmPrivFunc].\nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm);
              if lTrm <> nil then
              begin
                 \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                 fi := lTrm^.TrmInfo;
                 exit;
              end;
           end;
        ikTrmSelector:
           with FuncTrmPtr(FTrm)^ do
           begin
              \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FuncArgs);
              lTrm := FuncTrmList[expTrmSelector].\nwlinkedidentc{FindTerm}{NW4MEPPp-3r8YNG-1}(fTrm);
              if lTrm <> nil then
              begin
                 \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                 fi := lTrm^.TrmInfo;
                 exit;
              end;
           end;
        ikTrmAggreg:
           with FuncTrmPtr(FTrm)^ do
           begin
              \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(FuncArgs);
              if FuncTrmList[expTrmAggreg].Search(@FuncNr,lFunc) then
              begin
                 with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmAggreg].Items^[lFunc])^.fTerms do
                    for ii := 0 to Count-1 do
                    begin
                       \{ Trzeba zadjustowac agregaty, tzn. obciac argumnety "over".
                       Nalezaloby zapisac oryginalny typ, ale dlaczego nie jest
                       to robione w wariancie ikTrmFunctor
                       \}
                       \{ You need to adjust the aggregates, i.e. cut off the "over" arguments.
                       It would be nice to save the original type, but why isn't this done in the ikTrmFunctor variant \}
                       lArgList := FuncArgs;
                       lArgList1 := FuncTrmPtr(Items^[ii])^.FuncArgs;
                       for k := 1 to AggrConstrPtr( Constr[ coAggregate].At( FuncNr))^.fAggregBase do
                       begin
                          lArgList := lArgList^.NextTrm;
                          lArgList1 := lArgList1^.NextTrm;
                       end;
                       if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgList,lArgList1) then
                       begin
                          \nwlinkedidentc{DisposeTrmRecAndList}{NW4MEPPp-3MAeyg-1}(FuncTrmPtr(fTrm));
                          fi := FuncTrmPtr(Items^[ii])^.TrmInfo;
                          exit;
                       end;
                    end;
              end;
           end;
        ikTrmFraenkel:
           with FraenkelTrmPtr(fTrm)^ do
           begin
              for ii := 0 to LambdaArgs.Count-1 do
              begin
                 inc(BoundVarNbr);
                 \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(TypPtr(LambdaArgs.Items^[ii]));
              end;
              \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(LambdaScope);
              \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(Compr);
              dec(BoundVarNbr,LambdaArgs.Count);
              \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} := false;
              WithInTerm(fTrm,\nwlinkedidentc{CheckBound}{NW4MEPPp-qAgRS-1});
              if \nwlinkedidentc{ThereAreBound}{NW4MEPPp-qAgRS-1} then
              begin
                 DisposeTrm(fTrm);
                 exit;
              end;
              WithInTerm(fTrm,ChChangeBound);
              if FrOper.Search(fTrm,ii) then
              begin
                 DisposeTrm(fTrm);
                 fi := TrmPtr(FrOper.Items^[ii])^.TrmInfo;
                 exit;
              end;
           end;
        ikTrmChoice:
           with ChoiceTrmPtr(fTrm)^ do
           begin
              \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(ChoiceTyp);
              if ChoiceTerm.Search(fTrm,ii) then
              begin
                 DisposeTrm(fTrm);
                 fi := TrmPtr(ChoiceTerm.Items^[ii])^.TrmInfo;
                 exit;
              end;
           end;
        //    ikTrmEqConst,
        ikTrmInfConst,ikTrmConstant:
        exit;
      else
      begin
         \{$IFDEF MDEBUG\}
         writeln(InfoFile,TrmSort,'|2026');
         \{$ENDIF\}
         RunTimeError(2026);
      end;
   end;
   
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fi].Term^.TrmInfo] do
      case fTrm^.TrmSort of
        ikTrmNumeral:
           with VarTrmPtr(fTrm)^,NumValue do
           begin
              if not Determined then
              begin
                 NumValue.Determined := true;
                 NumValue.NumericValue := IntToComplex(VarNr);
              end
              else if not IsEQWithInt(NumericValue,VarNr) then
                 \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(3);
              fTrm^.TrmInfo := fi;
           end;
        ikTrmFunctor:
           begin
              iNr := AdjustedFuncNr(fTrm);
              if gRevReq[iNr] = rqImaginaryUnit then
              begin
                 NumValue.Determined := true;
                 NumValue.NumericValue := CImUnit;
              end;
              if gRevReq[iNr] = rqZeroNumber then
              begin
                 NumValue.Determined := true;
                 NumValue.NumericValue := CZero;
              end;
              lTrm := fTrm;
              fTrm := NewFuncTrm(lFunc,CopyTermList(lArgList));
              fTrm^.TrmInfo := fi;
              DisposeTrm(lTrm);
              FuncTrmList[expTrmFunctor].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
              if lCommTrm <> nil then
              begin
                 lTrm := NewFuncTrm(lFunc1,CopyTermList(lArgList1));
                 DisposeTrm(lCommTrm);
                 lTrm^.TrmInfo := fi;
                 EqClass := NewTrmList(lTrm,EqClass);
                 FuncTrmList[expTrmFunctor].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(lTrm);
              end;
              EqClass := NewTrmList(fTrm,EqClass);
           end;
      else
      begin
         FTrm^.TrmInfo := fi;
         EqClass := NewTrmList(fTrm,EqClass);
         case fTrm^.TrmSort of
           ikTrmSchFunc: FuncTrmList[expTrmSchFunc].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
           ikTrmPrivFunc: FuncTrmList[expTrmPrivFunc].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
           ikTrmSelector: FuncTrmList[expTrmSelector].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
           ikTrmAggreg: FuncTrmList[expTrmAggreg].\nwlinkedidentc{AllocTerm}{NW4MEPPp-2nHUFT-1}(fTrm);
           ikTrmFraenkel: FrOper.Insert(fTrm);
           ikTrmChoice: ChoiceTerm.Insert(fTrm);
         end;
      end;
      end;
   //writeln(InfoFile,' yyterm:>');
end;
\nwindexdefn{\nwixident{YYTerm}}{YYTerm}{NW4MEPPp-1G6XDl-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{YYTerm}}{YYTerm}}}\nwidentuses{\\{{\nwixident{AllocTerm}}{AllocTerm}}\\{{\nwixident{CheckBound}}{CheckBound}}\\{{\nwixident{ConstrItem}}{ConstrItem}}\\{{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{FindTerm}}{FindTerm}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{ThereAreBound}}{ThereAreBound}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{YFormula}}{YFormula}}\\{{\nwixident{YTerm}}{YTerm}}\\{{\nwixident{YTermList}}{YTermList}}\\{{\nwixident{YType}}{YType}}}\nwindexuse{\nwixident{AllocTerm}}{AllocTerm}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{CheckBound}}{CheckBound}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{FindTerm}}{FindTerm}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{ThereAreBound}}{ThereAreBound}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{YFormula}}{YFormula}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{YTermList}}{YTermList}{NW4MEPPp-1G6XDl-1}\nwindexuse{\nwixident{YType}}{YType}{NW4MEPPp-1G6XDl-1}\nwendcode{}\nwbegindocs{68}\nwdocspar
\nwenddocs{}\nwbegincode{69}\sublabel{NW4MEPPp-390Yo4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-390Yo4-1}}}\moddef{Substitute variable~{\nwtagstyle{}\subpageref{NW4MEPPp-390Yo4-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwprevnextdefs{\relax}{NW4MEPPp-390Yo4-2}\nwenddeflinemarkup
function \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(aVar: integer;
                            aTerm: PolynomialPtr;
                            var aSubst: NatSet): boolean;
var
   t,i,lVar: integer;
   lPolynomialValues: MList;
begin
   \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1} := false;
   if aTerm^.HasTheVariable(aVar) then exit;
   lVar := Trms[aVar].Term^.TrmInfo;
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
         if (t <> lVar) and (EqClass <> nil) then
         begin
            lPolynomialValues.Init(0);
            i := 0;
            while i < PolynomialValues.Count do
            begin
               if PolynomialPtr(PolynomialValues.Items^[i])^.HasTheVariable(aVar) then
               begin
                  PolynomialPtr(PolynomialValues.Items^[i])^.InsertValue(aVar,aTerm);
                  if PolynomialPtr(PolynomialValues.Items^[i])^.IsNumeric then
                  begin
                     if not NumValue.Determined then
                     begin
                        aSubst.InsertElem(t);
                        NumValue.Determined := true;
                        PolynomialPtr(PolynomialValues.Items^[i])^.GetNumeric(NumValue.NumericValue);
                     end
                     else if not PolynomialPtr(PolynomialValues.Items^[i])^.IsNumericEqualWith(NumValue.NumericValue) then
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(4);
                  end;
                  lPolynomialValues.Insert(PolynomialValues.Items^[i]);
                  PolynomialValues.AtDelete(i);
                  \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1} := true;
               end else inc(i);
            end;
            for i := 0 to lPolynomialValues.Count-1 do
               PolynomialValues.Insert(lPolynomialValues.Items^[i]);
            lPolynomialValues.DeleteAll;
            lPolynomialValues.Done;
         end;
end;
\nwindexdefn{\nwixident{SubstituteVariable}}{SubstituteVariable}{NW4MEPPp-390Yo4-1}\eatline
\nwalsodefined{\\{NW4MEPPp-390Yo4-2}}\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{SubstituteVariable}}{SubstituteVariable}}}\nwidentuses{\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-390Yo4-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-390Yo4-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-390Yo4-1}\nwendcode{}\nwbegindocs{70}\nwdocspar
\nwenddocs{}\nwbegincode{71}\sublabel{NW4MEPPp-cNbbp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-cNbbp-1}}}\moddef{Substitute pending variables~{\nwtagstyle{}\subpageref{NW4MEPPp-cNbbp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}(var aPendingVarSubst: NatSet);
var
   t,k: integer;
   lSubst: boolean;
begin
   while aPendingVarSubst.Count > 0 do
   begin
      k := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[aPendingVarSubst.Items^[0].X].Term^.TrmInfo;
      aPendingVarSubst.AtDelete(0);
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k] do
      begin
         mizassert(3453,EqClass <> nil);
         if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k].PolynomialValues.Count = 1 then
            if \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(k,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k].PolynomialValues.Items^[0],aPendingVarSubst) then
               lSubst := true;
      end;
   end;
   
   repeat
      for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
            if (EqClass <> nil) and NumValue.Determined and
                  (PolynomialValues.Count = 1) then
               aPendingVarSubst.InsertElem(t);
      lSubst := false;
      while aPendingVarSubst.Count > 0 do
      begin
         k := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[aPendingVarSubst.Items^[0].X].Term^.TrmInfo;
         aPendingVarSubst.AtDelete(0);
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k] do
         begin
            mizassert(3453,EqClass <> nil);
            if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k].PolynomialValues.Count = 1 then
               if \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(k,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[k].PolynomialValues.Items^[0],aPendingVarSubst) then
                  lSubst := true;
         end;
      end;
   until not lSubst;
   aPendingVarSubst.Done;
end;
\nwindexdefn{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}}\nwidentuses{\\{{\nwixident{SubstituteVariable}}{SubstituteVariable}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SubstituteVariable}}{SubstituteVariable}{NW4MEPPp-cNbbp-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-cNbbp-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-cNbbp-1}\nwendcode{}\nwbegindocs{72}\nwdocspar
\nwenddocs{}\nwbegincode{73}\sublabel{NW4MEPPp-1zWreN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1zWreN-1}}}\moddef{Union terms~{\nwtagstyle{}\subpageref{NW4MEPPp-1zWreN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(fEqNr1,fEqNr2: integer);
var
   p,z,i,j: integer;
   LTL1: TrmList;
   lClusterPtr: AttrCollectionPtr;
   lPendingVarSubst: NatSet;
begin
   fEqNr1 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fEqNr1].Term^.TrmInfo;
   fEqNr2 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fEqNr2].Term^.TrmInfo;
   if fEqNr1 <> fEqNr2 then
   begin
      if fEqNr1 < fEqNr2 then
      begin
         p := fEqNr1;
         fEqNr1 := fEqNr2;
         fEqNr2 := p
      end;
      clash := true;
      if Trms[fEqNr1].NumValue.Determined then
         if Trms[fEqNr2].NumValue.Determined then
         begin
            if not AreEqComplex(Trms[fEqNr1].NumValue.NumericValue,Trms[fEqNr2].NumValue.NumericValue) then
            begin
               \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(5);
               exit;
            end;
         end
         else
         begin
            Trms[fEqNr2].NumValue.Determined := Trms[fEqNr1].NumValue.Determined;
            Trms[fEqNr2].NumValue.NumericValue := Trms[fEqNr1].NumValue.NumericValue;
         end;
      //    Laczenie eqclass
      //    wynik Trms[fEqNr2].EqClass
      LTL1 := Trms[fEqNr1].EqClass;
      while LTL1<>nil do
      begin
         \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[LTL1^.XTrmPtr^.TrmInfo].Term^.TrmInfo := fEqNr2;
         LTL1 := LTL1^.NextTrm;
      end;
      LTL1 := LastElem(Trms[fEqNr2].EqClass);
      LTL1^.NextTrm := Trms[fEqNr1].EqClass;
      Trms[fEqNr1].EqClass := nil;
      // Laczenie superclusterow \{ Connecting superclusters \}
      // \{result\} wynik Trms[fEqNr2].SuperCluster
      // po polaczeniu eqclass moze pojawic sie nowa sprzcznosc.
      \{ after merging eqclass, a new contradiction may appear. \}
      with Trms[fEqNr2],SuperCluster^ do
      begin
         lClusterPtr := new(AttrCollectionPtr,Init(Count,4));
         for z := 0 to Count-1 do
            lClusterPtr^.Insert(AttrPtr(Items^[z])^.CopyAttribute);
         for z := 0 to Trms[fEqNr1].SuperCluster^.Count-1 do
            lClusterPtr^.Insert(AttrPtr(Trms[fEqNr1].SuperCluster^.Items^[z])^.CopyAttribute);
         dispose(Supercluster,Done);
         Supercluster := lClusterPtr;
      end;
      if not Trms[fEqNr2].SuperCluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(6);
      dispose(Trms[fEqNr1].SuperCluster,Done);
      Trms[fEqNr1].SuperCluster := nil;
      //   Laczenie listy typow \{ Combining a list of types \}
      for z := 0 to Trms[fEqNr1].XTypClass.Count-1 do
         \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(Trms[fEqNr1].XTypClass.Items^[z],fEqNr2);
      Trms[fEqNr1].XTypClass.DeleteAll;
      //    wartosc wielomianowa \{ polynomial value \}
      Trms[fEqNr2].PolynomialValues.AppendTo(Trms[fEqNr1].PolynomialValues);
      Trms[fEqNr1].PolynomialValues.DeleteAll;
      with Trms[fEqNr2] do
         if PolynomialValues.Count=2 then
         begin
            // eliminacja pojedynczych zmiennych poprzez ich podstawienie
            // eqklasa zawiera dwie wartosci wielamianowe (wynik polaczenia)
            \{ elimination of single variables by substituting them
              eqclass contains two polynomial values (the result of
              the combination) \}
            lPendingVarSubst.Init(0,8);
            i := PolynomialPtr(PolynomialValues.Items^[0])^.IsVariable;
            j := PolynomialPtr(PolynomialValues.Items^[1])^.IsVariable;
            if i > 0 then
            begin
               if (j > 0) and (i < j) then
               begin
                  PolynomialValues.AtFree(1);
                  \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(j,PolynomialValues.Items^[0],lPendingVarSubst);
               end
               else
               begin
                  PolynomialValues.AtFree(0);
                  \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(i,PolynomialValues.Items^[0],lPendingVarSubst);
               end
            end
            else if j > 0 then
            begin
               PolynomialValues.AtFree(1);
               \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(j,PolynomialValues.Items^[0],lPendingVarSubst);
            end;
            \nwlinkedidentc{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}(lPendingVarSubst);
         end;
   end;
end;
\nwindexdefn{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-1zWreN-1}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwidentuses{\\{{\nwixident{InsertType}}{InsertType}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}\\{{\nwixident{SubstituteVariable}}{SubstituteVariable}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{InsertType}}{InsertType}{NW4MEPPp-1zWreN-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-1zWreN-1}\nwindexuse{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}{NW4MEPPp-1zWreN-1}\nwindexuse{\nwixident{SubstituteVariable}}{SubstituteVariable}{NW4MEPPp-1zWreN-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1zWreN-1}\nwendcode{}\nwbegindocs{74}\nwdocspar
\subsection{Rational Arithmetic}

\nwenddocs{}\nwbegincode{75}\sublabel{NW4MEPPp-1QLcNW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1QLcNW-1}}}\moddef{Rational arithmetic functions~{\nwtagstyle{}\subpageref{NW4MEPPp-1QLcNW-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Add two rationals~{\nwtagstyle{}\subpageref{NW4MEPPp-2fQfeG-1}}\RA{}
\LA{}Rational successor function~{\nwtagstyle{}\subpageref{NW4MEPPp-46PllF-1}}\RA{}
\LA{}Negate rational number~{\nwtagstyle{}\subpageref{NW4MEPPp-1alA74-1}}\RA{}
\LA{}Multiply rational numbers~{\nwtagstyle{}\subpageref{NW4MEPPp-4bOVm6-1}}\RA{}
\LA{}Invert a rational number~{\nwtagstyle{}\subpageref{NW4MEPPp-4Wy9FH-1}}\RA{}
\LA{}Add an integer to both sides of an equation~{\nwtagstyle{}\subpageref{NW4MEPPp-2lqlVt-1}}\RA{}
\LA{}Process a system of linear equations~{\nwtagstyle{}\subpageref{NW4MEPPp-3H6RSw-1}}\RA{}
\LA{}Process Polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-19YZc6-1}}\RA{}
\LA{}Add polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-k1T1A-1}}\RA{}

\nwnotused{Rational arithmetic functions}\nwendcode{}\nwbegindocs{76}\nwdocspar

\nwenddocs{}\nwbegincode{77}\sublabel{NW4MEPPp-2fQfeG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2fQfeG-1}}}\moddef{Add two rationals~{\nwtagstyle{}\subpageref{NW4MEPPp-2fQfeG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RatAdd}{NW4MEPPp-2fQfeG-1}(fVal1,fVal2: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1}; var fVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
begin
   fVal.Determined := false;
   if fVal1.Determined and fVal2.Determined then
   begin
      fVal.Determined := true;
      fVal.NumericValue := ComplexAdd(fVal1.NumericValue,fVal2.NumericValue);
   end;
end;
\nwindexdefn{\nwixident{RatAdd}}{RatAdd}{NW4MEPPp-2fQfeG-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{RatAdd}}{RatAdd}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-2fQfeG-1}\nwendcode{}\nwbegindocs{78}\nwdocspar
\nwenddocs{}\nwbegincode{79}\sublabel{NW4MEPPp-46PllF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-46PllF-1}}}\moddef{Rational successor function~{\nwtagstyle{}\subpageref{NW4MEPPp-46PllF-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RatSucc}{NW4MEPPp-46PllF-1}(fVal1: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1}; var fVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
begin
   fVal.Determined := false;
   if fVal1.Determined and IsNaturalNumber(fVal1.NumericValue) then
      \nwlinkedidentc{RatAdd}{NW4MEPPp-2fQfeG-1}(fVal1,\nwlinkedidentc{One}{NW4MEPPp-3tHI3f-2},fVal);
end;
\nwindexdefn{\nwixident{RatSucc}}{RatSucc}{NW4MEPPp-46PllF-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{RatSucc}}{RatSucc}}}\nwidentuses{\\{{\nwixident{One}}{One}}\\{{\nwixident{RatAdd}}{RatAdd}}\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{One}}{One}{NW4MEPPp-46PllF-1}\nwindexuse{\nwixident{RatAdd}}{RatAdd}{NW4MEPPp-46PllF-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-46PllF-1}\nwendcode{}\nwbegindocs{80}\nwdocspar
\nwenddocs{}\nwbegincode{81}\sublabel{NW4MEPPp-1alA74-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1alA74-1}}}\moddef{Negate rational number~{\nwtagstyle{}\subpageref{NW4MEPPp-1alA74-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RatOpp}{NW4MEPPp-1alA74-1}(fVal1:\nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1}; var fVal:\nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
begin
   fVal.Determined := false;
   if fVal1.Determined then
   begin
      fVal.Determined := true;
      fVal.NumericValue := ComplexNeg(fVal1.NumericValue);
   end;
end;
\nwindexdefn{\nwixident{RatOpp}}{RatOpp}{NW4MEPPp-1alA74-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{RatOpp}}{RatOpp}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-1alA74-1}\nwendcode{}\nwbegindocs{82}\nwdocspar
\nwenddocs{}\nwbegincode{83}\sublabel{NW4MEPPp-4bOVm6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4bOVm6-1}}}\moddef{Multiply rational numbers~{\nwtagstyle{}\subpageref{NW4MEPPp-4bOVm6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RatMult}{NW4MEPPp-4bOVm6-1}(fVal1,fVal2: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1}; var fVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
begin
   fVal.Determined := false;
   if fVal1.Determined and fVal2.Determined then
   begin
      fVal.Determined := true;
      fVal.NumericValue := ComplexMult(fVal1.NumericValue,fVal2.NumericValue);
   end;
end;
\nwindexdefn{\nwixident{RatMult}}{RatMult}{NW4MEPPp-4bOVm6-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{RatMult}}{RatMult}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-4bOVm6-1}\nwendcode{}\nwbegindocs{84}\nwdocspar
\nwenddocs{}\nwbegincode{85}\sublabel{NW4MEPPp-4Wy9FH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4Wy9FH-1}}}\moddef{Invert a rational number~{\nwtagstyle{}\subpageref{NW4MEPPp-4Wy9FH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(fVal1:\nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1}; var fVal:\nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
begin
   fVal.Determined := false;
   if fVal1.Determined and not IsEqWithInt(fVal1.NumericValue,0) then
   begin
      fVal.Determined := true;
      fVal.NumericValue := ComplexInv(fVal1.NumericValue);
  end;
end;
\nwindexdefn{\nwixident{RatInv}}{RatInv}{NW4MEPPp-4Wy9FH-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{RatInv}}{RatInv}}}\nwidentuses{\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-4Wy9FH-1}\nwendcode{}\nwbegindocs{86}\nwdocspar
\nwenddocs{}\nwbegincode{87}\sublabel{NW4MEPPp-2lqlVt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2lqlVt-1}}}\moddef{Add an integer to both sides of an equation~{\nwtagstyle{}\subpageref{NW4MEPPp-2lqlVt-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(var aEquals: IntRel; LArg,RArg: integer);
var
   x: integer;
begin
   if LArg = RArg then exit;
   if LArg > RArg then
   begin
      x := LArg;
      LArg := RArg;
      RArg := x
   end;
   aEquals.AssignPair(LArg,RArg);
end;
\nwindexdefn{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-2lqlVt-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{AddEquality}}{AddEquality}}}\nwendcode{}\nwbegindocs{88}\nwdocspar
\nwenddocs{}\nwbegincode{89}\sublabel{NW4MEPPp-3H6RSw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3H6RSw-1}}}\moddef{Process a system of linear equations~{\nwtagstyle{}\subpageref{NW4MEPPp-3H6RSw-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ProcessLinearEquations}{NW4MEPPp-3H6RSw-1}(var aEquals:IntRel;
                                 var aPolynomials:MCollection);
var
   i,j,l,i1,i2,t1,t2,lVar: integer;
   lPolynomial,lEq: PolynomialPtr;
   lPolynomials,lEquations: MSortedCollection;
   lVariables: MSortedList;
   lMonomial: MonomialPtr;
label 1,2;
begin
   aPolynomials.Init(0,8);
   if aEquals.Count = 0 then exit;
   lPolynomials.InitSorted(0,4,ComparePolynomials);
   for i := 0 to aEquals.Count-1 do
      with aEquals.Items^[i] do
         if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Count > 0) and
               (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Count > 0) then
         begin
            lPolynomial := DiffPolynomials(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Items^[0],
                                           \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[0]);
            if lPolynomial^.IsNumeric then
            begin
               if not lPolynomial^.IsNumericEqualWith(CZero) then
               begin
                  dispose(lPolynomial,Done); \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(7);
                  exit;
               end;
               dispose(lPolynomial,Done);
            end
            else lPolynomials.Insert(lPolynomial);
         end;
   if lPolynomials.Count = 0 then
   begin
      lPolynomials.Done;
      exit;
   end;
   lEquations.InitSorted(0,4,ComparePolynomials);
   lVariables.InitSorted(0,CompareMonomials);
   for i := 0 to lPolynomials.Count-1 do
      with PolynomialPtr(lPolynomials.Items^[i])^ do
   begin
      lEq := new(PolynomialPtr,InitSorted(0,4,CompareMonomials));
      for j := 0 to Count-1 do
         if MonomialPtr(Items^[j])^.IsNumeric then
            lEq^.Insert(new(MonomialPtr,Init(MonomialPtr(Items^[j])^.nCoefficient)))
         else
         begin
            lMonomial := new(MonomialPtr,Init(COne));
            lMonomial^.nPowerProduct.CopyNatFunc(MonomialPtr(Items^[j])^.nPowerProduct);
            if not lVariables.Search(lMonomial,l) then
               lVariables.Insert(lMonomial)
            else dispose(lMonomial,Done);
            lEq^.Insert(new(MonomialPtr,InitMonomial(MonomialPtr(Items^[j])^.nCoefficient,l)));
         end;
      lEquations.Insert(lEq);
   end;
   lPolynomials.Done;
   GaussElimination(lEquations,\nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3});
   \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(\nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3});
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      lEquations.Done;
      lVariables.Done;
      exit;
   end;
   for i := 0 to lEquations.Count-1 do
      with PolynomialPtr(lEquations.Items^[i])^ do
   begin
      lPolynomial := new(PolynomialPtr,InitSorted(0,4,CompareMonomials));
      for j := 0 to Count-1 do
         if MonomialPtr(Items^[j])^.IsNumeric then
            lPolynomial^.Insert(new(MonomialPtr,Init(MonomialPtr(Items^[j])^.nCoefficient)))
         else
         begin
            lVar := MonomialPtr(Items^[j])^.nPowerProduct.Items^[0].X;
            lMonomial := MonomialPtr(MonomialPtr(lVariables.Items^[lVar])^.MCopy);
            lMonomial.nCoefficient := MonomialPtr(Items^[j])^.nCoefficient;
            lPolynomial^.Insert(lMonomial);
         end;
      aPolynomials.Insert(lPolynomial);
   end;
   \{$IFDEF MDEBUG\}
   //writeln(infofile,'Rozwiniete rownosci ("Gauss" elimination)');
   //for i := 0 to aPolynomials.Count-1 do
   //begin
   //write(infofile,i,': ');
   //infopolynomial(aPolynomials.Items^[i]);
   //infonewline;
   //end;
   \{$ENDIF\};
   for t1 := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      if (Trms[t1].EqClass<>nil) and (Trms[t1].PolynomialValues.Count>0) then
         for t2 := t1+1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
            if (Trms[t2].EqClass<>nil) and (Trms[t2].PolynomialValues.Count>0) and
                  (aEquals.IndexOf(t1,t2) < 0) and (aEquals.IndexOf(t2,t1) < 0) then
            begin
               for i1 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t1].PolynomialValues.Count-1 do
                  for i2 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t2].PolynomialValues.Count-1 do
                  begin
                     lPolynomial := DiffPolynomials(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t1].PolynomialValues.Items^[i1],
                                                    \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t2].PolynomialValues.Items^[i2]);
                     lEq := new(PolynomialPtr,InitSorted(0,4,CompareMonomials));
                     with lPolynomial^ do
                        for j := 0 to Count-1 do
                           if MonomialPtr(Items^[j])^.IsNumeric then
                              lEq^.Insert(new(MonomialPtr,Init(MonomialPtr(Items^[j])^.nCoefficient)))
                           else
                           begin
                              lMonomial := new(MonomialPtr,Init(COne));
                              lMonomial^.nPowerProduct.CopyNatFunc(MonomialPtr(Items^[j])^.nPowerProduct);
                              if not lVariables.Search(lMonomial,l) then
                              begin dispose(lMonomial,Done);
                              goto 1;
                              end;
                              lEq^.Insert(new(MonomialPtr,InitMonomial(MonomialPtr(Items^[j])^.nCoefficient,l)));
                           end;
                     if lEq^.IsNumeric then
                     begin
                        if lEq^.IsNumericEqualWith(CZero) then
                        begin
                           \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(aEquals,t1,t2);
                           dispose(lPolynomial,Done);
                           dispose(lEq,Done);
                           goto 2;
                        end;
                        goto 1;
                     end;
                     lEq := LinearEquationReduce(lEq,lEquations);
                     if lEq^.IsNumeric then
                     begin
                        if lEq^.IsNumericEqualWith(CZero) then
                        begin
                           \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(aEquals,t1,t2);
                           dispose(lPolynomial,Done);
                           dispose(lEq,Done);
                           goto 2;
                        end;
                        goto 1;
                     end;
                     1:
                        dispose(lPolynomial,Done);
                     dispose(lEq,Done);
                  end;
               2:
            end;
   lEquations.Done;
   lVariables.Done;
end;

\nwindexdefn{\nwixident{ProcessLinearEquations}}{ProcessLinearEquations}{NW4MEPPp-3H6RSw-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{ProcessLinearEquations}}{ProcessLinearEquations}}}\nwidentuses{\\{{\nwixident{AddEquality}}{AddEquality}}\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-3H6RSw-1}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-3H6RSw-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-3H6RSw-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-3H6RSw-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-3H6RSw-1}\nwendcode{}\nwbegindocs{90}\nwdocspar
\nwenddocs{}\nwbegincode{91}\sublabel{NW4MEPPp-19YZc6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-19YZc6-1}}}\moddef{Process Polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-19YZc6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ProcessPolynomialValues}{NW4MEPPp-19YZc6-1}(var aEquals:IntRel;
                                  var aPolynomials:MCollection);
var
   i,i1,i2,t1,t2: integer;
   lPolynomial  : PolynomialPtr;
   aTransOrder  : NatFuncPtr;
   rPolynomials : MCollection;
label 1;
begin
   if aPolynomials.Count = 0 then exit;
   new(aTransOrder,InitNatFunc(20,20));
   rPolynomials.CopyList(aPolynomials);
   for t1 := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      if (Trms[t1].EqClass<>nil) and (Trms[t1].PolynomialValues.Count>0) then
         for i := 0 to Trms[t1].PolynomialValues.Count-1 do
            rPolynomials.Insert(MListPtr(Trms[t1].PolynomialValues.Items^[i])^.MCopy);
   RecodeVariableOrder(rPolynomials,aPolynomials.Count,aTransOrder);
   \{$IFDEF GDEBUG\}
   writeln(infofile,'--------------');infostring('TransOrder: ');infonatfunc(aTransOrder^);infonewline;
   \{$ENDIF\};
   rPolynomials.Done;
   \{$IFDEF GDEBUG\}
   writeln(infofile,'Before Groebner');
   for i := 0 to aPolynomials.Count-1 do
   begin
      write(infofile,i,': ');
      infopolynomial(aPolynomials.Items^[i]);
      infonewline;
   end;
   \{$ENDIF\};
   RecodeVariables(aPolynomials,aTransOrder);
   \{$IFDEF GDEBUG\}
   writeln(infofile,'TrmNbr=',trmnbr);
   \{$ENDIF\};
   for t1 := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      if (Trms[t1].EqClass<>nil) and (Trms[t1].PolynomialValues.Count>0) then
      begin
         \{$IFDEF GDEBUG\}
         write(infofile,'trms[',t1,']=');
         for i := 0 to Trms[t1].PolynomialValues.Count-1 do
         begin
            infopolynomial(PolynomialPtr(Trms[t1].PolynomialValues.Items^[i]));infonewline;
         end;
         \{$ENDIF\};
         RecodeVariables(Trms[t1].PolynomialValues,aTransOrder);
      end;
   dispose(aTransOrder,Done);
   ExtendToGroebnerBasis0(aPolynomials);
   \{$IFDEF GDEBUG\}
   writeln(infofile,'After Groebner');
   for i := 0 to aPolynomials.Count-1 do
   begin
      write(infofile,i,': ');
      infopolynomial(aPolynomials.Items^[i]);
      infonewline;
   end;
   if not CheckGroebnerBasis(aPolynomials) then
   begin
      writeln(infofile,'NO GROEBNER!!!!!!!!!!!!!!!');
      halt(1);
   end;
   \{$ENDIF\};
   for t1 := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      if (Trms[t1].EqClass<>nil) and (Trms[t1].PolynomialValues.Count>0) then
         for t2 := t1+1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         begin
            if (Trms[t2].EqClass<>nil) and (Trms[t2].PolynomialValues.Count>0) and
                  (aEquals.IndexOf(t1,t2) < 0) and (aEquals.IndexOf(t2,t1) < 0) then
               for i1 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t1].PolynomialValues.Count-1 do
                  for i2 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t2].PolynomialValues.Count-1 do
                  begin
                     lPolynomial := DiffPolynomials(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t1].PolynomialValues.Items^[i1],
                                                    \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t2].PolynomialValues.Items^[i2]);
                     lPolynomial := Reduction(lPolynomial,aPolynomials);
                     if lPolynomial^.IsNumeric then
                        if lPolynomial^.IsNumericEqualWith(CZero) then
                        begin
                           \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(aEquals,t1,t2);
                           dispose(lPolynomial,Done);
                           goto 1;
                        end;
                     dispose(lPolynomial,Done);
                  end;
            1:
         end;
end;

\nwindexdefn{\nwixident{ProcessPolynomialValues}}{ProcessPolynomialValues}{NW4MEPPp-19YZc6-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{ProcessPolynomialValues}}{ProcessPolynomialValues}}}\nwidentuses{\\{{\nwixident{AddEquality}}{AddEquality}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-19YZc6-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-19YZc6-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-19YZc6-1}\nwendcode{}\nwbegindocs{92}\nwdocspar
\nwenddocs{}\nwbegincode{93}\sublabel{NW4MEPPp-k1T1A-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-k1T1A-1}}}\moddef{Add polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-k1T1A-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1QLcNW-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AddPolynomialValues}{NW4MEPPp-k1T1A-1};
var
   k,t,i,i1,i2,lArg1,lArg2,lCount,lLevel: integer;
   lVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1};
   lEqClass: TrmList;
   lTrm: TrmPtr;
   lPolynomial1,lPolynomial2: PolynomialPtr;
   lAddedValues: NatSet;
   ArgsNr: array[1..MaxTrmNbr] of NatSet;
   lPolynomialValues: array[1..MaxTrmNbr] of MSortedCollection;
   lValues: array[1..MaxTrmNbr] of MList;
begin
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
   begin
      ArgsNr[t].Init(0,4);
      lPolynomialValues[t].InitSorted(0,4,StdComparePolynomials);
      if (EqClass <> nil) and (PolynomialValues.Count <> 0) then
      begin
         lEqClass := EqClass;
         while lEqClass <> nil do
         begin
            lTrm := lEqClass^.XTrmPtr;
            lEqClass := lEqClass^.NextTrm;
            if lTrm^.TrmSort = ikTrmFunctor then
               with FuncTrmPtr(lTrm)^ do
            begin
               case gRevReq[FuncNr] of
                  rqRealAdd, rqRealMult, rqRealDiff:
                     begin
                        lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                        lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                        if (lArg1 <> t) and (lArg2 <> t) then
                        begin
                           ArgsNr[t].InsertElem(lArg1);
                           ArgsNr[t].InsertElem(lArg2);
                           for i1 := 0 to Trms[lArg1].PolynomialValues.Count-1 do
                              for i2 := 0 to Trms[lArg2].PolynomialValues.Count-1 do
                              begin
                                 lPolynomial1 := PolynomialPtr(PolynomialPtr(Trms[lArg1].PolynomialValues.Items^[i1])^.MCopy);
                                 lPolynomial2 := PolynomialPtr(PolynomialPtr(Trms[lArg2].PolynomialValues.Items^[i2])^.MCopy);
                                 case gRevReq[FuncNr] of
                                    rqRealAdd:
                                       lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,lPolynomial2));
                                    rqRealMult:
                                       lPolynomialValues[t].Insert(MultPolynomials(lPolynomial1,lPolynomial2));
                                    rqRealDiff:
                                       lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,NMultPolynomial(CMinusOne,lPolynomial2)));
                                 end;
                                 dispose(lPolynomial2,Done);
                                 dispose(lPolynomial1,Done);
                              end;
                        end;
                     end;
                  rqRealNeg:
                     begin
                        lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                        if lArg1 <> t then
                        begin
                           ArgsNr[t].InsertElem(lArg1);
                           for i1 := 0 to Trms[lArg1].PolynomialValues.Count-1 do
                           begin
                              lPolynomial1 := PolynomialPtr(PolynomialPtr(Trms[lArg1].PolynomialValues.Items^[i1])^.MCopy);
                              lPolynomialValues[t].Insert(NMultPolynomial(CMinusOne,lPolynomial1));
                              dispose(lPolynomial1,Done);
                           end;
                        end;
                     end;
                  rqRealDiv:
                     begin
                        lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                        lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                        \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(Trms[lArg2].NumValue,lVal);
                        if lVal.Determined and (lArg1 <> t) then
                        begin
                           ArgsNr[t].InsertElem(lArg1);
                           for i1 := 0 to Trms[lArg1].PolynomialValues.Count-1 do
                           begin
                              lPolynomial1 := PolynomialPtr(PolynomialPtr(Trms[lArg1].PolynomialValues.Items^[i1])^.MCopy);
                              lPolynomialValues[t].Insert(NMultPolynomial(lVal.NumericValue,lPolynomial1));
                              dispose(lPolynomial1,Done);
                           end
                        end
                     end;
               end;
            end;
         end;
      end;
   end;
   lAddedValues.Init(0,4);
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
   begin
      lValues[t].Init(0);
      for i := 0 to lPolynomialValues[t].Count-1 do
         if not PolynomialValues.Search(lPolynomialValues[t].Items^[i],lCount) then
         begin
            lValues[t].Insert(lPolynomialValues[t].Items^[i]);
            PolynomialValues.AtInsert(lCount, lPolynomialValues[t].Items^[i]);
            lAddedValues.InsertElem(t);
         end
         else dispose(PolynomialPtr(lPolynomialValues[t].Items^[i]),Done);
      lPolynomialValues[t].DeleteAll;
   end;
   \{$IFDEF MDEBUG\}
   writeln(InfoFile,'---------------------- w trakcie AddValues');
   infoeqclasses;
   writeln(InfoFile,'---------------------- koniec wydruku w trakcie AddValues');
   \{$ENDIF\};
   lLevel := 0;
   repeat
      for k := 0 to lAddedValues.Count-1 do
      begin
         //with lAddedValues.Items^[0] do
         //writeln(infofile,'obrabia added: ',X,'->',Y);
         with lAddedValues.Items^[0] do
            for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
               with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
                  if (T <> X) and ArgsNr[t].HasInDom(X) then
                  begin
                     mizassert(4623,PolynomialValues.Count <> 0);
                     lEqClass := EqClass;
                     while lEqClass <> nil do
                     begin
                        lTrm := lEqClass^.XTrmPtr;
                        lEqClass := lEqClass^.NextTrm;
                        if lTrm^.TrmSort = ikTrmFunctor then
                           with FuncTrmPtr(lTrm)^ do
                        begin
                           case gRevReq[FuncNr] of
                              rqRealAdd, rqRealMult, rqRealDiff:
                                 begin
                                    lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                                    lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                                    if (lArg1 = X) and (lArg2 = X) then
                                    begin
                                       for i := 0 to lValues[X].Count-1 do
                                       begin
                                          lPolynomial1 := lValues[X].Items^[i];
                                          case gRevReq[FuncNr] of
                                             rqRealAdd:
                                                lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,lPolynomial1));
                                             rqRealMult:
                                                lPolynomialValues[t].Insert(MultPolynomials(lPolynomial1,lPolynomial1));
                                             rqRealDiff:
                                                lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,NMultPolynomial(CMinusOne,lPolynomial1)));
                                          end;
                                       end;
                                    end
                                    else if (lArg1 = X) and (lArg2 <> t) then
                                    begin
                                       for i := 0 to lValues[X].Count-1 do
                                       begin
                                          lPolynomial1 := lValues[X].Items^[i];
                                          for i2 := 0 to Trms[lArg2].PolynomialValues.Count-1 do
                                          begin
                                             lPolynomial2 := PolynomialPtr(PolynomialPtr(Trms[lArg2].PolynomialValues.Items^[i2])^.MCopy);
                                             case gRevReq[FuncNr] of
                                                rqRealAdd:
                                                   lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,lPolynomial2));
                                                rqRealMult:
                                                   lPolynomialValues[t].Insert(MultPolynomials(lPolynomial1,lPolynomial2));
                                                rqRealDiff:
                                                   lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,NMultPolynomial(CMinusOne,lPolynomial2)));
                                             end;
                                             dispose(lPolynomial2,Done);
                                          end;
                                       end;
                                    end
                                    else  if (lArg1 <> t) and (lArg2 = X) then
                                    begin
                                       for i := 0 to lValues[X].Count-1 do
                                       begin
                                          lPolynomial2 := lValues[X].Items^[i];
                                          for i1 := 0 to Trms[lArg1].PolynomialValues.Count-1 do
                                          begin
                                             lPolynomial1 := PolynomialPtr(PolynomialPtr(Trms[lArg1].PolynomialValues.Items^[i1])^.MCopy);
                                             case gRevReq[FuncNr] of
                                                rqRealAdd:
                                                   lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,lPolynomial2));
                                                rqRealMult:
                                                   lPolynomialValues[t].Insert(MultPolynomials(lPolynomial1,lPolynomial2));
                                                rqRealDiff:
                                                   lPolynomialValues[t].Insert(AddPolynomials(lPolynomial1,NMultPolynomial(CMinusOne,lPolynomial2)));
                                             end;
                                             dispose(lPolynomial1,Done);
                                          end;
                                       end;
                                    end
                                 end;
                              rqRealNeg:
                                 begin
                                    lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                                    if lArg1 = X then
                                       for i := 0 to lValues[X].Count-1 do
                                          lPolynomialValues[t].Insert(NMultPolynomial(CMinusOne,lValues[X].Items^[i]));
                                 end;
                              rqRealDiv:
                                 begin
                                    lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                                    if lArg1 = X then
                                    begin
                                       lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                                       \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(Trms[lArg2].NumValue,lVal);
                                       if lVal.Determined then
                                          for i := 0 to lValues[X].Count-1 do
                                             lPolynomialValues[t].Insert(NMultPolynomial(lVal.NumericValue,lValues[X].Items^[i]));
                                    end;
              end;
                           end;
                        end;
                     end;
                     //infoeqclass(t);
                  end;
      end;
      inc(lLevel);
      if lLevel > 5 then break;
      for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
      begin
         lValues[t].DeleteAll;
         //    lValues[t].Init(0);
         for i := 0 to lPolynomialValues[t].Count-1 do
            if not PolynomialValues.Search(lPolynomialValues[t].Items^[i],lCount) then
            begin
               lValues[t].Insert(lPolynomialValues[t].Items^[i]);
               PolynomialValues.AtInsert(lCount, lPolynomialValues[t].Items^[i]);
               lAddedValues.InsertElem(t);
            end
            else dispose(PolynomialPtr(lPolynomialValues[t].Items^[i]),Done);
         lPolynomialValues[t].DeleteAll;
      end;
   until lAddedValues.Count = 0;
   lAddedValues.Done;
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
   begin
      lPolynomialValues[t].Done;
      lValues[t].DeleteAll;
      lValues[t].Done;
   end;
end;
\nwindexdefn{\nwixident{AddPolynomialValues}}{AddPolynomialValues}{NW4MEPPp-k1T1A-1}\eatline
\nwused{\\{NW4MEPPp-1QLcNW-1}}\nwidentdefs{\\{{\nwixident{AddPolynomialValues}}{AddPolynomialValues}}}\nwidentuses{\\{{\nwixident{RatInv}}{RatInv}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{RatInv}}{RatInv}{NW4MEPPp-k1T1A-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-k1T1A-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-k1T1A-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-k1T1A-1}\nwendcode{}\nwbegindocs{94}\nwdocspar
\subsection{Round-up Super clusters}

\nwenddocs{}\nwbegincode{95}\sublabel{NW4MEPPp-2KruEm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2KruEm-1}}}\moddef{Round up super clusters~{\nwtagstyle{}\subpageref{NW4MEPPp-2KruEm-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
type
   \nwlinkedidentc{ANClusterPtr}{NW4MEPPp-2KruEm-1} = ^\nwlinkedidentc{ANClusterObj}{NW4MEPPp-2KruEm-1};
   \nwlinkedidentc{ANClusterObj}{NW4MEPPp-2KruEm-1} =
      object(MObject)
         nInd: integer;
         nCluster: AttrCollectionPtr;
         constructor Init(aInd: integer; aCluster: AttrCollectionPtr);
         destructor Done; virtual;
      end;
\nwindexdefn{\nwixident{ANClusterObj}}{ANClusterObj}{NW4MEPPp-2KruEm-1}\nwindexdefn{\nwixident{ANClusterPtr}}{ANClusterPtr}{NW4MEPPp-2KruEm-1}\eatline
\nwnotused{Round up super clusters}\nwidentdefs{\\{{\nwixident{ANClusterObj}}{ANClusterObj}}\\{{\nwixident{ANClusterPtr}}{ANClusterPtr}}}\nwendcode{}\nwbegindocs{96}\nwdocspar
\subsubsection{AN Instance Collection}
\nwenddocs{}\nwbegincode{97}\sublabel{NW4MEPPp-4TSA9Z-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4TSA9Z-1}}}\moddef{AN Instance Collection~{\nwtagstyle{}\subpageref{NW4MEPPp-4TSA9Z-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
type
   \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1} = ^\nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1};
   \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1} =
      object(MCollection)
         Status: TLatStatus;
         
         procedure \nwlinkedidentc{InsertAndAbsorb}{NW4MEPPp-IFzSt-1}(fElem:NatFuncPtr);
         procedure \nwlinkedidentc{UnionWith}{NW4MEPPp-1u8Tus-1}(fColl:\nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1});
         procedure \nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(fColl:\nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1}); virtual;
         constructor \nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1};
         constructor \nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1};
         destructor Done; virtual;
         constructor \nwlinkedidentc{InitSingle}{NW4MEPPp-4Bn3U1-1}(fAtom:NatFuncPtr);
         
         \{$IFDEF MDEBUG\}
         procedure \nwlinkedidentc{InfoLatColl}{NW4MEPPp-43LvJn-1};
         \{$ENDIF\}
      end;
\nwindexdefn{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1}\nwindexdefn{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-4TSA9Z-1}\eatline
\nwnotused{AN Instance Collection}\nwidentdefs{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}}\nwidentuses{\\{{\nwixident{InfoLatColl}}{InfoLatColl}}\\{{\nwixident{InitBottom}}{InitBottom}}\\{{\nwixident{InitSingle}}{InitSingle}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}}\\{{\nwixident{JoinWith}}{JoinWith}}\\{{\nwixident{UnionWith}}{UnionWith}}}\nwindexuse{\nwixident{InfoLatColl}}{InfoLatColl}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{InitSingle}}{InitSingle}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-4TSA9Z-1}\nwindexuse{\nwixident{UnionWith}}{UnionWith}{NW4MEPPp-4TSA9Z-1}\nwendcode{}\nwbegindocs{98}\nwdocspar
\nwenddocs{}\nwbegincode{99}\sublabel{NW4MEPPp-3om7vU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3om7vU-1}}}\moddef{Log a substitution in an AN~{\nwtagstyle{}\subpageref{NW4MEPPp-3om7vU-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{$IFDEF MDEBUG\}
procedure \nwlinkedidentc{InfoSubstAN}{NW4MEPPp-3om7vU-1}(aSubst: NatFuncPtr);
var
   k: integer;
begin
   with aSubst^ do
   begin
      for k := 0 to Count-1 do
         with Items^[k] do
      begin
         if k > 0 then
            write(infofile,', ');
         write(infofile,'A',X,' <- ','E',Y);
      end;
   end;
end;
\nwindexdefn{\nwixident{InfoSubstAN}}{InfoSubstAN}{NW4MEPPp-3om7vU-1}\eatline
\nwnotused{Log a substitution in an AN}\nwidentdefs{\\{{\nwixident{InfoSubstAN}}{InfoSubstAN}}}\nwendcode{}\nwbegindocs{100}\nwdocspar
\nwenddocs{}\nwbegincode{101}\sublabel{NW4MEPPp-43LvJn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-43LvJn-1}}}\moddef{Log a lattice collection(?)~{\nwtagstyle{}\subpageref{NW4MEPPp-43LvJn-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InfoLatColl}{NW4MEPPp-43LvJn-1};
var
   z: integer;
begin
   writeln(InfoFile,'Count=',Count);
   for z := 0 to Count-1 do
      if Items = nil then break
      else
      begin
         write(InfoFile,z,': ');
         \nwlinkedidentc{InfoSubstAN}{NW4MEPPp-3om7vU-1}(Items^[z]);
         infonewline;
      end;
end;
\{$ENDIF\}

\nwindexdefn{\nwixident{InfoLatColl}}{InfoLatColl}{NW4MEPPp-43LvJn-1}\eatline
\nwnotused{Log a lattice collection(?)}\nwidentdefs{\\{{\nwixident{InfoLatColl}}{InfoLatColl}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}\\{{\nwixident{InfoSubstAN}}{InfoSubstAN}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-43LvJn-1}\nwindexuse{\nwixident{InfoSubstAN}}{InfoSubstAN}{NW4MEPPp-43LvJn-1}\nwendcode{}\nwbegindocs{102}\nwdocspar
\nwenddocs{}\nwbegincode{103}\sublabel{NW4MEPPp-1Tt0jF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1Tt0jF-1}}}\moddef{Initialize top (of AN instance collection)~{\nwtagstyle{}\subpageref{NW4MEPPp-1Tt0jF-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
const \nwlinkedidentc{NilPtr}{NW4MEPPp-1Tt0jF-1} : pointer = nil;

constructor \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1};
begin
   Items := \nwlinkedidentc{NilPtr}{NW4MEPPp-1Tt0jF-1};
   Count := 1;
   Limit := 1;
   Delta := 0;
   Status := Top;
end;

\nwindexdefn{\nwixident{InitTop}}{InitTop}{NW4MEPPp-1Tt0jF-1}\nwindexdefn{\nwixident{NilPtr}}{NilPtr}{NW4MEPPp-1Tt0jF-1}\eatline
\nwnotused{Initialize top (of AN instance collection)}\nwidentdefs{\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{NilPtr}}{NilPtr}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-1Tt0jF-1}\nwendcode{}\nwbegindocs{104}\nwdocspar
\nwenddocs{}\nwbegincode{105}\sublabel{NW4MEPPp-4G0mLr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4G0mLr-1}}}\moddef{Initialize bottom of AN instance collection~{\nwtagstyle{}\subpageref{NW4MEPPp-4G0mLr-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
constructor \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1};
begin
   Items := nil;
   Count := 0;
   Limit := 0;
   Delta := 0;
   Status := Regular;
end;
\nwindexdefn{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-4G0mLr-1}\eatline
\nwnotused{Initialize bottom of AN instance collection}\nwidentdefs{\\{{\nwixident{InitBottom}}{InitBottom}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-4G0mLr-1}\nwendcode{}\nwbegindocs{106}\nwdocspar
\nwenddocs{}\nwbegincode{107}\sublabel{NW4MEPPp-1KrR39-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1KrR39-1}}}\moddef{Destruct AN instance collection~{\nwtagstyle{}\subpageref{NW4MEPPp-1KrR39-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
destructor \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.Done;
begin
   if status=top then
   begin
      count := 0;
      limit := 0;
   end
   else inherited Done;
end;
\nwnotused{Destruct AN instance collection}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-1KrR39-1}\nwendcode{}\nwbegindocs{108}\nwdocspar

\nwenddocs{}\nwbegincode{109}\sublabel{NW4MEPPp-4Bn3U1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4Bn3U1-1}}}\moddef{Construct AN instance collection from an atom~{\nwtagstyle{}\subpageref{NW4MEPPp-4Bn3U1-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
constructor \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitSingle}{NW4MEPPp-4Bn3U1-1}(fAtom:NatFuncPtr);
begin
   Init(1,0);
   Count := 1;
   AtPut(0,fAtom);
   Status := Regular;
end;
\nwindexdefn{\nwixident{InitSingle}}{InitSingle}{NW4MEPPp-4Bn3U1-1}\eatline
\nwnotused{Construct AN instance collection from an atom}\nwidentdefs{\\{{\nwixident{InitSingle}}{InitSingle}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-4Bn3U1-1}\nwendcode{}\nwbegindocs{110}\nwdocspar
\nwenddocs{}\nwbegincode{111}\sublabel{NW4MEPPp-IFzSt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-IFzSt-1}}}\moddef{Insert and absorb an element into AN instance collection~{\nwtagstyle{}\subpageref{NW4MEPPp-IFzSt-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Below is the difference compared to PreInstCollection

procedure \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InsertAndAbsorb}{NW4MEPPp-IFzSt-1}(fElem:NatFuncPtr);
var
   i: integer;
   lAtom: NatFuncPtr;
label ItIsWeaker;
begin
   i := 0;
   while i < Count do
   begin
      lAtom := Items^[i];
      case lAtom^.CompareWith(fElem^) of
         0: inc(i);
         -1: goto ItIsWeaker;
         1: begin dispose(fElem,Done); exit end;
      end;
   end;
   Insert(fElem);
   exit;
ItIsWeaker:
   FreeItem(lAtom); AtPut(i,fElem); inc(i);
   while i < Count do
   begin
      lAtom := Items^[i];
      if lAtom^.WeakerThan(fElem^) then
      begin
         AtFree(i)
      end
      else inc(i);
   end;
end;

\nwindexdefn{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}{NW4MEPPp-IFzSt-1}\eatline
\nwnotused{Insert and absorb an element into AN instance collection}\nwidentdefs{\\{{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-IFzSt-1}\nwendcode{}\nwbegindocs{112}\nwdocspar
\nwenddocs{}\nwbegincode{113}\sublabel{NW4MEPPp-1u8Tus-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1u8Tus-1}}}\moddef{Take the union of two AN instance collections~{\nwtagstyle{}\subpageref{NW4MEPPp-1u8Tus-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{UnionWith}{NW4MEPPp-1u8Tus-1}(fColl:\nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1});
var
   z: integer;
begin
   if Status = Top then
   begin
      dispose(fColl,Done);
      exit;
   end;
   if fColl^.Count = 0 then
   begin
      dispose(fcoll,Done);
      exit;
   end;
   if fColl^.Status = Top then
   begin
      Done;
      \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1};
      dispose(fcoll,Done);
      exit;
   end;
   SetLimit(Count+fColl^.Count);
   for z := 0 to fColl^.Count-1 do \nwlinkedidentc{InsertAndAbsorb}{NW4MEPPp-IFzSt-1}(fColl.Items^[z]);
   fColl^.DeleteAll;
   dispose(fcoll,Done);
   SetLimit(0);
   Status := Regular;
end;
\nwindexdefn{\nwixident{UnionWith}}{UnionWith}{NW4MEPPp-1u8Tus-1}\eatline
\nwnotused{Take the union of two AN instance collections}\nwidentdefs{\\{{\nwixident{UnionWith}}{UnionWith}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-1u8Tus-1}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-1u8Tus-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-1u8Tus-1}\nwindexuse{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}{NW4MEPPp-1u8Tus-1}\nwendcode{}\nwbegindocs{114}\nwdocspar
\nwenddocs{}\nwbegincode{115}\sublabel{NW4MEPPp-EOnOh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-EOnOh-1}}}\moddef{(Lattice) join with another AN instance collection~{\nwtagstyle{}\subpageref{NW4MEPPp-EOnOh-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(fColl: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1});
var
   tTLC: \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1};
   lAtom,lAtom1: NatFuncPtr;
   z,z1: integer;
begin
   \{ Top & Bottom \}
   if fColl^.Status = Top then begin dispose(fColl,Done); exit; end;
   if Status = Top then
   begin
      \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1};
      SetLimit(fColl^.count);
      for z := 0 to fColl^.Count-1 do Insert(fColl^.Items^[z]);
      fColl^.DeleteAll;
      dispose(fColl,Done);
      exit;
   end;
   if fColl^.Count = 0 then
   begin
      Done;
      \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1};
      dispose(fColl,Done);
      exit;
   end;
   if Count = 0 then
   begin dispose(fColl,Done);
   exit
   end;

   tTLC.Init(count*fcoll^.count,0);
   for z := 0 to count -1 do
      for z1 := 0 to fcoll^.count -1 do
      begin
         lAtom := NatFuncPtr(items^[z]);
         lAtom1 := lAtom^.JoinAtom(NatFuncPtr(fColl^.items^[z1]));
         if lAtom1<>nil then tTLC.Insert(lAtom1);
      end;
   Done;
   \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}.\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1};
   SetLimit(tTLC.count);
   for z := 0 to tTLC.count-1 do insert(tTLC.Items^[z]);
   tTLC.DeleteAll;
   tTLC.Done;
   dispose(fColl,Done);
   SetLimit(0);
   Status := Regular;
   \{ Pewnie warto miec osobna informacje, czy to jest Bottom i raczej uzywac tego \}
   \{ It's probably worth having separate information about whether it's Bottom and rather use it \}
end;

//End of \nwlinkedidentc{ANInstCollection}{NW4MEPPp-4TSA9Z-1}
\nwindexdefn{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-EOnOh-1}\eatline
\nwnotused{(Lattice) join with another AN instance collection}\nwidentdefs{\\{{\nwixident{JoinWith}}{JoinWith}}}\nwidentuses{\\{{\nwixident{ANInstCollection}}{ANInstCollection}}\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitBottom}}{InitBottom}}}\nwindexuse{\nwixident{ANInstCollection}}{ANInstCollection}{NW4MEPPp-EOnOh-1}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-EOnOh-1}\nwindexuse{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-EOnOh-1}\nwendcode{}\nwbegindocs{116}\nwdocspar
\subsubsection{AN Cluster Object}

\nwenddocs{}\nwbegincode{117}\sublabel{NW4MEPPp-3tfB6L-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3tfB6L-1}}}\moddef{State variables for AN Cluster Objects~{\nwtagstyle{}\subpageref{NW4MEPPp-3tfB6L-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
var
   \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1}: NatFuncPtr;
   \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1}: boolean;
   \nwlinkedidentc{gY}{NW4MEPPp-3tfB6L-1}: Integer;

\nwindexdefn{\nwixident{gANInstantiation}}{gANInstantiation}{NW4MEPPp-3tfB6L-1}\nwindexdefn{\nwixident{gFound}}{gFound}{NW4MEPPp-3tfB6L-1}\nwindexdefn{\nwixident{gY}}{gY}{NW4MEPPp-3tfB6L-1}\eatline
\nwnotused{State variables for AN Cluster Objects}\nwidentdefs{\\{{\nwixident{gANInstantiation}}{gANInstantiation}}\\{{\nwixident{gFound}}{gFound}}\\{{\nwixident{gY}}{gY}}}\nwendcode{}\nwbegindocs{118}\nwdocspar
\nwenddocs{}\nwbegincode{119}\sublabel{NW4MEPPp-1C9cBZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1C9cBZ-1}}}\moddef{Constructor for AN Cluster object~{\nwtagstyle{}\subpageref{NW4MEPPp-1C9cBZ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
constructor \nwlinkedidentc{ANClusterObj}{NW4MEPPp-2KruEm-1}.Init(aInd : integer; aCluster: AttrCollectionPtr);
begin
   nInd := aInd;
   nCluster := aCluster;
end;

\nwnotused{Constructor for AN Cluster object}\nwidentuses{\\{{\nwixident{ANClusterObj}}{ANClusterObj}}}\nwindexuse{\nwixident{ANClusterObj}}{ANClusterObj}{NW4MEPPp-1C9cBZ-1}\nwendcode{}\nwbegindocs{120}\nwdocspar

\nwenddocs{}\nwbegincode{121}\sublabel{NW4MEPPp-HGue5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-HGue5-1}}}\moddef{Destructor for AN Cluster object~{\nwtagstyle{}\subpageref{NW4MEPPp-HGue5-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
destructor \nwlinkedidentc{ANClusterObj}{NW4MEPPp-2KruEm-1}.Done;
begin
   dispose(nCluster,Done);
end;

\nwnotused{Destructor for AN Cluster object}\nwidentuses{\\{{\nwixident{ANClusterObj}}{ANClusterObj}}}\nwindexuse{\nwixident{ANClusterObj}}{ANClusterObj}{NW4MEPPp-HGue5-1}\nwendcode{}\nwbegindocs{122}\nwdocspar

\nwenddocs{}\nwbegincode{123}\sublabel{NW4MEPPp-wWzhz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-wWzhz-1}}}\moddef{Check if a formula contains D constants unavailable in the inference~{\nwtagstyle{}\subpageref{NW4MEPPp-wWzhz-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Checks if a formula contains D constants unavailable in the inference
procedure \nwlinkedidentc{CheckForDConsts}{NW4MEPPp-wWzhz-1}(var fTrm :TrmPtr );
begin
   if not \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} then
      if (fTrm^.TrmSort=ikTrmInfConst) then
         if (VarTrmPtr(fTrm)^.VarNr>DTrm.Count-1) or (DTrm.Items^[VarTrmPtr(fTrm)^.VarNr]=nil) then \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} := true;
end;

\nwindexdefn{\nwixident{CheckForDConsts}}{CheckForDConsts}{NW4MEPPp-wWzhz-1}\eatline
\nwnotused{Check if a formula contains D constants unavailable in the inference}\nwidentdefs{\\{{\nwixident{CheckForDConsts}}{CheckForDConsts}}}\nwidentuses{\\{{\nwixident{D}}{D}}\\{{\nwixident{gFound}}{gFound}}}\nwindexuse{\nwixident{D}}{D}{NW4MEPPp-wWzhz-1}\nwindexuse{\nwixident{gFound}}{gFound}{NW4MEPPp-wWzhz-1}\nwendcode{}\nwbegindocs{124}\nwdocspar
\nwenddocs{}\nwbegincode{125}\sublabel{NW4MEPPp-1TNvWL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1TNvWL-1}}}\moddef{Check for E class in arguments~{\nwtagstyle{}\subpageref{NW4MEPPp-1TNvWL-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Checks for a certain E class in arguments
procedure \nwlinkedidentc{CheckForClass}{NW4MEPPp-1TNvWL-1}(var fTrm: TrmPtr );
begin
   ///!!! Must be outside of \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1}, otherwise fTrm is wrong!
   //   writeln(infofile,'checking: ',ftrm^.trmsort,ftrm^.trminfo);
   if (not \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1}) and (fTrm^.TrmSort=ikTrmEqConst) and (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrm^.TrmInfo].Term^.TrmInfo=\nwlinkedidentc{gY}{NW4MEPPp-3tfB6L-1})
   then \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} := true;
end;

\nwindexdefn{\nwixident{CheckForClass}}{CheckForClass}{NW4MEPPp-1TNvWL-1}\eatline
\nwnotused{Check for E class in arguments}\nwidentdefs{\\{{\nwixident{CheckForClass}}{CheckForClass}}}\nwidentuses{\\{{\nwixident{DependsOn}}{DependsOn}}\\{{\nwixident{gFound}}{gFound}}\\{{\nwixident{gY}}{gY}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{DependsOn}}{DependsOn}{NW4MEPPp-1TNvWL-1}\nwindexuse{\nwixident{gFound}}{gFound}{NW4MEPPp-1TNvWL-1}\nwindexuse{\nwixident{gY}}{gY}{NW4MEPPp-1TNvWL-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1TNvWL-1}\nwendcode{}\nwbegindocs{126}\nwdocspar
\nwenddocs{}\nwbegincode{127}\sublabel{NW4MEPPp-3Fy5tU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3Fy5tU-1}}}\moddef{Determine allowed attribute in cluster~{\nwtagstyle{}\subpageref{NW4MEPPp-3Fy5tU-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{AllowedAttributeInCluster}{NW4MEPPp-3Fy5tU-1}(aCluster:AttrCollectionPtr):AttrCollectionPtr;
var
   lCluster: AttrCollectionPtr;
   i: integer;
begin
   lCluster := new(AttrCollectionPtr,Init(aCluster^.Count,0));
   with aCluster^ do
      for i := 0 to Count-1 do
      begin
         \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} := false;
         AttrPtr(Items^[i])^.WithinAttr(\nwlinkedidentc{CheckForDConsts}{NW4MEPPp-wWzhz-1});
         if not \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} then
            lCluster^.Insert(AttrPtr(Items^[i])^.CopyAttribute);
      end;
   \nwlinkedidentc{AllowedAttributeInCluster}{NW4MEPPp-3Fy5tU-1} := lCluster;
end;
\nwindexdefn{\nwixident{AllowedAttributeInCluster}}{AllowedAttributeInCluster}{NW4MEPPp-3Fy5tU-1}\eatline
\nwnotused{Determine allowed attribute in cluster}\nwidentdefs{\\{{\nwixident{AllowedAttributeInCluster}}{AllowedAttributeInCluster}}}\nwidentuses{\\{{\nwixident{CheckForDConsts}}{CheckForDConsts}}\\{{\nwixident{gFound}}{gFound}}}\nwindexuse{\nwixident{CheckForDConsts}}{CheckForDConsts}{NW4MEPPp-3Fy5tU-1}\nwindexuse{\nwixident{gFound}}{gFound}{NW4MEPPp-3Fy5tU-1}\nwendcode{}\nwbegindocs{128}\nwdocspar
\nwenddocs{}\nwbegincode{129}\sublabel{NW4MEPPp-2bF02H-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2bF02H-1}}}\moddef{Initialize allowed clusters~{\nwtagstyle{}\subpageref{NW4MEPPp-2bF02H-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InitAllowedClusters}{NW4MEPPp-2bF02H-1};
var
   ANj: integer;
   lCluster: AttrCollectionPtr;
begin
   for ANj := 0 to ConditionalCluster.Count-1 do
   begin
      lCluster := \nwlinkedidentc{AllowedAttributeInCluster}{NW4MEPPp-3Fy5tU-1}(CClusterPtr(ConditionalCluster.Items^[anj])^.nConsequent.upper);
      if lCluster.Count > 0 then
         AllowedCCluster.Insert(new(\nwlinkedidentc{ANClusterPtr}{NW4MEPPp-2KruEm-1},Init(ANj,lCluster)))
      else dispose(lCluster,Done);
   end;
   for ANj := 0 to FunctorCluster.Count-1 do
   begin
      lCluster := \nwlinkedidentc{AllowedAttributeInCluster}{NW4MEPPp-3Fy5tU-1}(FClusterPtr(FunctorCluster.Items^[anj])^.nConsequent.upper);
      if lCluster.Count > 0 then
         AllowedFCluster.Insert(new(\nwlinkedidentc{ANClusterPtr}{NW4MEPPp-2KruEm-1},Init(ANj,lCluster)))
      else dispose(lCluster,Done);
   end;
end;
\nwindexdefn{\nwixident{InitAllowedClusters}}{InitAllowedClusters}{NW4MEPPp-2bF02H-1}\eatline
\nwnotused{Initialize allowed clusters}\nwidentdefs{\\{{\nwixident{InitAllowedClusters}}{InitAllowedClusters}}}\nwidentuses{\\{{\nwixident{AllowedAttributeInCluster}}{AllowedAttributeInCluster}}\\{{\nwixident{ANClusterPtr}}{ANClusterPtr}}}\nwindexuse{\nwixident{AllowedAttributeInCluster}}{AllowedAttributeInCluster}{NW4MEPPp-2bF02H-1}\nwindexuse{\nwixident{ANClusterPtr}}{ANClusterPtr}{NW4MEPPp-2bF02H-1}\nwendcode{}\nwbegindocs{130}\nwdocspar
\nwenddocs{}\nwbegincode{131}\sublabel{NW4MEPPp-4UL8Iu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4UL8Iu-1}}}\moddef{Check class dependence~{\nwtagstyle{}\subpageref{NW4MEPPp-4UL8Iu-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Checks class dependence
function \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1}(x,y:integer):boolean;
var
   al: TrmList;
begin
   if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[x].EqClass<>nil) and (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[y].EqClass<>nil) then
   begin
      \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} := false;
      \nwlinkedidentc{gY}{NW4MEPPp-3tfB6L-1} := y;
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[x] do
      begin
         al := EqClass;
         while al<>nil do
         begin
            WithinTerm(al^.XTrmPtr,@CheckForClass);
            al := al^.NextTrm;
         end;
         if not \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} then WithinTypeColl(XTypClass,@CheckForClass);
         if not \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1} then SuperCluster^.WithinAttrCollection(@CheckForClass);
      end;
      \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1} := \nwlinkedidentc{gFound}{NW4MEPPp-3tfB6L-1};
   end
   else \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1} := false
end;
\nwindexdefn{\nwixident{DependsOn}}{DependsOn}{NW4MEPPp-4UL8Iu-1}\eatline
\nwnotused{Check class dependence}\nwidentdefs{\\{{\nwixident{DependsOn}}{DependsOn}}}\nwidentuses{\\{{\nwixident{gFound}}{gFound}}\\{{\nwixident{gY}}{gY}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{gFound}}{gFound}{NW4MEPPp-4UL8Iu-1}\nwindexuse{\nwixident{gY}}{gY}{NW4MEPPp-4UL8Iu-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-4UL8Iu-1}\nwendcode{}\nwbegindocs{132}\nwdocspar
\nwenddocs{}\nwbegincode{133}\sublabel{NW4MEPPp-3vUQ6B-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3vUQ6B-1}}}\moddef{Determine set of dependent classes~{\nwtagstyle{}\subpageref{NW4MEPPp-3vUQ6B-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Calculates the set of dependent classes
function \nwlinkedidentc{DependentClasses}{NW4MEPPp-3vUQ6B-1}(enr:Integer):NatSetPtr;
var
   i: integer;
   r: NatSetPtr;
begin
   if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr].EqClass<>nil then
   begin
      new(r,Init(10,10));
      for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         if \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1}(i,enr) then r^.InsertElem(i);
      \nwlinkedidentc{DependentClasses}{NW4MEPPp-3vUQ6B-1} := r;
   end
   else \nwlinkedidentc{DependentClasses}{NW4MEPPp-3vUQ6B-1} := nil;
end;
\nwindexdefn{\nwixident{DependentClasses}}{DependentClasses}{NW4MEPPp-3vUQ6B-1}\eatline
\nwnotused{Determine set of dependent classes}\nwidentdefs{\\{{\nwixident{DependentClasses}}{DependentClasses}}}\nwidentuses{\\{{\nwixident{DependsOn}}{DependsOn}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{DependsOn}}{DependsOn}{NW4MEPPp-3vUQ6B-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-3vUQ6B-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-3vUQ6B-1}\nwendcode{}\nwbegindocs{134}\nwdocspar
\nwenddocs{}\nwbegincode{135}\sublabel{NW4MEPPp-1wkHGU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1wkHGU-1}}}\moddef{Match loci with classes in attributes~{\nwtagstyle{}\subpageref{NW4MEPPp-1wkHGU-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1}(fcluster:PCollection;etrm,atrm:TrmPtr): ANInstcollectionptr; forward;
function \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1}(ccluster:PCollection;enr:integer;atyp:TypPtr): ANInstcollectionptr; forward;

//Matches loci with classes in attributes
function \nwlinkedidentc{InstantiateAttr}{NW4MEPPp-1wkHGU-1}(fcluster:PCollection;
                         enr:integer;
                         aa:AttrPtr): ANInstcollectionptr;
var
   r,z,v,int1: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
   el,al: TrmList;
   j,t,u: integer;
   f: boolean;
begin
   new(r,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
   f := false;
   for j := 0 to Trms[enr].SuperCluster^.Count-1 do
   begin
      AttrPtr(Trms[enr].SuperCluster^.Items^[j])^.AdjustAttr(t,el);
      aa^.AdjustAttr(u,al);
      if (t=u) and (AttrPtr(Trms[enr].SuperCluster^.Items^[j])^.fNeg=aa^.fNeg)
      then
      begin
         if al=nil then
         begin
            dispose(r,Done); //1
            new(z,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
            \nwlinkedidentc{InstantiateAttr}{NW4MEPPp-1wkHGU-1} := z;
            exit;
         end;
         f := true;
         new(v,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
         while al<>nil do
         begin
            int1 := instantiateTerm(fcluster,el^.XTrmPtr,al^.XTrmPtr);
            v^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(int1);
            al := al^.NextTrm;
            el := el^.NextTrm;
         end;
         r^.\nwlinkedidentc{UnionWith}{NW4MEPPp-1u8Tus-1}(v);
      end;
   end;
   if not f then
   begin
      dispose(r,Done);
      new(r,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
      instantiateAttr := r;
      exit;
   end;
   instantiateattr := r;
end;
\nwindexdefn{\nwixident{InstantiateAttr}}{InstantiateAttr}{NW4MEPPp-1wkHGU-1}\eatline
\nwnotused{Match loci with classes in attributes}\nwidentdefs{\\{{\nwixident{InstantiateAttr}}{InstantiateAttr}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitBottom}}{InitBottom}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{InstantiateTerm}}{InstantiateTerm}}\\{{\nwixident{InstantiateType}}{InstantiateType}}\\{{\nwixident{JoinWith}}{JoinWith}}\\{{\nwixident{UnionWith}}{UnionWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{InstantiateTerm}}{InstantiateTerm}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{InstantiateType}}{InstantiateType}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-1wkHGU-1}\nwindexuse{\nwixident{UnionWith}}{UnionWith}{NW4MEPPp-1wkHGU-1}\nwendcode{}\nwbegindocs{136}\nwdocspar
\nwenddocs{}\nwbegincode{137}\sublabel{NW4MEPPp-2YvKKn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2YvKKn-1}}}\moddef{Match loci with classes in an attribute collection~{\nwtagstyle{}\subpageref{NW4MEPPp-2YvKKn-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in attribute collections
function \nwlinkedidentc{InstantiateAttrs}{NW4MEPPp-2YvKKn-1}(fcluster:PCollection;
                          enr:integer;
                          alc:AttrCollectionPtr): ANInstcollectionptr;
var
   r,int1: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
   i: integer;
begin
   new(r,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
   for i := 0 to alc^.Count-1 do
   begin
      int1 := \nwlinkedidentc{InstantiateAttr}{NW4MEPPp-1wkHGU-1}(fcluster,enr,AttrPtr(alc^.Items^[i]));
      r^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(int1);
   end;
   instantiateattrs := r;
end;
\nwindexdefn{\nwixident{InstantiateAttrs}}{InstantiateAttrs}{NW4MEPPp-2YvKKn-1}\eatline
\nwnotused{Match loci with classes in an attribute collection}\nwidentdefs{\\{{\nwixident{InstantiateAttrs}}{InstantiateAttrs}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{InstantiateAttr}}{InstantiateAttr}}\\{{\nwixident{JoinWith}}{JoinWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-2YvKKn-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-2YvKKn-1}\nwindexuse{\nwixident{InstantiateAttr}}{InstantiateAttr}{NW4MEPPp-2YvKKn-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-2YvKKn-1}\nwendcode{}\nwbegindocs{138}\nwdocspar
\nwenddocs{}\nwbegincode{139}\sublabel{NW4MEPPp-15kCPx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-15kCPx-1}}}\moddef{Match loci with classes in terms~{\nwtagstyle{}\subpageref{NW4MEPPp-15kCPx-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in terms
function \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1}(fcluster: PCollection;
                         etrm,atrm: trmptr ): ANInstcollectionptr;
var
   r,z,v,int1: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
   enr,t,u: integer;
   tl,el,al,atl: TrmList;
   n: NatFuncPtr;
   t1: TypPtr;
begin
   (*  \{$IFDEF MDEBUG\}
  writeln(infofile,'InstantiateTerm:');
  infostring('e=');infoterm(etrm);writeln(infofile,' trminfo=',etrm^.TrmInfo);
  infostring('a=');infoterm(atrm);writeln(infofile,' trminfo=',atrm^.TrmInfo);
  flush(infofile);
  \{$ENDIF\} *)
   if eTrm^.TrmSort<>ikTrmEqConst then
   begin
      mizassert(1898,etrm^.TrmSort in [ikTrmFunctor,ikTrmNumeral,ikTrmSelector,ikTrmAggreg]);
      if eTrm^.TrmSort=ikTrmNumeral then
         if (aTrm^.TrmSort=ikTrmNumeral) and (VarTrmPtr(eTrm)^.VarNr=VarTrmPtr(aTrm)^.VarNr) then
         begin
            new(z,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
            \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
            exit;
         end
         else
         begin
            new(z,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
            \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
            exit;
         end;
      if (eTrm^.TrmSort=atrm^.TrmSort) then
      begin
         if eTrm^.TrmSort=ikTrmFunctor then
         begin
            AdjustTrm(eTrm,t,el);
            AdjustTrm(aTrm,u,al);
         end
         else
         begin
            t := FuncTrmPtr(eTrm)^.FuncNr;
            el := FuncTrmPtr(eTrm)^.FuncArgs;
            u := FuncTrmPtr(aTrm)^.FuncNr;
            al := FuncTrmPtr(aTrm)^.FuncArgs;
         end;
         if t=u then
         begin
            new(r,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
            while el<>nil do
            begin
               int1 := instantiateTerm(fcluster,el^.XTrmPtr,al^.XTrmPtr);
               r^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(int1);
               el := el^.NextTrm;
               al := al^.NextTrm;
            end;
            \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := r;
            exit;
         end;
      end
      else
      begin
         new(r,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
         \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := r;
         exit;
      end;
   end;
   enr := Trms[etrm^.TrmInfo].Term^.TrmInfo; //??? really needed TrmInfo twice?
   if atrm^.TrmSort=ikTrmLocus then
   begin
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr] do
      begin
         t1 := fcluster^.Items^[VarTrmPtr(atrm)^.VarNr-1];
         z := \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1}(fcluster,enr,t1);
         if z^.Count=0 then
         begin
            \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
            exit;
         end;
         // int2 := \nwlinkedidentc{InstantiateRadixType}{NW4MEPPp-2EAQ15-1}(fcluster,enr,t1);
         // z^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(int2);
         // if z^.Count=0 then
         // begin
         //    \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
         //    exit;
         // end;
         new(n,InitNatFunc(1,1));
         n^.Assign(VarTrmPtr(atrm)^.VarNr,VarTrmPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr].Term)^.VarNr);
         new(r,\nwlinkedidentc{InitSingle}{NW4MEPPp-4Bn3U1-1}(n));
         z^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(r);
         \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
      end;
   end
   else
   begin
      mizassert(1888,atrm^.TrmSort in [ikTrmFunctor,ikTrmNumeral,ikTrmSelector,ikTrmAggreg]);
      if aTrm^.TrmSort=ikTrmNumeral then
      begin
         if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr].NumValue.Determined) and
               (CompareComplex(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr].NumValue.NumericValue,IntToComplex(VarTrmPtr(aTrm)^.VarNr))=0) then
         begin
            new(z,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
            \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
            exit;
         end;
         new(z,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
         \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1} := z;
         exit;
      end;
      if aTrm^.TrmSort=ikTrmFunctor then AdjustTrm(aTrm,u,atl)
      else
      begin
         u := FuncTrmPtr(aTrm)^.FuncNr;
         atl := FuncTrmPtr(aTrm)^.FuncArgs;
      end;
      new(r,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
      with trms[enr] do
      begin
         tl := EqClass;
         while tl<>nil do
         begin
            if tl^.XTrmPtr^.TrmSort=aTrm^.TrmSort then
            begin
               if tl^.XTrmPtr^.TrmSort=ikTrmFunctor then AdjustTrm(tl^.XTrmPtr,t,el)
               else
               begin t := FuncTrmPtr(tl^.XTrmPtr)^.FuncNr;el := FuncTrmPtr(tl^.XTrmPtr)^.FuncArgs;
               end;
               if t=u then
               begin
                  new(z,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
                  al := atl;
                  while el<>nil do
                  begin
                     v := \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1}(fcluster,el^.XTrmPtr,al^.XTrmPtr);
                     z^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(v);
                     el := el^.NextTrm;
                     al := al^.NextTrm;
                  end;
                  r^.\nwlinkedidentc{UnionWith}{NW4MEPPp-1u8Tus-1}(z);
               end;
            end;
            tl := tl^.NextTrm;
         end;
         instantiateTerm := r;
      end;
   end;
end;

\nwindexdefn{\nwixident{InstantiateTerm}}{InstantiateTerm}{NW4MEPPp-15kCPx-1}\eatline
\nwnotused{Match loci with classes in terms}\nwidentdefs{\\{{\nwixident{InstantiateTerm}}{InstantiateTerm}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitBottom}}{InitBottom}}\\{{\nwixident{InitSingle}}{InitSingle}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{InstantiateRadixType}}{InstantiateRadixType}}\\{{\nwixident{InstantiateType}}{InstantiateType}}\\{{\nwixident{JoinWith}}{JoinWith}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionWith}}{UnionWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{InitSingle}}{InitSingle}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{InstantiateRadixType}}{InstantiateRadixType}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{InstantiateType}}{InstantiateType}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-15kCPx-1}\nwindexuse{\nwixident{UnionWith}}{UnionWith}{NW4MEPPp-15kCPx-1}\nwendcode{}\nwbegindocs{140}\nwdocspar
\nwenddocs{}\nwbegincode{141}\sublabel{NW4MEPPp-2EAQ15-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2EAQ15-1}}}\moddef{Match loci with classes in radix types~{\nwtagstyle{}\subpageref{NW4MEPPp-2EAQ15-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in radix types
function \nwlinkedidentc{InstantiateRadixType}{NW4MEPPp-2EAQ15-1}(ccluster: PCollection;
                              enr: integer;
                              atyp: TypPtr): ANInstcollectionptr;
var
   r,z,int2: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
   i,t,u: integer;
   el,al,atl,atm: TrmList;
begin
   enr := Trms[enr].Term^.TrmInfo;
   atyp^.AdjustTyp(t,atl);
   new(r,\nwlinkedidentc{InitBottom}{NW4MEPPp-4G0mLr-1});
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr] do
   begin
      for i := 0 to XTypClass.Count-1 do
         with TypPtr(XTypClass.Items^[i])^ do
      begin
         AdjustTyp(u,atm);
         if (TypSort=atyp^.TypSort) and (u=t) then
         begin
            if atl=nil then
            begin
               dispose(r,Done);
               new(r,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
               \nwlinkedidentc{InstantiateRadixType}{NW4MEPPp-2EAQ15-1} := r;
               exit;
            end;
            new(z,\nwlinkedidentc{InitTop}{NW4MEPPp-1Tt0jF-1});
            el := atm;
            al := atl;
            while al<>nil do
            begin
               int2 := instantiateTerm(ccluster,el^.XTrmPtr,al^.XTrmPtr);
               z^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(int2);
               el := el^.NextTrm;
               al := al^.NextTrm;
            end;
            r^.\nwlinkedidentc{UnionWith}{NW4MEPPp-1u8Tus-1}(z);
         end;
      end;
      \nwlinkedidentc{InstantiateRadixType}{NW4MEPPp-2EAQ15-1} := r;
   end;
end;
\nwindexdefn{\nwixident{InstantiateRadixType}}{InstantiateRadixType}{NW4MEPPp-2EAQ15-1}\eatline
\nwnotused{Match loci with classes in radix types}\nwidentdefs{\\{{\nwixident{InstantiateRadixType}}{InstantiateRadixType}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InitBottom}}{InitBottom}}\\{{\nwixident{InitTop}}{InitTop}}\\{{\nwixident{JoinWith}}{JoinWith}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionWith}}{UnionWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-2EAQ15-1}\nwindexuse{\nwixident{InitBottom}}{InitBottom}{NW4MEPPp-2EAQ15-1}\nwindexuse{\nwixident{InitTop}}{InitTop}{NW4MEPPp-2EAQ15-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-2EAQ15-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2EAQ15-1}\nwindexuse{\nwixident{UnionWith}}{UnionWith}{NW4MEPPp-2EAQ15-1}\nwendcode{}\nwbegindocs{142}\nwdocspar
\nwenddocs{}\nwbegincode{143}\sublabel{NW4MEPPp-vVcE1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-vVcE1-1}}}\moddef{Match loci with classes in types~{\nwtagstyle{}\subpageref{NW4MEPPp-vVcE1-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in types
function \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1}(ccluster: PCollection;
                         enr: integer;
                         atyp: TypPtr): ANInstcollectionptr;
var
   r,s: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
begin
   r := \nwlinkedidentc{InstantiateRadixType}{NW4MEPPp-2EAQ15-1}(ccluster,enr,atyp);
   s := \nwlinkedidentc{InstantiateAttrs}{NW4MEPPp-2YvKKn-1}(ccluster,enr,atyp^.LowerCluster);
   r^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(s);
   \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1} := r;
end;

\nwindexdefn{\nwixident{InstantiateType}}{InstantiateType}{NW4MEPPp-vVcE1-1}\eatline
\nwnotused{Match loci with classes in types}\nwidentdefs{\\{{\nwixident{InstantiateType}}{InstantiateType}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InstantiateAttrs}}{InstantiateAttrs}}\\{{\nwixident{InstantiateRadixType}}{InstantiateRadixType}}\\{{\nwixident{JoinWith}}{JoinWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-vVcE1-1}\nwindexuse{\nwixident{InstantiateAttrs}}{InstantiateAttrs}{NW4MEPPp-vVcE1-1}\nwindexuse{\nwixident{InstantiateRadixType}}{InstantiateRadixType}{NW4MEPPp-vVcE1-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-vVcE1-1}\nwendcode{}\nwbegindocs{144}\nwdocspar
\nwenddocs{}\nwbegincode{145}\sublabel{NW4MEPPp-2D5MuC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2D5MuC-1}}}\moddef{Match loci with classes in term registrations~{\nwtagstyle{}\subpageref{NW4MEPPp-2D5MuC-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in term registrations
function \nwlinkedidentc{InstantiateFCluster}{NW4MEPPp-2D5MuC-1}(fcluster: fclusterptr;
                             enr: integer): ANInstcollectionptr;
var
   r,s : \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
begin
   r := \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1}(@fcluster^.nPrimaryList,Trms[enr].Term,fcluster^.nClusterTerm);
   if fcluster^.nClusterType<>nil then
   begin
      s := \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1}(@fcluster^.nPrimaryList,enr,fcluster^.nClusterType);
      r^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(s);
   end;
   \nwlinkedidentc{InstantiateFCluster}{NW4MEPPp-2D5MuC-1} := r;
end;
\nwindexdefn{\nwixident{InstantiateFCluster}}{InstantiateFCluster}{NW4MEPPp-2D5MuC-1}\eatline
\nwnotused{Match loci with classes in term registrations}\nwidentdefs{\\{{\nwixident{InstantiateFCluster}}{InstantiateFCluster}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InstantiateTerm}}{InstantiateTerm}}\\{{\nwixident{InstantiateType}}{InstantiateType}}\\{{\nwixident{JoinWith}}{JoinWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-2D5MuC-1}\nwindexuse{\nwixident{InstantiateTerm}}{InstantiateTerm}{NW4MEPPp-2D5MuC-1}\nwindexuse{\nwixident{InstantiateType}}{InstantiateType}{NW4MEPPp-2D5MuC-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-2D5MuC-1}\nwendcode{}\nwbegindocs{146}\nwdocspar
\nwenddocs{}\nwbegincode{147}\sublabel{NW4MEPPp-xRTSq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-xRTSq-1}}}\moddef{Match loci with classes in conditional registrations~{\nwtagstyle{}\subpageref{NW4MEPPp-xRTSq-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Matches loci with classes in conditional registrations
function \nwlinkedidentc{InstantiateCCluster}{NW4MEPPp-xRTSq-1}(ccluster: cclusterptr;
                             enr: integer): ANInstcollectionptr;
var
   r,s: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
begin
   r := \nwlinkedidentc{InstantiateType}{NW4MEPPp-vVcE1-1}(@ccluster^.nPrimaryList,enr,ccluster^.nClusterType);
// the attributes from the type are copied to the antecedent, so it should be enough to use RadixType above
   s := \nwlinkedidentc{InstantiateAttrs}{NW4MEPPp-2YvKKn-1}(@ccluster^.nPrimaryList,enr,ccluster^.nAntecedent);
   r^.\nwlinkedidentc{JoinWith}{NW4MEPPp-EOnOh-1}(s);
   \nwlinkedidentc{InstantiateCCluster}{NW4MEPPp-xRTSq-1} := r;
end;
\nwindexdefn{\nwixident{InstantiateCCluster}}{InstantiateCCluster}{NW4MEPPp-xRTSq-1}\eatline
\nwnotused{Match loci with classes in conditional registrations}\nwidentdefs{\\{{\nwixident{InstantiateCCluster}}{InstantiateCCluster}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{InstantiateAttrs}}{InstantiateAttrs}}\\{{\nwixident{InstantiateType}}{InstantiateType}}\\{{\nwixident{JoinWith}}{JoinWith}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-xRTSq-1}\nwindexuse{\nwixident{InstantiateAttrs}}{InstantiateAttrs}{NW4MEPPp-xRTSq-1}\nwindexuse{\nwixident{InstantiateType}}{InstantiateType}{NW4MEPPp-xRTSq-1}\nwindexuse{\nwixident{JoinWith}}{JoinWith}{NW4MEPPp-xRTSq-1}\nwendcode{}\nwbegindocs{148}\nwdocspar
\nwenddocs{}\nwbegincode{149}\sublabel{NW4MEPPp-1zYHzy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1zYHzy-1}}}\moddef{Try to match a list of terms~{\nwtagstyle{}\subpageref{NW4MEPPp-1zYHzy-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1}(aTrm:TrmPtr): TrmPtr; FORWARD;

//Tries to match a list of terms using the function below
function \nwlinkedidentc{LocateTermList}{NW4MEPPp-1zYHzy-1}(aList: TrmList): TrmList;
var
   l,la : TrmList;
   t: TrmPtr;
begin
   la := nil;
   l := aList;
   while l<>nil do
   begin
      t := \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1}(l^.XTrmPtr);
      if t=nil then
      begin
         if la<>nil then DisposeListOfTerms(la);
         \nwlinkedidentc{LocateTermList}{NW4MEPPp-1zYHzy-1} := nil;
         exit;
      end;
      la := AddToTrmList(la,t);
      l := l^.NextTrm;
   end;
   \nwlinkedidentc{LocateTermList}{NW4MEPPp-1zYHzy-1} := la;
end;
\nwindexdefn{\nwixident{LocateTermList}}{LocateTermList}{NW4MEPPp-1zYHzy-1}\eatline
\nwnotused{Try to match a list of terms}\nwidentdefs{\\{{\nwixident{LocateTermList}}{LocateTermList}}}\nwidentuses{\\{{\nwixident{LocateTerm}}{LocateTerm}}}\nwindexuse{\nwixident{LocateTerm}}{LocateTerm}{NW4MEPPp-1zYHzy-1}\nwendcode{}\nwbegindocs{150}\nwdocspar
\nwenddocs{}\nwbegincode{151}\sublabel{NW4MEPPp-2F8gN0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2F8gN0-1}}}\moddef{Try to match a term to an external class~{\nwtagstyle{}\subpageref{NW4MEPPp-2F8gN0-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Tries to match a (possibly external) term to an existing class
//It depends on \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1}! - should probably be changed to another parameter
function \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1}(aTrm: TrmPtr): TrmPtr;
var
   i,g : Integer;
   l,la: TrmList;
begin
   \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := nil;
   case aTrm^.TrmSort of
      ikTrmLocus:
         begin
            g := \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1}^.Value(VarTrmPtr(aTrm)^.VarNr);
            for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
               if VarTrmPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term)^.VarNr=g then
               begin \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term;
               exit;
               end;
         end;
      ikTrmInfConst:
         for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         begin
            l := Trms[i].EqClass;
            while l<>nil do
            begin
               if (l^.XTrmPtr^.TrmSort=ikTrmInfConst) and (VarTrmPtr(l^.XTrmPtr)^.VarNr=VarTrmPtr(aTrm)^.VarNr) then
               begin
                  \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term;
                  exit;
               end;
               l := l^.NextTrm;
            end;
         end;
      ikTrmNumeral:
         for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
            with Trms[i], NumValue do
               if (EqClass <> nil) and Determined and
                     IsEQWithInt(NumericValue,VarTrmPtr(aTrm)^.VarNr) then
               begin
                  \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term;
                  exit;
               end;
      ikTrmFunctor,ikTrmSelector,ikTrmAggreg:
         for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
            with Trms[i] do
               if EqClass<>nil then
               begin
                  l := EqClass;
                  while l<>nil do
                  begin
                     if (l^.XTrmPtr^.TrmSort=aTrm^.TrmSort) and (FuncTrmPtr(l^.XTrmPtr)^.FuncNr=FuncTrmPtr(aTrm)^.FuncNr) then
                     begin
                        with FuncTrmPtr(l^.XTrmPtr)^ do
                        begin
                           if FuncArgs=nil then
                           begin
                              \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term;
                              exit;
                           end;
                           la := \nwlinkedidentc{LocateTermList}{NW4MEPPp-1zYHzy-1}(FuncTrmPtr(aTrm)^.FuncArgs);
                           if (la<>nil) and (\nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(la,FuncArgs)) then
                           begin
                              DisposeListofTerms(la);
                              \nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1} := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[i].Term;
                              exit;
                           end;
                        end;
                     end;
                     l := l^.NextTrm;
                  end;
               end;
   end;
end;
\nwindexdefn{\nwixident{LocateTerm}}{LocateTerm}{NW4MEPPp-2F8gN0-1}\eatline
\nwnotused{Try to match a term to an external class}\nwidentdefs{\\{{\nwixident{LocateTerm}}{LocateTerm}}}\nwidentuses{\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{gANInstantiation}}{gANInstantiation}}\\{{\nwixident{LocateTermList}}{LocateTermList}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-2F8gN0-1}\nwindexuse{\nwixident{gANInstantiation}}{gANInstantiation}{NW4MEPPp-2F8gN0-1}\nwindexuse{\nwixident{LocateTermList}}{LocateTermList}{NW4MEPPp-2F8gN0-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-2F8gN0-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2F8gN0-1}\nwendcode{}\nwbegindocs{152}\nwdocspar
\nwenddocs{}\nwbegincode{153}\sublabel{NW4MEPPp-2H0WBZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2H0WBZ-1}}}\moddef{Convert attribute to E classes~{\nwtagstyle{}\subpageref{NW4MEPPp-2H0WBZ-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Converts attribute arguments to respective E classes
function \nwlinkedidentc{LocatedAttr}{NW4MEPPp-2H0WBZ-1}(aAttr: AttrPtr): AttrPtr;
var
   a: AttrPtr;
   l: TrmList;
begin
   if aAttr^.fAttrArgs=nil then \nwlinkedidentc{LocatedAttr}{NW4MEPPp-2H0WBZ-1} := aAttr^.CopyAttribute
   else
   begin
      l := \nwlinkedidentc{LocateTermList}{NW4MEPPp-1zYHzy-1}(aAttr^.fAttrArgs);
      if l=nil then \nwlinkedidentc{LocatedAttr}{NW4MEPPp-2H0WBZ-1} := nil else
      begin
         a := AttrPtr(PObject(aAttr)^.CopyObject);
         a^.fAttrArgs := l;
         \nwlinkedidentc{LocatedAttr}{NW4MEPPp-2H0WBZ-1} := a;
      end;
   end;
end;
\nwindexdefn{\nwixident{LocatedAttr}}{LocatedAttr}{NW4MEPPp-2H0WBZ-1}\eatline
\nwnotused{Convert attribute to E classes}\nwidentdefs{\\{{\nwixident{LocatedAttr}}{LocatedAttr}}}\nwidentuses{\\{{\nwixident{LocateTermList}}{LocateTermList}}}\nwindexuse{\nwixident{LocateTermList}}{LocateTermList}{NW4MEPPp-2H0WBZ-1}\nwendcode{}\nwbegindocs{154}\nwdocspar
\nwenddocs{}\nwbegincode{155}\sublabel{NW4MEPPp-1h9hfF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1h9hfF-1}}}\moddef{Convert attribute collections to hold attributes with E constants~{\nwtagstyle{}\subpageref{NW4MEPPp-1h9hfF-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Converts attribute collections to hold attributes with E arguments
function \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1}(aCluster: AttrCollectionPtr): AttrCollectionPtr;
var
   i: Integer;
   r: AttrCollectionPtr;
   a: AttrPtr;
begin
   new(r,Init(10,10));
   for i := 0 to aCluster^.Count-1 do
   begin
      a := \nwlinkedidentc{LocatedAttr}{NW4MEPPp-2H0WBZ-1}(AttrPtr(aCluster^.Items^[i]));
      if a <> nil then r^.Insert(a);
   end;
   \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1} := r;
end;
\nwindexdefn{\nwixident{LocatedCluster}}{LocatedCluster}{NW4MEPPp-1h9hfF-1}\eatline
\nwnotused{Convert attribute collections to hold attributes with E constants}\nwidentdefs{\\{{\nwixident{LocatedCluster}}{LocatedCluster}}}\nwidentuses{\\{{\nwixident{LocatedAttr}}{LocatedAttr}}}\nwindexuse{\nwixident{LocatedAttr}}{LocatedAttr}{NW4MEPPp-1h9hfF-1}\nwendcode{}\nwbegindocs{156}\nwdocspar
\nwenddocs{}\nwbegincode{157}\sublabel{NW4MEPPp-1qAXg2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1qAXg2-1}}}\moddef{Apply all possible registrations to a given E class~{\nwtagstyle{}\subpageref{NW4MEPPp-1qAXg2-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Applies all possible registrations to a given E class
function \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1}(enr: Integer): Boolean;
var
   r,added: Boolean;
   i,j,c: Integer;
   inst: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
   ANCluster,LCluster: AttrCollectionPtr;
begin
   r := false;
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr] do
   begin
      if EqClass=nil then
      begin
         \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := false;
         exit;
      end;
      //AN We repeat the loop as rounding must be independent of the order of registrations!
      added := true;
      while added do
      begin
         added := false;
         for i := 0 to AllowedCCluster.Count-1 do
            with \nwlinkedidentc{ANClusterPtr}{NW4MEPPp-2KruEm-1}(AllowedCCluster.items^[i])^ do
         begin
            \{$IFDEF DEBUGSUPERCLUSTERS\}
            writeln(infofile,'CClusternr=',i);
            \{$ENDIF\}
            inst := \nwlinkedidentc{InstantiateCCluster}{NW4MEPPp-xRTSq-1}(cclusterptr(conditionalcluster.items^[nInd]),enr);
            if inst^.status=TOP then
            begin
               ANCluster := nCluster;
               \{$IFDEF DEBUGSUPERCLUSTERS\}
               infostring('clusterupper=');infocluster(ancluster);infonewline;
               \{$ENDIF\}
               LCluster := \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1}(ANCluster);
               \{$IFDEF DEBUGSUPERCLUSTERS\}
               infostring('locatedcluster=');infocluster(lcluster);infonewline;
               infostring('supercluster=');infocluster(supercluster);infonewline;
               \{$ENDIF\}
               c := supercluster.count;
               SuperCluster^.EnlargeBy(LCluster);
               if supercluster^.count<>c then
               begin
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  writeln(infofile,'ADDEDC1:',supercluster^.count,' ',c);
                  \{$ENDIF\}
                  r := true;
                  added := true;
               end;
               dispose(lcluster,Done);
               if not SuperCluster^.fConsistent then
               begin
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  writeln(infofile,'FOUNDC1');
                  \{$ENDIF\}
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(8);
                  dispose(inst,Done);
                  \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := true;
                  exit;
               end;
            end
            else
               for j := 0 to inst^.count-1 do
               begin
                  \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1} := inst^.Items^[j];
                  ANCluster := nCluster;
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  infostring('clusterupper=');
                  infocluster(ancluster);
                  infonewline;
                  \{$ENDIF\}
                  LCluster := \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1}(ANCluster);
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  infostring('locatedcluster=');
                  infocluster(lcluster);
                  infonewline;
                  infostring('supercluster=');
                  infocluster(supercluster);
                  infonewline;
                  \{$ENDIF\}
                  c := supercluster.count;
                  SuperCluster^.EnlargeBy(LCluster);
                  if supercluster^.count<>c then
                  begin
                     \{$IFDEF DEBUGSUPERCLUSTERS\}
                     writeln(infofile,'ADDEDC2:',supercluster^.count,' ',c);
                     \{$ENDIF\}
                     r := true;
                     added := true;
                  end;
                  dispose(LCluster,Done);
                  if not SuperCluster^.fConsistent then
                  begin
                     \{$IFDEF DEBUGSUPERCLUSTERS\}
                     writeln(infofile,'FOUNDC2');
                     \{$ENDIF\}
                     \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(9);
                     dispose(inst,Done);
                     \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := true;
                     exit;
                  end;
               end;
            dispose(inst,Done);
         end;
         for i := 0 to AllowedFCluster.Count-1 do
            with \nwlinkedidentc{ANClusterPtr}{NW4MEPPp-2KruEm-1}(AllowedFCluster.items^[i])^ do
         begin
            \{$IFDEF DEBUGSUPERCLUSTERS\}
            writeln(infofile,'FClusternr=',i);
            \{$ENDIF\}
            inst := \nwlinkedidentc{InstantiateFCluster}{NW4MEPPp-2D5MuC-1}(fclusterptr(functorcluster.items^[nInd]),enr);
            if inst^.status=TOP then
            begin
               ANCluster := nCluster;
               \{$IFDEF DEBUGSUPERCLUSTERS\}
               infostring('clusterupper=');
               infocluster(ancluster);
               infonewline;
               \{$ENDIF\}
               LCluster := \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1}(ANCluster);
               \{$IFDEF DEBUGSUPERCLUSTERS\}
               infostring('locatedcluster=');
               infocluster(lcluster);
               infonewline;
               infostring('supercluster=');
               infocluster(supercluster);
               infonewline;
               \{$ENDIF\}
               c := supercluster.count;
               SuperCluster^.EnlargeBy(LCluster);
               if supercluster^.count<>c then
               begin
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  writeln(infofile,'ADDEDF1:',supercluster^.count,' ',c);
                  \{$ENDIF\}
                  r := true;
                  added := true;
               end;
               dispose(lcluster,Done);
               if not SuperCluster^.fConsistent then
               begin
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  writeln(infofile,'FOUNDF1');
                  \{$ENDIF\}
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(10);
                  dispose(inst,Done);
                  \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := true;
                  exit;
               end;
            end
            else
            begin
               for j := 0 to inst^.count-1 do
               begin
                  \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1} := inst^.Items^[j];
                  ANCluster := nCluster;
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  infostring('clusterupper=');
                  infocluster(ancluster);
                  infonewline;
                  \{$ENDIF\}
                  LCluster := \nwlinkedidentc{LocatedCluster}{NW4MEPPp-1h9hfF-1}(ANCluster);
                  \{$IFDEF DEBUGSUPERCLUSTERS\}
                  infostring('locatedcluster=');
                  infocluster(lcluster);
                  infonewline;
                  infostring('supercluster=');
                  infocluster(supercluster);
                  infonewline;
                  \{$ENDIF\}
                  c := supercluster.count;
                  SuperCluster^.EnlargeBy(LCluster);
                  if supercluster^.count<>c then
                  begin
                     \{$IFDEF DEBUGSUPERCLUSTERS\}
                     writeln(infofile,'ADDEDF2:',supercluster^.count,' ',c);
                     \{$ENDIF\}
                     r := true;
                     added := true;
                  end;
                  dispose(lcluster,Done);
                  if not SuperCluster^.fConsistent then
                  begin
                     \{$IFDEF DEBUGSUPERCLUSTERS\}
                     writeln(infofile,'FOUNDF2');
                     \{$ENDIF\}
                     \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(11);
                     dispose(inst,Done);
                     \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := true;
                     exit;
                  end;
               end;
            end;
            dispose(inst,Done);
         end;
      end;
   end;
   \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1} := r;
end;
\nwindexdefn{\nwixident{RoundUpSuperCluster}}{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1}\eatline
\nwnotused{Apply all possible registrations to a given E class}\nwidentdefs{\\{{\nwixident{RoundUpSuperCluster}}{RoundUpSuperCluster}}}\nwidentuses{\\{{\nwixident{ANClusterPtr}}{ANClusterPtr}}\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{gANInstantiation}}{gANInstantiation}}\\{{\nwixident{InstantiateCCluster}}{InstantiateCCluster}}\\{{\nwixident{InstantiateFCluster}}{InstantiateFCluster}}\\{{\nwixident{LocatedCluster}}{LocatedCluster}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{ANClusterPtr}}{ANClusterPtr}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{gANInstantiation}}{gANInstantiation}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{InstantiateCCluster}}{InstantiateCCluster}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{InstantiateFCluster}}{InstantiateFCluster}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{LocatedCluster}}{LocatedCluster}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-1qAXg2-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1qAXg2-1}\nwendcode{}\nwbegindocs{158}\nwdocspar
\subsection{More methods}

\nwenddocs{}\nwbegincode{159}\sublabel{NW4MEPPp-1aEz1p-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1aEz1p-1}}}\moddef{Initialize Empty in Equality Class~{\nwtagstyle{}\subpageref{NW4MEPPp-1aEz1p-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InitEmptyInEqClass}{NW4MEPPp-1aEz1p-1}(var lEqPendings: IntRel);
var
   ii: integer;
   lAttr: AttrPtr;
   lUniqueTrm: TrmPtr;
begin
   //  Empty
   if gBuiltIn[rqEmptySet] <> 0 then
   begin
      ii := 1;
      while ii <= \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
      begin
         if  EqClass<>nil then
         begin
            lAttr := SuperCluster^.GetAttr(gBuiltIn[rqEmpty],nil);
            if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
            begin lUniqueTrm := NewFuncTrm(gBuiltIn[rqEmptySet],nil);
            \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lUniqueTrm);
            //         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(ii,lUniqueTrm^.TrmInfo);
            if ii <> lUniqueTrm^.TrmInfo then
               \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqPendings,ii,lUniqueTrm^.TrmInfo);
            end;
         end;
         inc(ii);
      end;
   end;
   if gBuiltIn[rqZeroNumber] <> 0 then
   begin
      ii := 1;
      while ii <= \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
      begin
         if  EqClass<>nil then
         begin
            lAttr := SuperCluster^.GetAttr(gBuiltIn[rqZero],nil);
            if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
            begin
               lUniqueTrm := NewFuncTrm(gBuiltIn[rqZeroNumber],nil);
               \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lUniqueTrm);
               //         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(ii,lUniqueTrm^.TrmInfo);
               if ii <> lUniqueTrm^.TrmInfo then
                  \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqPendings,ii,lUniqueTrm^.TrmInfo);
            end;
         end;
         inc(ii);
      end;
   end;
end;

\nwindexdefn{\nwixident{InitEmptyInEqClass}}{InitEmptyInEqClass}{NW4MEPPp-1aEz1p-1}\eatline
\nwnotused{Initialize Empty in Equality Class}\nwidentdefs{\\{{\nwixident{InitEmptyInEqClass}}{InitEmptyInEqClass}}}\nwidentuses{\\{{\nwixident{AddEquality}}{AddEquality}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}\\{{\nwixident{YTerm}}{YTerm}}}\nwindexuse{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-1aEz1p-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-1aEz1p-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1aEz1p-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-1aEz1p-1}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-1aEz1p-1}\nwendcode{}\nwbegindocs{160}\nwdocspar
\nwenddocs{}\nwbegincode{161}\sublabel{NW4MEPPp-ktNEN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-ktNEN-1}}}\moddef{Check if attribute is strict~{\nwtagstyle{}\subpageref{NW4MEPPp-ktNEN-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{IsStrict}{NW4MEPPp-ktNEN-1}(Item: AttrPtr): boolean;
begin
   with ConstrPtr( Constr[ coAttribute].At( Item^.fAttrNr))^ do
      \nwlinkedidentc{IsStrict}{NW4MEPPp-ktNEN-1} := (syAbstractness in fProperties) and (Item^.fNeg = 1);
end;
\nwindexdefn{\nwixident{IsStrict}}{IsStrict}{NW4MEPPp-ktNEN-1}\eatline
\nwnotused{Check if attribute is strict}\nwidentdefs{\\{{\nwixident{IsStrict}}{IsStrict}}}\nwendcode{}\nwbegindocs{162}\nwdocspar
\nwenddocs{}\nwbegincode{163}\sublabel{NW4MEPPp-E6LZj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-E6LZj-1}}}\moddef{Initialize structures in equality class~{\nwtagstyle{}\subpageref{NW4MEPPp-E6LZj-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InitStructuresInEqClass}{NW4MEPPp-E6LZj-1};
var
   ii,x,z,lStrictStruct: integer;
   lEqs: IntRel;
   lTrm: TrmPtr;
begin
   // Structury
   \{ Nie obrabiamy na razie selektorowych fuktorow majacych typ "strict" \}
   \{ We do not currently process selector factors with the "strict" type \}
   ii := 1;
   while ii <= \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
   begin
      if EqClass <> nil then
      begin
         lStrictStruct := 0;
         with SuperCluster^ do
            for x := 0 to Count-1 do
               with AttrPtr(Items^[x])^,
         ConstrTypPtr(Constr[ coAttribute].Items^[fAttrNr])^.fConstrTyp^ do
            if \nwlinkedidentc{IsStrict}{NW4MEPPp-ktNEN-1}( AttrPtr(Items^[x])) then
               if lStrictStruct = 0 then lStrictStruct := ModNr
                  \{ Nie uwzgledniamy roznych ukladow "over" \}
                  \{ We do not take into account various "over" arrangements \}
               else if ModNr <> lStrictStruct then
               begin
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(12);
                  exit;
               end;
         if lStrictStruct <> 0 then
         begin
            lEqs.Init(8);
            with XTypClass do
               for z := 0 to Count-1 do
                  with TypPtr(Items^[z])^ do
                     if (TypSort = ikTypStruct) and (lStrictStruct = ModNr) then
                     begin
                        lTrm := ReconAggregTrm(lStrictStruct,Term,TypPtr(Items^[z])^.CopyType);
                        if lTrm^.TrmSort <> ikTrmError then
                        begin
                           \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lTrm);
                           //             \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(agTrm^.TrmInfo,Term^.TrmInfo);
                           if lTrm^.TrmInfo <> Term^.TrmInfo then
                              \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqs,lTrm^.TrmInfo,Term^.TrmInfo);
                        end
                        else DisposeTrm(lTrm);
                     end;
            while lEqs.Count > 0 do
            begin
               with lEqs.Items^[0] do \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
               lEqs.AtDelete(0);
            end;
         end;
      end;
      inc(ii);
   end;
end;
\nwindexdefn{\nwixident{InitStructuresInEqClass}}{InitStructuresInEqClass}{NW4MEPPp-E6LZj-1}\eatline
\nwnotused{Initialize structures in equality class}\nwidentdefs{\\{{\nwixident{InitStructuresInEqClass}}{InitStructuresInEqClass}}}\nwidentuses{\\{{\nwixident{AddEquality}}{AddEquality}}\\{{\nwixident{IsStrict}}{IsStrict}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}\\{{\nwixident{YTerm}}{YTerm}}}\nwindexuse{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{IsStrict}}{IsStrict}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-E6LZj-1}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-E6LZj-1}\nwendcode{}\nwbegindocs{164}\nwdocspar
\nwenddocs{}\nwbegincode{165}\sublabel{NW4MEPPp-3rjq8o-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3rjq8o-1}}}\moddef{Execute one reduction~{\nwtagstyle{}\subpageref{NW4MEPPp-3rjq8o-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Executes one reduction
procedure \nwlinkedidentc{ExecuteReduction}{NW4MEPPp-3rjq8o-1}(enr,aRedNr: Integer);
var
   FuncNr1: integer;
   A1: TrmList;
begin
   with ReductionPtr(gReductions.At(aRedNr))^ do
      if nTerms[1]^.TrmSort = ikTrmFunctor then
      begin
         AdjustTrm(nTerms[1],FuncNr1,A1);        
         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(enr,\nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1}(NewFuncTrm(FuncNr1,A1)).TrmInfo);
      end else
         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(enr,\nwlinkedidentc{LocateTerm}{NW4MEPPp-2F8gN0-1}(nTerms[1]).TrmInfo);
end;
\nwindexdefn{\nwixident{ExecuteReduction}}{ExecuteReduction}{NW4MEPPp-3rjq8o-1}\eatline
\nwnotused{Execute one reduction}\nwidentdefs{\\{{\nwixident{ExecuteReduction}}{ExecuteReduction}}}\nwidentuses{\\{{\nwixident{LocateTerm}}{LocateTerm}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{LocateTerm}}{LocateTerm}{NW4MEPPp-3rjq8o-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-3rjq8o-1}\nwendcode{}\nwbegindocs{166}\nwdocspar
\nwenddocs{}\nwbegincode{167}\sublabel{NW4MEPPp-2Tqh0j-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2Tqh0j-1}}}\moddef{Apply all possible reductions to a given E class~{\nwtagstyle{}\subpageref{NW4MEPPp-2Tqh0j-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
//Applies all possible reductions to a given E class
function \nwlinkedidentc{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1}(enr: Integer): boolean;
var
   i: Integer;
   inst0: \nwlinkedidentc{ANInstCollectionPtr}{NW4MEPPp-4TSA9Z-1};
begin
   \nwlinkedidentc{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1} := false;
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[enr] do
   begin
      if EqClass = nil then exit;
      for i := 0 to gReductions.Count-1 do
         with ReductionPtr(gReductions.At(i))^ do
      begin
         inst0 := \nwlinkedidentc{InstantiateTerm}{NW4MEPPp-15kCPx-1}(@nPrimaryList,Term,nTerms[0]);
         case inst0^.Status of
            Regular:
               if inst0^.count > 0 then
               begin
                  \nwlinkedidentc{gANInstantiation}{NW4MEPPp-3tfB6L-1} := inst0^.At(0);
                  \nwlinkedidentc{ExecuteReduction}{NW4MEPPp-3rjq8o-1}(enr,i);
                  \nwlinkedidentc{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1} := true;
               end;
            Top:
               begin
                  \nwlinkedidentc{ExecuteReduction}{NW4MEPPp-3rjq8o-1}(enr,i);
                  \nwlinkedidentc{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1} := true;
               end;
         end;
         dispose(inst0,Done);
      end;
   end;
end;
\nwindexdefn{\nwixident{ProcessReductionsAN}}{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1}\eatline
\nwnotused{Apply all possible reductions to a given E class}\nwidentdefs{\\{{\nwixident{ProcessReductionsAN}}{ProcessReductionsAN}}}\nwidentuses{\\{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}\\{{\nwixident{ExecuteReduction}}{ExecuteReduction}}\\{{\nwixident{gANInstantiation}}{gANInstantiation}}\\{{\nwixident{InstantiateTerm}}{InstantiateTerm}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}{NW4MEPPp-2Tqh0j-1}\nwindexuse{\nwixident{ExecuteReduction}}{ExecuteReduction}{NW4MEPPp-2Tqh0j-1}\nwindexuse{\nwixident{gANInstantiation}}{gANInstantiation}{NW4MEPPp-2Tqh0j-1}\nwindexuse{\nwixident{InstantiateTerm}}{InstantiateTerm}{NW4MEPPp-2Tqh0j-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2Tqh0j-1}\nwendcode{}\nwbegindocs{168}\nwdocspar
\nwenddocs{}\nwbegincode{169}\sublabel{NW4MEPPp-2RSnyx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2RSnyx-1}}}\moddef{Process reductions~{\nwtagstyle{}\subpageref{NW4MEPPp-2RSnyx-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ProcessReductions}{NW4MEPPp-2RSnyx-1};
var
   k: integer;
begin
   if \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} > 0 then
      for k := 0 to DTrm.Count-1 do
         if DTrm.At(k) <> nil then
            \nwlinkedidentc{ProcessReductionsAN}{NW4MEPPp-2Tqh0j-1}(TrmPtr(DTrm.At(k)).TrmInfo);
end;
\nwindexdefn{\nwixident{ProcessReductions}}{ProcessReductions}{NW4MEPPp-2RSnyx-1}\eatline
\nwnotused{Process reductions}\nwidentdefs{\\{{\nwixident{ProcessReductions}}{ProcessReductions}}}\nwidentuses{\\{{\nwixident{ProcessReductionsAN}}{ProcessReductionsAN}}\\{{\nwixident{TrmNbr}}{TrmNbr}}}\nwindexuse{\nwixident{ProcessReductionsAN}}{ProcessReductionsAN}{NW4MEPPp-2RSnyx-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-2RSnyx-1}\nwendcode{}\nwbegindocs{170}\nwdocspar
\nwenddocs{}\nwbegincode{171}\sublabel{NW4MEPPp-z6Fof-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-z6Fof-1}}}\moddef{Check if a cluster is a complex number~{\nwtagstyle{}\subpageref{NW4MEPPp-z6Fof-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(aCluster: AttrCollectionPtr): boolean;
var
   lAttr: AttrPtr;
begin
   lAttr := aCluster^.GetAttr(gBuiltIn[rqComplex],nil);
   \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1} := (lAttr<>nil) and (lAttr^.fNeg=ord(true));
end;
\nwindexdefn{\nwixident{IsComplexNumber}}{IsComplexNumber}{NW4MEPPp-z6Fof-1}\eatline
\nwnotused{Check if a cluster is a complex number}\nwidentdefs{\\{{\nwixident{IsComplexNumber}}{IsComplexNumber}}}\nwendcode{}\nwbegindocs{172}\nwdocspar
\nwenddocs{}\nwbegincode{173}\sublabel{NW4MEPPp-2kKu1H-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2kKu1H-1}}}\moddef{Insert complex~{\nwtagstyle{}\subpageref{NW4MEPPp-2kKu1H-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(aNr: integer);
begin
   with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[aNr] do
   begin
      MizAssert(7321,EqClass <> nil);
      if not \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(SuperCluster) then
      begin
         SuperCluster^.InsertAttr(gBuiltIn[rqComplex],ord(true),nil);
         if not SuperCluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(13);
      end;
   end;
end;
\nwindexdefn{\nwixident{InsertComplex}}{InsertComplex}{NW4MEPPp-2kKu1H-1}\eatline
\nwnotused{Insert complex}\nwidentdefs{\\{{\nwixident{InsertComplex}}{InsertComplex}}}\nwidentuses{\\{{\nwixident{IsComplexNumber}}{IsComplexNumber}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{IsComplexNumber}}{IsComplexNumber}{NW4MEPPp-2kKu1H-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-2kKu1H-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2kKu1H-1}\nwendcode{}\nwbegindocs{174}\nwdocspar
\nwenddocs{}\nwbegincode{175}\sublabel{NW4MEPPp-2kjDN2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2kjDN2-1}}}\moddef{Initialize super cluster for complex numbers~{\nwtagstyle{}\subpageref{NW4MEPPp-2kjDN2-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InitSuperClusterForComplex}{NW4MEPPp-2kjDN2-1};
var
   ii: integer;
   lTL: TrmList;
begin
   // inserting attribute complex into a SuperCluster of a EqClass
   // which contains an standard complex operations ( *,+,-,/ )
   // or it is an argument of it
   if gBuiltIn[rqComplex] = 0 then exit;
   
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
   begin
      LTL := EqClass;
      while LTL<>nil do
      begin
         with FuncTrmPtr(LTL^.XTrmPtr)^ do
      case TrmSort of
         ikTrmInfConst:
            if NumValue.Determined then
               \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(ii);
         ikTrmFunctor:
            case gRevReq[FuncNr] of
               rqImaginaryUnit:
                  \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(ii);
               rqRealAdd,  rqRealMult, rqRealDiff, rqRealDiv:
                  begin
                     \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo);
                     \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo);
                     \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(ii);
                  end;
               rqRealNeg, rqRealInv:
                  begin
                     \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo);
                     \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(ii);
                  end;
            end;
      end;
         lTL := lTL^.NextTrm;
      end;
   end;
end;

\nwindexdefn{\nwixident{InitSuperClusterForComplex}}{InitSuperClusterForComplex}{NW4MEPPp-2kjDN2-1}\eatline
\nwnotused{Initialize super cluster for complex numbers}\nwidentdefs{\\{{\nwixident{InitSuperClusterForComplex}}{InitSuperClusterForComplex}}}\nwidentuses{\\{{\nwixident{InsertComplex}}{InsertComplex}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{InsertComplex}}{InsertComplex}{NW4MEPPp-2kjDN2-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-2kjDN2-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2kjDN2-1}\nwendcode{}\nwbegindocs{176}\nwdocspar
\nwenddocs{}\nwbegincode{177}\sublabel{NW4MEPPp-2jO3Qb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2jO3Qb-1}}}\moddef{Check if a term list is the empty set~{\nwtagstyle{}\subpageref{NW4MEPPp-2jO3Qb-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(aTrmList: TrmList): boolean;
begin
   while aTrmList <> nil do
   begin
      with FuncTrmPtr(aTrmList^.XTrmPtr)^ do
         if (TrmSort=ikTrmFunctor) and (FuncNr=gBuiltIn[rqEmptySet]) then
         begin \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1} := true;
         exit;
         end
         else aTrmList := aTrmList^.NextTrm;
   end;
   \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1} := false;
end;
\nwindexdefn{\nwixident{IsItEmptySet}}{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}\eatline
\nwnotused{Check if a term list is the empty set}\nwidentdefs{\\{{\nwixident{IsItEmptySet}}{IsItEmptySet}}}\nwendcode{}\nwbegindocs{178}\nwdocspar
\nwenddocs{}\nwbegincode{179}\sublabel{NW4MEPPp-22qC3q-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-22qC3q-1}}}\moddef{Equate complex values~{\nwtagstyle{}\subpageref{NW4MEPPp-22qC3q-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(aTrmInfo: integer;
                             V: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1});
var
   i: Integer;
begin
   (*** if V <= MaxConstInt then***)
   if Trms[aTrmInfo].NumValue.Determined then
   begin
      if not AreEqComplex(Trms[aTrmInfo].NumValue.NumericValue,V.NumericValue) then
      begin
         \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(14);
         exit;
      end;
   end
   else
   begin
      for i := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         if Trms[i].EqClass<>nil then
            if Trms[i].NumValue.Determined and
                  AreEqComplex(Trms[i].NumValue.NumericValue,V.NumericValue)  then
            begin
               \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(aTrmInfo,i);
               if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
               break;
               \{ skad tu moze byc sprzecznosc ??? \}
               \{ where can there be a contradiction here??? \}
            end;
      clash := true;
      Trms[aTrmInfo].NumValue.Determined := true;
      Trms[aTrmInfo].NumValue.NumericValue := V.NumericValue;
   end;
end;
\nwindexdefn{\nwixident{EquateComplexValue}}{EquateComplexValue}{NW4MEPPp-22qC3q-1}\eatline
\nwnotused{Equate complex values}\nwidentdefs{\\{{\nwixident{EquateComplexValue}}{EquateComplexValue}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{UnionTrms}}{UnionTrms}}\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-22qC3q-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-22qC3q-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-22qC3q-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-22qC3q-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-22qC3q-1}\nwendcode{}\nwbegindocs{180}\nwdocspar
\nwenddocs{}\nwbegincode{181}\sublabel{NW4MEPPp-40vKAU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-40vKAU-1}}}\moddef{``XXX''~{\nwtagstyle{}\subpageref{NW4MEPPp-40vKAU-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{XXX}{NW4MEPPp-40vKAU-1}(ff: char;
              const FTL: MList);
var
   cl: boolean;
   lArgs1,lArgs2: TrmList;
   i,l1,l2: integer;
label Different;
begin
   if FTL.Count=0 then exit;
   with FTL do
      for l1 := 0 to Count-2 do
      begin
         for l2 := l1+1 to Count-1 do
            with FuncTrmPtr(Items^[l2])^ do
         begin
            if FuncTrmPtr(Items^[l1])^.TrmInfo<>TrmInfo then
            begin
               cl := false;
               case ff of
                  \{ co z adjustacja wariantu ikTrmFunctor ? \}
                  \{ what about ikTrmFunctor variant adjustment? \}
                  ikTrmFunctor:
                     begin
                        lArgs1 := AdjustTrmList(ikTrmFunctor,FuncTrmPtr(Items^[l1])^.FuncNr,FuncTrmPtr(Items^[l1])^.FuncArgs);
                        lArgs2 := AdjustTrmList(ikTrmFunctor,FuncNr,FuncArgs);
                        cl := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgs1,lArgs2);
                     end;

                  ikTrmSchFunc,ikTrmPrivFunc:
                     cl := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(FuncTrmPtr(FuncTrmPtr(Items^[l1]))^.FuncArgs,FuncArgs);
                  \{ Trzeba usunac nieistotne \}
                  \{ Need to remove irrelevant ones \}
                  ikTrmAggreg:
                     begin
                        lArgs1 := FuncTrmPtr(Items^[l1])^.FuncArgs;
                        lArgs2 := FuncArgs;
                        for i := 1 to AggrConstrPtr( Constr[ coAggregate].At( FuncNr))^.fAggregBase do
                        begin
                           lArgs1 := lArgs1^.NextTrm;
                           lArgs2 := lArgs2^.NextTrm;
                        end;
                        cl := \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(lArgs1,lArgs2);
                     end;

                  ikTrmSelector:
                     cl := \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(LastArg(FuncTrmPtr(FuncTrmPtr(Items^[l1]))^.FuncArgs),LastArg(FuncArgs));

                  ikTrmFraenkel:
                     with FraenkelTrmPtr(Items^[l2])^ do
                     if FraenkelTrmPtr(FuncTrmPtr(Items^[l1]))^.LambdaArgs.Count = LambdaArgs.Count then
                     begin
                        for i := 0 to LambdaArgs.Count-1 do
                           if not \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(LambdaArgs.Items^[i],
                                         FraenkelTrmPtr(FuncTrmPtr(Items^[l1]))^.LambdaArgs.Items^[i]) then
                              goto Different;
                        cl :=  \nwlinkedidentc{EqTrms}{NW4MEPPp-4WdwKE-1}(LambdaScope,FraenkelTrmPtr(FuncTrmPtr(Items^[l1]))^.LambdaScope) and
                           \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(Compr,FraenkelTrmPtr(FuncTrmPtr(Items^[l1]))^.Compr);
                     end;
                  
                  ikTrmChoice:
                     cl := \nwlinkedidentc{EqTyps}{NW4MEPPp-141Af5-1}(ChoiceTrmPtr(Items^[l1])^.ChoiceTyp,
                                  ChoiceTrmPtr(Items^[l2])^.ChoiceTyp);
               end;
               if cl then
               begin
                  \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(FuncTrmPtr(Items^[l1])^.TrmInfo,TrmInfo);
                  if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
               end;
            end;
            Different:
         end;
      end;
end;
\nwindexdefn{\nwixident{XXX}}{XXX}{NW4MEPPp-40vKAU-1}\eatline
\nwnotused{``XXX''}\nwidentdefs{\\{{\nwixident{XXX}}{XXX}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{EqFrms}}{EqFrms}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{EqTrms}}{EqTrms}}\\{{\nwixident{EqTyps}}{EqTyps}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-40vKAU-1}\nwindexuse{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-40vKAU-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-40vKAU-1}\nwindexuse{\nwixident{EqTrms}}{EqTrms}{NW4MEPPp-40vKAU-1}\nwindexuse{\nwixident{EqTyps}}{EqTyps}{NW4MEPPp-40vKAU-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-40vKAU-1}\nwendcode{}\nwbegindocs{182}\nwdocspar
\nwenddocs{}\nwbegincode{183}\sublabel{NW4MEPPp-aZNaO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-aZNaO-1}}}\moddef{Apply arithmetical identities~{\nwtagstyle{}\subpageref{NW4MEPPp-aZNaO-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{Identities}{NW4MEPPp-aZNaO-1}(aArithmIncl: boolean);
var
   lStructArg1,lStructArg2: TrmList;
   k,EqNr1,EqNr2: integer;
   lt1,lt2: TrmPtr;
   F1: TrmList;
   lFunctor: integer;
   lTrmInfo: integer;
   z,ii,ll: integer;
   lVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1};
   e: ComplexTrmExprKind;
label Found,Next;
begin
   repeat
      for z := 0 to FuncTrmList[expTrmAggreg].Count-1 do
      begin
         with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmAggreg].Items^[z])^.fTerms do
            for ii := 0 to Count-1 do
               with FuncTrmPtr(Items^[ii])^ do
            begin
               for ll := ii+1 to Count-1 do
               begin
                  if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[FuncTrmPtr(Items^[ll])^.TrmInfo].Term^.TrmInfo
                     = \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo then goto Found;
               end;
               goto Next;
               Found:
                  \{ Przewijamy nieistotne argumenty \}
                  \{ Scroll through irrelevant arguments \}
                  lStructArg1 := FuncArgs;
               lStructArg2 := FuncTrmPtr(Items^[ll])^.FuncArgs;
               for k := 1 to AggrConstrPtr( Constr[ coAggregate].At( FuncNr))^.fAggregBase do
               begin
                  lStructArg1 := lStructArg1^.NextTrm;
                  lStructArg2 := lStructArg2^.NextTrm;
               end;
               while lStructArg1 <> nil do
               begin
                  mizassert(2999,lStructArg1^.XTrmPtr^.TrmInfo<=\nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3});
                  EqNr1 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lStructArg1^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                  EqNr2 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lStructArg2^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                  if EqNr1 <> EqNr2 then \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(EqNr1,EqNr2);
                  lStructArg1 := lStructArg1^.NextTrm; lStructArg2 := lStructArg2^.NextTrm;
               end;
               Next:
            end;
      end;
      
      with FuncTrmList[expTrmFunctor] do
         for z := 0 to Count-1 do
            with \nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(FuncTrmList[expTrmFunctor].Items^[z])^ do
         begin
            \{ Idempotence \}
            with ConstrTypPtr( Constr[ coFunctor].At(IntKey))^ do
               if syIdempotence in fProperties then
               begin
                  for ii := 0 to fTerms.Count-1 do
                     with FuncTrmPtr(fTerms.Items^[ii])^ do
                  begin
                     GetArgs2(fFirstArg,fSecondArg,lt1,lt2,FuncArgs);
                     lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                     if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].Term^.TrmInfo = \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt2^.TrmInfo].Term^.TrmInfo
                     then \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                  end;
               end;
            \{ Involutiveness \}
            if aArithmIncl or (IntKey <> gBuiltIn[rqRealNeg])
               or (IntKey <> gBuiltIn[rqRealInv]) then
               with ConstrTypPtr( Constr[ coFunctor].At(IntKey))^ do
                  if syInvolutiveness in fProperties then
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        GetArgs1(fFirstArg,lt1,FuncArgs);
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].Term^.TrmInfo;
                        F1 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lTrmInfo].EqClass;
                        while F1<>nil do
                        begin
                           if (FuncTrmPtr(F1^.XTrmPtr)^.TrmSort = ikTrmFunctor) then
                              if FuncTrmPtr(F1^.XTrmPtr)^.FuncNr = IntKey then
                                 if \nwlinkedidentc{EqButLast}{NW4MEPPp-GMQ7O-1}(FuncArgs,FuncTrmPtr(F1^.XTrmPtr)^.FuncArgs) then
                                 begin
                                    GetArgs1(fFirstArg,lt2,FuncTrmPtr(F1^.XTrmPtr)^.FuncArgs);
                                    \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo,lt2^.TrmInfo);
                                 end;
                           F1 := F1^.NextTrm;
                        end;
                     end;
                  end;
            \{ Projectivity \}
            with ConstrTypPtr( Constr[ coFunctor].At(IntKey))^ do
               if syProjectivity in fProperties then
               begin
                  for ii := 0 to fTerms.Count-1 do
                     with FuncTrmPtr(fTerms.Items^[ii])^ do
                  begin
                     GetArgs1(fFirstArg,lt1,FuncArgs);
                     lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].Term^.TrmInfo;
                     F1 := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lTrmInfo].EqClass;
                     while F1<>nil do
                     begin
                        if (FuncTrmPtr(F1^.XTrmPtr)^.TrmSort = ikTrmFunctor) then
                           if FuncTrmPtr(F1^.XTrmPtr)^.FuncNr = IntKey then
                              if \nwlinkedidentc{EqButLast}{NW4MEPPp-GMQ7O-1}(FuncArgs,FuncTrmPtr(F1^.XTrmPtr)^.FuncArgs) then
                                 \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo,lt1^.TrmInfo);
                        F1 := F1^.NextTrm;
                     end;
                  end;
               end;
            \{ --- BuiltIn --- \}
            case gRevReq[IntKey] of
               rqNone:;
               \{ --- BOOLE --- \}
               rqUnion:
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        if \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].EqClass) then
                           \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt2^.TrmInfo);
                     end;
                  end;
               rqIntersection:
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        if \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].EqClass) then
                           \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                     end;
                  end;
               rqSubtraction:
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        if \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt1^.TrmInfo].EqClass) then
                           \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                        if \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt2^.TrmInfo].EqClass) then
                           \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                     end;
                  end;
               rqSymmetricDifference:
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        if \nwlinkedidentc{IsItEmptySet}{NW4MEPPp-2jO3Qb-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lt2^.TrmInfo].EqClass) then
                           \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                     end;
                  end;
               \{ --- NUMERALS --- \}
               rqSucc:
                  begin
                     for ii := 0 to fTerms.Count-1 do
                        with FuncTrmPtr(fTerms.Items^[ii])^ do
                     begin
                        lt1 := FuncArgs^.XTrmPtr;
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        \nwlinkedidentc{RatSucc}{NW4MEPPp-46PllF-1}(Trms[lt1^.TrmInfo].NumValue,lVal);
                        if lVal.Determined then
                        begin
                           \{$IFDEF CH_REPORT\}
                           CHReport.Out_NumReq2(rqSucc,Trms[lt1^.TrmInfo].NumValue.NumericValue,lVal.NumericValue);
                           \{$ENDIF\}
                           \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                           if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                        end;
                     end;
                  end;
            end;
            \{ --- COMPLEX --- \}
            if aArithmIncl then
               case gRevReq[IntKey] of
                  rqRealAdd:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin
                           lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                           lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                           if Trms[lt1^.TrmInfo].NumValue.Determined then
                              if IsEqWithInt(Trms[lt1^.TrmInfo].NumValue.NumericValue,0) then
                                 \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt2^.TrmInfo);
                           \nwlinkedidentc{RatAdd}{NW4MEPPp-2fQfeG-1}(Trms[lt1^.TrmInfo].NumValue,Trms[lt2^.TrmInfo].NumValue,lVal);
                           if lVal.Determined then
           begin
              \{$IFDEF CH_REPORT\}
              // CHReport.Out_NumReq2(rqRealAdd,
              //                      Trms[lt1^.TrmInfo].NumValue.NumericValue,
              //                      Trms[lt2^.TrmInfo].NumValue.NumericValue);
              \{$ENDIF\}
              \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
              if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
           end;
                        end;
                     end;
                  rqRealMult:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin
                           lt1 := FuncArgs^.XTrmPtr;
                           lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                           if Trms[lt1^.TrmInfo].NumValue.Determined then
                           begin
                              if IsEqWithInt(Trms[lt1^.TrmInfo].NumValue.NumericValue,0) then
                                 \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(TrmInfo,lt1^.TrmInfo)
                              else if IsEqWithInt(Trms[lt1^.TrmInfo].NumValue.NumericValue,1) then
                                 \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(TrmInfo,lt2^.TrmInfo);
                              lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                              \nwlinkedidentc{RatMult}{NW4MEPPp-4bOVm6-1}(Trms[lt1^.TrmInfo].NumValue,Trms[lt2^.TrmInfo].NumValue,lVal);
                              if lVal.Determined then
                              begin
                                 \{$IFDEF CH_REPORT\}
//                CHReport.Out_NumReq2(rqRealMult,
//                                     Trms[lt1^.TrmInfo].NumValue.NumericValue,
//                                     Trms[lt2^.TrmInfo].NumValue.NumericValue);
                                 \{$ENDIF\}
                                 \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                                 if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                              end;
                           end;
                        end;
                     end;
                  rqRealNeg:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin
                           lt1 := FuncArgs^.XTrmPtr;
                           lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                           \nwlinkedidentc{RatOpp}{NW4MEPPp-1alA74-1}(Trms[lt1^.TrmInfo].NumValue,lVal);
                           if lVal.Determined then
                           begin
\{$IFDEF CH_REPORT\}
//              CHReport.Out_NumReq1(rqRealNeg,
//                                   Trms[lt1^.TrmInfo].NumValue.NumericValue);
\{$ENDIF\}
                              \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                              if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                           end;
                        end;
                     end;
                  rqRealInv:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin
                           lt1 := FuncArgs^.XTrmPtr;
                           lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                           \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(Trms[lt1^.TrmInfo].NumValue,lVal);
                           if lVal.Determined then
                           begin
\{$IFDEF CH_REPORT\}
//              CHReport.Out_NumReq1(rqRealInv,
//                                   Trms[lt1^.TrmInfo].NumValue.NumericValue);
\{$ENDIF\}
                              \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                              if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                           end;
                        end;
                     end;
                  rqRealDiff:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin
                           lt1 := FuncArgs^.XTrmPtr; lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                           \{ odejmowanie zera \} \{ subtract zero \}
                           lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                           if Trms[lt2^.TrmInfo].NumValue.Determined then
                              if IsEqWithInt(Trms[lt2^.TrmInfo].NumValue.NumericValue,0) then
                                 \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(lTrmInfo,lt1^.TrmInfo);
                           \{ birzemy przeciwny do drugie argumentu \}
                           \{we take the opposite of the second argument\}
                           
                           \nwlinkedidentc{RatOpp}{NW4MEPPp-1alA74-1}(Trms[lt2^.TrmInfo].NumValue,lVal);
                           \{ odejmowanie od zera \} \{ subtract zero \}
                           if lVal.Determined then
                              \{ dodajemy przeciwny do drugiego argumentu \}
                              \{ we add the opposite to the second argument \}
                           begin \nwlinkedidentc{RatAdd}{NW4MEPPp-2fQfeG-1}(Trms[lt1^.TrmInfo].NumValue,lVal,lVal);
                           if lVal.Determined then
                           begin
\{$IFDEF CH_REPORT\}
//                CHReport.Out_NumReq2(rqRealDiff,
//                                    Trms[lt1^.TrmInfo].NumValue.NumericValue,
//                                     Trms[lt2^.TrmInfo].NumValue.NumericValue);
\{$ENDIF\}
                              \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                              if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                           end;
                           end;
                        end;
                     end;
                  rqRealDiv:
                     begin
                        for ii := 0 to fTerms.Count-1 do
                           with FuncTrmPtr(fTerms.Items^[ii])^ do
                        begin lt1 := FuncArgs^.XTrmPtr;
                        lt2 := FuncArgs^.NextTrm^.XTrmPtr;
                        if Trms[lt1^.TrmInfo].NumValue.Determined then
                           \{ dzielenie zera \} \{ subtract zero \}
                           if IsEqWithInt(Trms[lt1^.TrmInfo].NumValue.NumericValue,0) then
                              \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(TrmInfo,lt1^.TrmInfo);
                        lTrmInfo := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[TrmInfo].Term^.TrmInfo;
                        \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(Trms[lt2^.TrmInfo].NumValue,lVal);
                        if lVal.Determined then
                        begin
                           \{ dzielenie przez 1 \} \{ division by 1 \}
                           if IsEqWithInt(lVal.NumericValue,1) then
                              \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(TrmInfo,lt1^.TrmInfo);
                           \nwlinkedidentc{RatMult}{NW4MEPPp-4bOVm6-1}(Trms[lt1^.TrmInfo].NumValue,lVal,lVal);
                           if lVal.Determined then
                           begin
\{$IFDEF CH_REPORT\}
//                 CHReport.Out_NumReq2(rqRealDiv,
//                                      Trms[lt1^.TrmInfo].NumValue.NumericValue,
//                                      Trms[lt2^.TrmInfo].NumValue.NumericValue);
\{$ENDIF\}
                              \nwlinkedidentc{EquateComplexValue}{NW4MEPPp-22qC3q-1}(lTrmInfo,lVal);
                              if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit
                           end;
                        end;
                        end;
                     end;
               end;
         end;
      
      if not clash then exit;
      
      repeat
         clash := false;
         for e := Low(FuncTrmExprKind) to High(FuncTrmExprKind) do
            with FuncTrmList[e] do
               for z := 0 to Count-1 do
               begin
                  \nwlinkedidentc{XXX}{NW4MEPPp-40vKAU-1}(TrmKindArr[e],\nwlinkedidentc{ConstrItem}{NW4MEPPp-54Dll-1}(Items^[z])^.fTerms);
                  if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
               end;
         \nwlinkedidentc{XXX}{NW4MEPPp-40vKAU-1}(ikTrmFraenkel,FrOper);
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
         \nwlinkedidentc{XXX}{NW4MEPPp-40vKAU-1}(ikTrmChoice,ChoiceTerm);
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      until not clash;
      \nwlinkedidentc{ProcessReductions}{NW4MEPPp-2RSnyx-1};
   until false;
end;
\nwindexdefn{\nwixident{Identities}}{Identities}{NW4MEPPp-aZNaO-1}\eatline
\nwnotused{Apply arithmetical identities}\nwidentdefs{\\{{\nwixident{Identities}}{Identities}}}\nwidentuses{\\{{\nwixident{ConstrItem}}{ConstrItem}}\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{EqButLast}}{EqButLast}}\\{{\nwixident{EquateComplexValue}}{EquateComplexValue}}\\{{\nwixident{IsItEmptySet}}{IsItEmptySet}}\\{{\nwixident{ProcessReductions}}{ProcessReductions}}\\{{\nwixident{RatAdd}}{RatAdd}}\\{{\nwixident{RatInv}}{RatInv}}\\{{\nwixident{RatMult}}{RatMult}}\\{{\nwixident{RatOpp}}{RatOpp}}\\{{\nwixident{RatSucc}}{RatSucc}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}\\{{\nwixident{ValRec}}{ValRec}}\\{{\nwixident{XXX}}{XXX}}}\nwindexuse{\nwixident{ConstrItem}}{ConstrItem}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{EqButLast}}{EqButLast}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{EquateComplexValue}}{EquateComplexValue}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{IsItEmptySet}}{IsItEmptySet}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{ProcessReductions}}{ProcessReductions}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{RatAdd}}{RatAdd}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{RatInv}}{RatInv}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{RatMult}}{RatMult}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{RatOpp}}{RatOpp}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{RatSucc}}{RatSucc}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-aZNaO-1}\nwindexuse{\nwixident{XXX}}{XXX}{NW4MEPPp-aZNaO-1}\nwendcode{}\nwbegindocs{184}\nwdocspar
\nwenddocs{}\nwbegincode{185}\sublabel{NW4MEPPp-1AYPAS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1AYPAS-1}}}\moddef{Union equals (for non-complex equations)~{\nwtagstyle{}\subpageref{NW4MEPPp-1AYPAS-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{UnionEqualsForNonComplex}{NW4MEPPp-1AYPAS-1}(var aEqPendings: IntRel);
var
   ii,lEqPendingsNbr: integer;
begin
   ii := 0;
   lEqPendingsNbr := aEqPendings.Count;
   while ii < aEqPendings.Count do
      with aEqPendings.Items^[ii] do
         if \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].SuperCluster) or
               \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].SuperCluster) then
         begin
            \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo);
            \nwlinkedidentc{InsertComplex}{NW4MEPPp-2kKu1H-1}(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo);
            inc(ii)
         end
         else
         begin
            \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
            aEqPendings.AtDelete(ii);
         end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   // Czy jest to poprawne wolanie?
   \{ Is this the correct call? \}
   if lEqPendingsNbr <> aEqPendings.Count then
      \nwlinkedidentc{Identities}{NW4MEPPp-aZNaO-1}(false);
end;
\nwindexdefn{\nwixident{UnionEqualsForNonComplex}}{UnionEqualsForNonComplex}{NW4MEPPp-1AYPAS-1}\eatline
\nwnotused{Union equals (for non-complex equations)}\nwidentdefs{\\{{\nwixident{UnionEqualsForNonComplex}}{UnionEqualsForNonComplex}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{Identities}}{Identities}}\\{{\nwixident{InsertComplex}}{InsertComplex}}\\{{\nwixident{IsComplexNumber}}{IsComplexNumber}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-1AYPAS-1}\nwindexuse{\nwixident{Identities}}{Identities}{NW4MEPPp-1AYPAS-1}\nwindexuse{\nwixident{InsertComplex}}{InsertComplex}{NW4MEPPp-1AYPAS-1}\nwindexuse{\nwixident{IsComplexNumber}}{IsComplexNumber}{NW4MEPPp-1AYPAS-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1AYPAS-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-1AYPAS-1}\nwendcode{}\nwbegindocs{186}\nwdocspar
\nwenddocs{}\nwbegincode{187}\sublabel{NW4MEPPp-390Yo4-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-390Yo4-2}}}\moddef{Substitute variable~{\nwtagstyle{}\subpageref{NW4MEPPp-390Yo4-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4MEPPp-1KdKcq-1}}\nwprevnextdefs{NW4MEPPp-390Yo4-1}{\relax}\nwenddeflinemarkup
procedure \nwlinkedidentc{SubstVar}{NW4MEPPp-390Yo4-2}(lVar,sVar: integer);
var
   t,i: integer;
   lPolynomialValues: MList;
   lPolynomial: PolynomialPtr;
begin
   lPolynomial := new(PolynomialPtr,InitWithMonomial(COne,sVar));
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
         if (t <> lVar) and (EqClass <> nil) then
         begin
            lPolynomialValues.Init(0);
            i := 0;
            while i < PolynomialValues.Count do
            begin
               if PolynomialPtr(PolynomialValues.Items^[i])^.HasTheVariable(lVar) then
               begin
                  PolynomialPtr(PolynomialValues.Items^[i])^.InsertValue(lVar,lPolynomial);
                  if PolynomialPtr(PolynomialValues.Items^[i])^.IsNumeric then
                  begin
                     if not NumValue.Determined then
                     begin
                        NumValue.Determined := true;
                        PolynomialPtr(PolynomialValues.Items^[i])^.GetNumeric(NumValue.NumericValue);
                     end
                     else if not PolynomialPtr(PolynomialValues.Items^[i])^.IsNumericEqualWith(NumValue.NumericValue) then
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(15);
                  end;
                  lPolynomialValues.Insert(PolynomialValues.Items^[i]);
                  PolynomialValues.AtDelete(i);
               end else inc(i);
            end;
            for i := 0 to lPolynomialValues.Count-1 do
               PolynomialValues.Insert(lPolynomialValues.Items^[i]);
            lPolynomialValues.DeleteAll;
            lPolynomialValues.Done;
         end;
   Dispose(lPolynomial,Done);
end;

\nwindexdefn{\nwixident{SubstVar}}{SubstVar}{NW4MEPPp-390Yo4-2}\eatline
\nwused{\\{NW4MEPPp-1KdKcq-1}}\nwidentdefs{\\{{\nwixident{SubstVar}}{SubstVar}}}\nwidentuses{\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-390Yo4-2}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-390Yo4-2}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-390Yo4-2}\nwendcode{}\nwbegindocs{188}\nwdocspar
\nwenddocs{}\nwbegincode{189}\sublabel{NW4MEPPp-2W1GeU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2W1GeU-1}}}\moddef{Clear polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-2W1GeU-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1};
var
   t: integer;
begin
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
         if (Term^.TrmInfo <> t) and
               (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Term^.TrmInfo].PolynomialValues.Count > 0) then
            \nwlinkedidentc{SubstVar}{NW4MEPPp-390Yo4-2}(t,Term^.TrmInfo);
end;
\nwindexdefn{\nwixident{ClearPolynomialValues}}{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1}\eatline
\nwnotused{Clear polynomial values}\nwidentdefs{\\{{\nwixident{ClearPolynomialValues}}{ClearPolynomialValues}}}\nwidentuses{\\{{\nwixident{SubstVar}}{SubstVar}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SubstVar}}{SubstVar}{NW4MEPPp-2W1GeU-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-2W1GeU-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-2W1GeU-1}\nwendcode{}\nwbegindocs{190}\nwdocspar
\nwenddocs{}\nwbegincode{191}\sublabel{NW4MEPPp-opCJA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-opCJA-1}}}\moddef{Initialize polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-opCJA-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InitPolynomialValues}{NW4MEPPp-opCJA-1};
var
   t,k,lArg1,lArg2: integer;
   lTrm: TrmPtr;
   lVal: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1};
   lPolynomial1,lPolynomial2: PolynomialPtr;
   lPendingVarSubst: NatSet;
   lEqClass: TrmList;
begin
   if gBuiltIn[rqComplex] = 0 then exit;
   lPendingVarSubst.Init(0,8);
   for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
         if EqClass <> nil then
         begin
            lEqClass := EqClass;
            while lEqClass <> nil do
            begin
               lTrm := lEqClass^.XTrmPtr;
               lEqClass := lEqClass^.NextTrm;
               case lTrm^.TrmSort of
                  ikTrmSchFunc,ikTrmPrivFunc,ikTrmAggreg,ikTrmSelector,ikTrmFraenkel,ikTrmEqConst:
                     if \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(SuperCluster) then
                        PolynomialValues.Insert(new(PolynomialPtr,InitWithMonomial(COne,t)));
                  ikTrmInfConst:
                     if NumValue.Determined then
                     begin
                        PolynomialValues.Insert(new(PolynomialPtr,InitWithNumeric(NumValue.NumericValue)));
                        lPendingVarSubst.InsertElem(t);
                     end
                     else if \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(SuperCluster) then
                        if PolynomialValues.Count = 0 then
                           PolynomialValues.Insert(new(PolynomialPtr,InitWithMonomial(COne,t)));
                  ikTrmFunctor:
                     with FuncTrmPtr(lTrm)^ do
                  begin
                     case gRevReq[FuncNr] of
                        rqImaginaryUnit:
                           begin
                              MizAssert(3292,NumValue.Determined);
                              PolynomialValues.Insert(new(PolynomialPtr,InitWithNumeric(CImUnit)));
                              lPendingVarSubst.InsertElem(t);
                           end;
                        rqRealAdd, rqRealMult, rqRealDiff:
                           begin
                              lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                              lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                              lPolynomial1 := new(PolynomialPtr,InitWithMonomial(COne,lArg1));
                              lPolynomial2 := new(PolynomialPtr,InitWithMonomial(COne,lArg2));
                              case gRevReq[FuncNr] of
                                 rqRealAdd:
                                    PolynomialValues.Insert(AddPolynomials(lPolynomial1,lPolynomial2));
                                 rqRealMult:
                                    PolynomialValues.Insert(MultPolynomials(lPolynomial1,lPolynomial2));
                                 rqRealDiff:
                                    PolynomialValues.Insert(AddPolynomials(lPolynomial1,NMultPolynomial(CMinusOne,lPolynomial2)));
                              end;
                              lPendingVarSubst.InsertElem(t);
                              dispose(lPolynomial2,Done);
                              dispose(lPolynomial1,Done);
                           end;
                        rqRealNeg:
                           begin
                              lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                              lPolynomial1 := new(PolynomialPtr,InitWithMonomial(COne,lArg1));
                              PolynomialValues.Insert(NMultPolynomial(CMinusOne,lPolynomial1));
                              lPendingVarSubst.InsertElem(t);
                              dispose(lPolynomial1,Done);
                           end;
                        rqRealInv:
                           begin
                              PolynomialValues.Insert(new(PolynomialPtr,InitWithMonomial(COne,t)));
                           end;
                        rqRealDiv:
                           begin
                              lArg1 := Trms[FuncArgs^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                              lArg2 := Trms[FuncArgs^.NextTrm^.XTrmPtr^.TrmInfo].Term^.TrmInfo;
                              \nwlinkedidentc{RatInv}{NW4MEPPp-4Wy9FH-1}(Trms[lArg2].NumValue,lVal);
                              if lVal.Determined then
                              begin
                                 lPolynomial1 := new(PolynomialPtr,InitWithMonomial(COne,lArg1));
                                 PolynomialValues.Insert(NMultPolynomial(lVal.NumericValue,lPolynomial1));
                                 lPendingVarSubst.InsertElem(t);
                                 dispose(lPolynomial1,Done);
                              end
                              else
                              begin
                                 PolynomialValues.Insert(new(PolynomialPtr,InitWithMonomial(COne,t)));
                              end;
                           end;
                     else if NumValue.Determined then
                     begin
                        PolynomialValues.Insert(new(PolynomialPtr,InitWithNumeric(NumValue.NumericValue)));
                        lPendingVarSubst.InsertElem(t);
                     end
                     else if \nwlinkedidentc{IsComplexNumber}{NW4MEPPp-z6Fof-1}(SuperCluster) then
                        PolynomialValues.Insert(new(PolynomialPtr,InitWithMonomial(COne,t)));
                     end;
                  end;
                  ikTrmChoice:;
               else RunTimeError(2625);
               end;
            end;
            if PolynomialValues.Count > 1 then
            begin
               for k := 0 to PolynomialValues.Count-1 do
                  if PolynomialPtr(PolynomialValues.Items^[k])^.IsVariable = t then
                  begin PolynomialValues.AtFree(k);
                  break
                  end;
            end;
         end;
   \{$IFDEF MDEBUG\}
   //writeln(InfoFile,'---------------------- w trakcie InitPolynomialValues');
   //infoeqclasses;
   //writeln(InfoFile,'---------------------- koniec wydruku w trakcie InitPolynomialValues');
   \{$ENDIF\};
   \nwlinkedidentc{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}(lPendingVarSubst);
end;
\nwindexdefn{\nwixident{InitPolynomialValues}}{InitPolynomialValues}{NW4MEPPp-opCJA-1}\eatline
\nwnotused{Initialize polynomial values}\nwidentdefs{\\{{\nwixident{InitPolynomialValues}}{InitPolynomialValues}}}\nwidentuses{\\{{\nwixident{IsComplexNumber}}{IsComplexNumber}}\\{{\nwixident{RatInv}}{RatInv}}\\{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{ValRec}}{ValRec}}}\nwindexuse{\nwixident{IsComplexNumber}}{IsComplexNumber}{NW4MEPPp-opCJA-1}\nwindexuse{\nwixident{RatInv}}{RatInv}{NW4MEPPp-opCJA-1}\nwindexuse{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}{NW4MEPPp-opCJA-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-opCJA-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-opCJA-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-opCJA-1}\nwendcode{}\nwbegindocs{192}\nwdocspar
\nwenddocs{}\nwbegincode{193}\sublabel{NW4MEPPp-4Jbl3X-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4Jbl3X-1}}}\moddef{Substitute settings~{\nwtagstyle{}\subpageref{NW4MEPPp-4Jbl3X-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{SubsituteSettings}{NW4MEPPp-4Jbl3X-1}(var aEquals: IntRel);
var
   lPendingVarSubst: NatSet;
begin
   lPendingVarSubst.Init(0,8);
   while aEquals.Count > 0 do
   begin
      with aEquals.Items^[0] do
      begin
         if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Count > 0) and
               (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Count > 0) then
            \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(X,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[0],lPendingVarSubst);
         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
      end;
      aEquals.AtDelete(0);
   end;
   \nwlinkedidentc{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}(lPendingVarSubst);
   aEquals.Done;
end;
\nwindexdefn{\nwixident{SubsituteSettings}}{SubsituteSettings}{NW4MEPPp-4Jbl3X-1}\eatline
\nwnotused{Substitute settings}\nwidentdefs{\\{{\nwixident{SubsituteSettings}}{SubsituteSettings}}}\nwidentuses{\\{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}\\{{\nwixident{SubstituteVariable}}{SubstituteVariable}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}{NW4MEPPp-4Jbl3X-1}\nwindexuse{\nwixident{SubstituteVariable}}{SubstituteVariable}{NW4MEPPp-4Jbl3X-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-4Jbl3X-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-4Jbl3X-1}\nwendcode{}\nwbegindocs{194}\nwdocspar
\nwenddocs{}\nwbegincode{195}\sublabel{NW4MEPPp-1nOrG8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1nOrG8-1}}}\moddef{Equate polynomial values~{\nwtagstyle{}\subpageref{NW4MEPPp-1nOrG8-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{EquatePolynomialValues}{NW4MEPPp-1nOrG8-1}(var aEquals: IntRel);
var
   i,j,j1,j2,lVar1,lVar2,t: integer;
   lPendingVarSubst: NatSet;
   lPolynomial: PolynomialPtr;
label 1;
begin
   if gBuiltIn[rqComplex] = 0 then exit;
   lPendingVarSubst.Init(0,8);
   repeat
      for t := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[t] do
            if (EqClass <> nil) and (PolynomialValues.Count>0) then
            begin
               i := PolynomialPtr(PolynomialValues.Items^[0])^.IsVariable;
               if i > 0 then
               begin
                  if i <> t then
                  begin
                     j := PolynomialPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Trms[i].Term^.TrmInfo].PolynomialValues.Items^[0])^.IsVariable;
                     if j = i then
                     begin
                        if t > i then
                           \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(t,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Trms[i].Term^.TrmInfo].PolynomialValues.Items^[0],lPendingVarSubst)
                        else
                        begin
                           lPolynomial := new(PolynomialPtr,InitWithMonomial(COne,t));
                           \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(i,lPolynomial,lPendingVarSubst);
                           Dispose(lPolynomial,Done);
                        end;
                        \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(t,i);
                     end;
                  end
               end
            end;
      \nwlinkedidentc{SubstitutePendingVars}{NW4MEPPp-cNbbp-1}(lPendingVarSubst);
      i := 0;
      while i < aEquals.Count do
      begin
         with aEquals.Items^[i] do
            if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Count > 0) and
                  (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Count > 0) then
            begin
               for j1 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Count-1 do
                  for j2 := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Count-1 do
                     if ComparePolynomials(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Items^[j1],
                                           \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[j2]) = 0 then
                     begin
                        \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
                        aEquals.AtDelete(i);
                        goto 1;
                     end;
               lVar1 := PolynomialPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Items^[0])^.IsUniVariantVariable;
               lVar2 := PolynomialPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[0])^.IsUniVariantVariable;
               if (lVar1 = \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo) then
               begin
                  if lVar2 = \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo then
                  begin
                     \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
                     aEquals.AtDelete(i);
                     continue;
                  end
                  else if (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].NumValue.Determined
                           and (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Count = 1)) then
                  begin
                     \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(X,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[0],lPendingVarSubst);
                     \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
                     aEquals.AtDelete(i);
                     continue;
                  end
               end
               else if  (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].NumValue.Determined
                         and (\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Count = 1))then
                  if lVar2 = Y then
                  begin
                     \nwlinkedidentc{SubstituteVariable}{NW4MEPPp-390Yo4-1}(Y,\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[X].Term^.TrmInfo].PolynomialValues.Items^[0],lPendingVarSubst);
                     \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
                     aEquals.AtDelete(i);
                     continue;
                  end
                  else if PolynomialPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[Y].Term^.TrmInfo].PolynomialValues.Items^[0])^.IsNumeric then
                     \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(16);
            end;
         inc(i);
         1:
      end;
   until lPendingVarSubst.Count  = 0;
   lPendingVarSubst.Done;
end;
\nwindexdefn{\nwixident{EquatePolynomialValues}}{EquatePolynomialValues}{NW4MEPPp-1nOrG8-1}\eatline
\nwnotused{Equate polynomial values}\nwidentdefs{\\{{\nwixident{EquatePolynomialValues}}{EquatePolynomialValues}}}\nwidentuses{\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}\\{{\nwixident{SubstituteVariable}}{SubstituteVariable}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-1nOrG8-1}\nwindexuse{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}{NW4MEPPp-1nOrG8-1}\nwindexuse{\nwixident{SubstituteVariable}}{SubstituteVariable}{NW4MEPPp-1nOrG8-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-1nOrG8-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1nOrG8-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-1nOrG8-1}\nwendcode{}\nwbegindocs{196}\nwdocspar
\nwenddocs{}\nwbegincode{197}\sublabel{NW4MEPPp-9WAAI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-9WAAI-1}}}\moddef{Equate polynomials~{\nwtagstyle{}\subpageref{NW4MEPPp-9WAAI-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
var
   i1,i2,j1,j2: integer;
label 1;
begin
   \{$IFDEF MINI_PROFILER\}
   MiniProfiler.SectionBegin ('3.1. EquatePolynomials');
   \{$ENDIF\}
   for i1 := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      if (Trms[i1].EqClass <> nil) and (Trms[i1].PolynomialValues.Count > 0) then
         for i2 := i1+1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
         begin
            if (Trms[i2].EqClass <> nil) and (Trms[i2].PolynomialValues.Count > 0) then
               for j1 := 0 to Trms[i1].PolynomialValues.Count-1 do
                  for j2 := 0 to Trms[i2].PolynomialValues.Count-1 do
                     if ComparePolynomials(Trms[i1].PolynomialValues.Items^[j1],
                                           Trms[i2].PolynomialValues.Items^[j2]) = 0 then
                     begin
                        \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(i1,i2);
                        if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
                        begin
                           \{$IFDEF MINI_PROFILER\}
                           MiniProfiler.SectionEnd;
                           \{$ENDIF\}
                           exit;
                        end;
                        goto 1;
                     end;
            1:
         end;
   \{$IFDEF MINI_PROFILER\}
   MiniProfiler.SectionEnd;
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{EquatePolynomials}}{EquatePolynomials}{NW4MEPPp-9WAAI-1}\eatline
\nwnotused{Equate polynomials}\nwidentdefs{\\{{\nwixident{EquatePolynomials}}{EquatePolynomials}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{UnionTrms}}{UnionTrms}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-9WAAI-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-9WAAI-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-9WAAI-1}\nwendcode{}\nwbegindocs{198}\nwdocspar
\nwenddocs{}\nwbegincode{199}\sublabel{NW4MEPPp-43MMpW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-43MMpW-1}}}\moddef{Renumber E classes~{\nwtagstyle{}\subpageref{NW4MEPPp-43MMpW-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{RenumEqClasses}{NW4MEPPp-43MMpW-1};
var
   ii,aii,xx: integer;
   lClusterPtr: AttrCollectionPtr;
begin
   \nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3} := 0;
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with Trms[ii] do
         if  EqClass<>nil then
         begin
            inc(\nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3});
            VarTrmPtr(Trms[ii].Term)^.VarNr := \nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3}
         end;
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with Trms[ii].Term^ do
   begin
      TrmSort := ikTrmEqConst;
      aii := VarTrmPtr(Trms[TrmInfo].Term)^.VarNr;\{aii wprowadzona dla GPC !\}
      \{aii introduced for GPC !\}
      VarTrmPtr(Trms[ii].Term)^.VarNr := aii
   end;
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
         if  EqClass<>nil then
         begin
            with SuperCluster^ do
            begin
               lClusterPtr := new(AttrCollectionPtr,Init(Count,4));
               for xx := 0 to Count-1 do
                  lClusterPtr^.Insert(AttrPtr(Items^[xx])^.CopyAttribute);
            end;
            if not lClusterPtr^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(17);
            dispose(Supercluster,Done);
            Supercluster := lClusterPtr;
            if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
         end;
end;
\nwindexdefn{\nwixident{RenumEqClasses}}{RenumEqClasses}{NW4MEPPp-43MMpW-1}\eatline
\nwnotused{Renumber E classes}\nwidentdefs{\\{{\nwixident{RenumEqClasses}}{RenumEqClasses}}}\nwidentuses{\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{EqClassNbr}}{EqClassNbr}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-43MMpW-1}\nwindexuse{\nwixident{EqClassNbr}}{EqClassNbr}{NW4MEPPp-43MMpW-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-43MMpW-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-43MMpW-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-43MMpW-1}\nwendcode{}\nwbegindocs{200}\nwdocspar
\nwenddocs{}\nwbegincode{201}\sublabel{NW4MEPPp-ZKp2x-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-ZKp2x-1}}}\moddef{Verify contradiction~{\nwtagstyle{}\subpageref{NW4MEPPp-ZKp2x-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{ContradictionVerify}{NW4MEPPp-ZKp2x-1};
var
   ii,j: integer;
   lAttr: AttrPtr;
   hQualTyp: TypPtr;
   lLeftArg,lRightArg: TrmPtr;
begin
   for ii := 0 to \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
   begin
      case FrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.FrmSort of
         ikFrmAttr,ikFrmSchPred,ikFrmPrivPred,ikFrmPred:
            with PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^ do
         begin
            case FrmSort of
               ikFrmAttr:
                  begin
                     lAttr := Trms[LastArg(PredArgs)^.TrmInfo].SuperCluster^.GetAttr(PredNr,CopyTermList1(PredArgs));
                     if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(18);
                        exit
                     end;
                  end;
               ikFrmPred:
                  with ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
                  if syReflexivity in fProperties then
                  begin
                     GetArgs2(fFirstArg,fSecondArg,lLeftArg,lRightArg,PredArgs);
                     if lLeftArg^.TrmInfo = lRightArg^.TrmInfo then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(19);
                        exit
                     end;
                  end;
            end;
            for j := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
               if \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[j],\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii]) then
               begin
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(20);
                  exit
               end;
         end;
         ikFrmQual:
            begin
               hQualTyp := QualFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.QualTyp;
               with hQualTyp^,Trms[QualFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.QualTrm^.TrmInfo].XTypClass do
                                 for j := 0 to Count-1 do
                                    if EqRadices(TypPtr(Items^[j])) then
                                    begin
                                       \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(21);
                                       exit
                                    end;
            end;
      end;
   end;
end;
\nwindexdefn{\nwixident{ContradictionVerify}}{ContradictionVerify}{NW4MEPPp-ZKp2x-1}\eatline
\nwnotused{Verify contradiction}\nwidentdefs{\\{{\nwixident{ContradictionVerify}}{ContradictionVerify}}}\nwidentuses{\\{{\nwixident{EqFrms}}{EqFrms}}\\{{\nwixident{NegBas}}{NegBas}}\\{{\nwixident{PosBas}}{PosBas}}\\{{\nwixident{SetContr}}{SetContr}}}\nwindexuse{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-ZKp2x-1}\nwindexuse{\nwixident{NegBas}}{NegBas}{NW4MEPPp-ZKp2x-1}\nwindexuse{\nwixident{PosBas}}{PosBas}{NW4MEPPp-ZKp2x-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-ZKp2x-1}\nwendcode{}\nwbegindocs{202}\nwdocspar
\nwenddocs{}\nwbegincode{203}\sublabel{NW4MEPPp-1o3Qsj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-1o3Qsj-1}}}\moddef{Insert non-empty (attribute?)~{\nwtagstyle{}\subpageref{NW4MEPPp-1o3Qsj-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertNonEmpty}{NW4MEPPp-1o3Qsj-1}(fTrmInfo1,fTrmInfo2: integer);
var
   lAttr: AttrPtr;
begin
   lAttr := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo1].SuperCluster^.GetAttr(gBuiltIn[rqEmpty],nil);
   if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
   begin
      \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo2].SuperCluster^.InsertAttr(gBuiltIn[rqEmpty],0,nil);
      if not \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo2].SuperCluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(22);
   end;
end;
\nwindexdefn{\nwixident{InsertNonEmpty}}{InsertNonEmpty}{NW4MEPPp-1o3Qsj-1}\eatline
\nwnotused{Insert non-empty (attribute?)}\nwidentdefs{\\{{\nwixident{InsertNonEmpty}}{InsertNonEmpty}}}\nwidentuses{\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-1o3Qsj-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-1o3Qsj-1}\nwendcode{}\nwbegindocs{204}\nwdocspar
\nwenddocs{}\nwbegincode{205}\sublabel{NW4MEPPp-372vgv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-372vgv-1}}}\moddef{Insert non-zero attribute~{\nwtagstyle{}\subpageref{NW4MEPPp-372vgv-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertNonZero}{NW4MEPPp-372vgv-1}(fTrmInfo1,fTrmInfo2: integer);
var
   lAttr: AttrPtr;
begin
   lAttr := \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo1].SuperCluster^.GetAttr(gBuiltIn[rqZero],nil);
   if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
   begin
      \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo2].SuperCluster^.InsertAttr(gBuiltIn[rqZero],0,nil);
      if not \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[fTrmInfo2].SuperCluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(23);
   end;
end;
\nwindexdefn{\nwixident{InsertNonZero}}{InsertNonZero}{NW4MEPPp-372vgv-1}\eatline
\nwnotused{Insert non-zero attribute}\nwidentdefs{\\{{\nwixident{InsertNonZero}}{InsertNonZero}}}\nwidentuses{\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-372vgv-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-372vgv-1}\nwendcode{}\nwbegindocs{206}\nwdocspar
\section{Equate}

The {\Tt{}\nwlinkedidentq{Equate}{NW4MEPPp-3NW9rx-1}\nwendquote} function is a behemoth, and really deserves to be
refactored into more helper functions (or at least carved up in a
literary program to make clear\dots what the hell it's doing).

\nwenddocs{}\nwbegincode{207}\sublabel{NW4MEPPp-3NW9rx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-3NW9rx-1}}}\moddef{Equate~{\nwtagstyle{}\subpageref{NW4MEPPp-3NW9rx-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{Equate}{NW4MEPPp-3NW9rx-1}(var fEval: NatFunc);
var
   j,ii,jj,xi: integer;
   lFrm: FrmPtr;
   lPred,lPred2:integer;
   lArgs,lArgs2: TrmList;
   lLeftArg,lRightArg:TrmPtr;
   lEqClass: TrmList;
   lTyp:TypPtr;
   LTrm1,LTrm2: TrmPtr;
   agTyp,gTyp:TypPtr;
   lSetting,lEqPendings: IntRel;
// lConstSet: NatSet;
   lPolynomials: MCollection;
   lInsTyp: TypPtr; // Rozszerzenia typow uzywane przy negatywnych atrybutywnych.
                    \{ Type extensions used for negative attributives. \}
   llFrm:QualFrmPtr; // pomocnicza przy standaryzacji atrybutywnych, do wyrzucenia !!!
   \{ auxiliary for standardization of attributive attributes, to be thrown away!!! \}
   xx,lTrmInfo1,lTrmInfo2: integer;
   hQualTyp,xType,lQualTyp: TypPtr;
   lEmptyTrm,xTerm,xTerm1,lTrm,lTrm3,lTrm4: TrmPtr;
   k,PredNr2: integer;
   lTrmList,lTrmList1,A1,A2: TrmList;
   lTypClass: MCollection;
   CollectedE: NatSet;
   lTl,llTL1,LTL1,LTL2,sTrmList,selTrmList: TrmList;
   llInsTyp: TypPtr;
   lAttr,lPositive,lNegative,lZero,rPositive,rNegative,rZero: AttrPtr;
   lTrmInfo,lPredNr: integer;
   lEqList: integer;
   lFrm1: FrmPtr;
   z,zz,zz1,zz2,b11,b11ModNr,lModNr1,lModNr2: integer;
   b11Args: TrmList;
   AddedAttr,lVerifyAttr: boolean;
   lAttrTyp: TypPtr;
   lAttrArgs: TrmList;
   lNumValue: \nwlinkedidentc{ValRec}{NW4MEPPp-3tHI3f-1};
   lLatOvfl: boolean;
   e: ComplexTrmExprKind;
   ANi,ANj,ANk,ANl,ANm,ANn: Integer;
   ns1,ns2: NatSetPtr;
label 111,63,EndEquate;
begin \{ \nwlinkedidentc{Equate}{NW4MEPPp-3NW9rx-1} \}
   \{$IFDEF MDEBUG\}
   //writeln(infofile,'InferConstDef.Count=',InferConstDef.Count);
   //for II := 0 to InferConstDef.Count-1 do InfoInferConstDef(II);
   \{$ENDIF\}
   \nwlinkedidentc{EqClassNbr}{NW4MEPPp-3tHI3f-3} := 0;
   
   \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Init(8,16); \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Init(8,16);
   \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} := 0;
   \nwlinkedidentc{TrmOvfl}{NW4MEPPp-3tHI3f-3} := false;
   DTrm.Init(MaxInferConstNbr);
   for e := Low(FuncTrmExprKind) to High(FuncTrmExprKind) do
      FuncTrmList[e].Init(0,10);
   FrOper.InitSorted(0,CompRdTrms);
   ChoiceTerm.InitSorted(0,CompRdTrms);
   \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(0); clash := false;

   lEqPendings.Init(8);
   lSetting.Init(8);
   AllowedCCluster.Init(ConditionalCluster.Count);
   AllowedFCluster.Init(FunctorCluster.Count);
   gDependencies.Init(\nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3});
   ANEqStack.Init(\nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3},10);

(*   lConstSet.Init(0,8);
   lConstSet.Init(gTrms.Count,8);
   for j := 0 to gTrms.Count-1 do
    with TrmsPtr(gTrms.Items^[j])^ do
    begin
     xTerm := NewVarTrm(ikTrmInfConst,nConstrNr);
     \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(xTerm);
     with ConstDefPtr(InferConstDef.Items^[nConstrNr])^ do
     begin
//      lConstSet.InsertElem(nConstrNr);
      ii := xTerm^.TrmInfo;
      lConstSet.InsertElem(ii);
      for z := 0 to fEqConst.Count-1 do
       begin
        lTrm := NewVarTrm(ikTrmInfConst,fEqConst.Items^[z].X);
        \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lTrm);
        if ii <> lTrm^.TrmInfo then
         \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqPendings,ii,lTrm^.TrmInfo);
       end;
      lTrm := CopyExpTrm(fDef);
      \nwlinkedidentc{YYTerm}{NW4MEPPp-1G6XDl-1}(lTrm,ii);
      if ii <> xTerm^.TrmInfo then
        \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lSetting,ii,xTerm^.TrmInfo);
      if \nwlinkedidentc{TrmOvfl}{NW4MEPPp-3tHI3f-3} then begin ChError(14); goto EndEquate1 end;
      if fDef^.TrmSort = ikTrmFunctor then
       with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
        begin
         mizassert(3271,EqClass^.XTrmPtr^.TrmSort = ikTrmFunctor);
         for z := 0 to 1 do
          for k := 0 to nIdentify[z].Count-1 do
           begin
            if not gFuncIdentify.Search(@nIdentify[z].Items^[k].X,xi) then
             gFuncIdentify.AtInsert(xi,new(IdTrmItem, Init(nIdentify[z].Items^[k].X)));
            with IdTrmItem(gFuncIdentify.Items^[xi])^ do
             begin
              IdTrms[z].Insert(EqClass^.XTrmPtr);
              with ConstrTypPtr(Constr[coFunctor].Items^[FuncTrmPtr(fDef)^.FuncNr])^ do
               if Commutativity in fProperties then
                IdTrms[z].Insert(EqClass^.NextTrm^.XTrmPtr);
             end;
           end;
        end;
     end;
    end;
*)

   for j := 0 to Basic.Count-1 do
      if fEval.HasInDom(j) and (fEval.Value(j) = 1) then
         case FrmPtr(Basic.Items^[j])^.FrmSort of
            ikFrmQual:
               begin
                  xType := QualFrmPtr(Basic.Items^[j])^.QualTyp^.CopyType;
                  xTerm := CopyTerm(QualFrmPtr(Basic.Items^[j])^.QualTrm);
                  \nwlinkedidentc{YType}{NW4MEPPp-1ByE5t-1}(xType);
                  \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(xTerm);
                  \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(xType,xTerm^.TrmInfo);
               end;
            ikFrmAttr:
               with PredFrmPtr(Basic.Items^[j])^ do
            begin
               lTrmList := CopyTermList1(PredArgs);
               lTrm := CopyTerm(LastArg(PredArgs));
               \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(lTrmList);
               \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lTrm);
               Trms[Trms[lTrm^.TrmInfo].Term^.TrmInfo].Supercluster^.InsertAttr(PredNr,1,lTrmList);
               if not Trms[Trms[lTrm^.TrmInfo].Term^.TrmInfo].Supercluster^.fConsistent
               then
               begin
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(24);
                  exit;
               end;
            end;
            ikFrmPred:
               begin
                  AdjustFrm(PredFrmPtr(Basic.Items^[j]),lPred,lArgs);
                  if lPred=gBuiltIn[rqEqualsTo] then
                  begin
                     xTerm := CopyTerm(lArgs^.XTrmPtr);
                     xTerm1 := CopyTerm(lArgs^.NextTrm^.XTrmPtr);
                     \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(xTerm);
                     \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(xTerm1);
                     if xTerm^.TrmInfo <> xTerm1^.TrmInfo then
                        \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqPendings,xTerm^.TrmInfo,xTerm1^.TrmInfo);
                  end
                  else goto 63;
               end;
         else
            63:
               begin
                  lFrm := FrmPtr(Basic.Items^[j])^.CopyFormula;
                  \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(lFrm);
                  \{ It would be necessary to experiment whether it is
                    possible to allocate already adjusted, at most
                    allocate before adjustment, but enter adjusted into
                    \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Sentence \}
                  
                  \{ Trzeba by przeeksperymentowac, czy nie mozna alokowac juz zadjustowana,
                    co najwyzej zalokowac przed adjustacja, ale wpisywac zadjustowana do
                    \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Sentence
                  \}
                  \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Insert(lFrm);
                  \{$IFDEF MDEBUG\}
                  // InfoString('PosBas: '); InfoFormula(lFrm); InfoNewLine;
                  \{$ENDIF\}
               end;
         end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   
   for j := 0 to Basic.Count-1 do
      if fEval.HasInDom(j) and (fEval.Value(j) = 0) then
         if FrmPtr(Basic.Items^[j])^.FrmSort  = ikFrmAttr then
            with PredFrmPtr(Basic.Items^[j])^ do
         begin
            lTrmList := CopyTermList1(PredArgs);
            lTrm := CopyTerm(LastArg(PredArgs));
            \nwlinkedidentc{YTermList}{NW4MEPPp-stOEL-1}(lTrmList);
            \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lTrm);
            Trms[Trms[lTrm^.TrmInfo].Term^.TrmInfo].Supercluster^.InsertAttr(PredNr,0,lTrmList);
            if not Trms[Trms[lTrm^.TrmInfo].Term^.TrmInfo].Supercluster^.fConsistent then
            begin
               \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(25);
               exit;
            end;
         end
         else
         begin
            lFrm := FrmPtr(Basic.Items^[j])^.CopyFormula;
            \nwlinkedidentc{YFormula}{NW4MEPPp-2R1rnI-1}(lFrm);
            \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Insert(lFrm);
            \{$IFDEF MDEBUG\}
            // InfoString('NegBas: '); InfoFormula(lFrm); InfoNewLine;
            \{$ENDIF\}
         end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   
   // Looking for occurrences of external (not allowed) constants in registrations
   
   \nwlinkedidentc{InitAllowedClusters}{NW4MEPPp-2bF02H-1};
   
   for II := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
      with FrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[II])^ do
         case FrmSort of
            ikFrmPred:
               with PredFrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[II])^,
            ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
            begin
               if syAsymmetry in fProperties then
               begin
                  z := BasicFrmNr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[II],\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3});
                  if z < 0 then
                     \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Insert(NewPredFrm(FrmSort,PredNr,SwitchArgs(fFirstArg,fSecondArg,PredArgs),0));
               end;
            end;
         end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   
   for II := 0 to \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
      with FrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[II])^ do
         case FrmSort of
            ikFrmPred:
               with PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[II])^,
            ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
               if syConnectedness in fProperties then
               begin
                  z := BasicFrmNr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[II],\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3});
                  if z < 0 then
                     \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Insert(NewPredFrm(FrmSort,PredNr,SwitchArgs(fFirstArg,fSecondArg,PredArgs),0));
               end;
         end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   
   ii := 1;
   while ii <= \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii] do
   begin
      lTL := EqClass;
      while lTL <> nil do
         with lTL^.XTrmPtr^ do
      begin
         if (TrmSort = ikTrmInfConst)
               // and not lConstSet.HasInDom(VarTrmPtr(lTL^.XTrmPtr)^.VarNr)
         then
            with ConstDefPtr(InferConstDef.Items^[VarTrmPtr(lTL^.XTrmPtr)^.VarNr])^ do
         begin
            for z := 0 to fEqConst.Count-1 do
            begin
               lTrm := NewVarTrm(ikTrmInfConst,fEqConst.Items^[z].X);
               \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lTrm);
               if ii <> lTrm^.TrmInfo then
               begin
                  // if nSetting = fEqConst.Items^[z].X then
                  //    \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lSetting,ii,lTerm^.TrmInfo);
                  // else
                  \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lEqPendings,ii,lTrm^.TrmInfo);
               end;
            end;
            lTrm := CopyExpTrm(fDef);
            xi := ii;
            \nwlinkedidentc{YYTerm}{NW4MEPPp-1G6XDl-1}(lTrm,xi);
            if ii <> xi then
               \nwlinkedidentc{AddEquality}{NW4MEPPp-2lqlVt-1}(lSetting,ii,xi);
         end;
         lTL := lTL^.NextTrm;
      end;
      inc(ii);
   end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   \nwlinkedidentc{InitEmptyInEqClass}{NW4MEPPp-1aEz1p-1}(lEqPendings);
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   \nwlinkedidentc{InitStructuresInEqClass}{NW4MEPPp-E6LZj-1};
   if \nwlinkedidentc{TrmOvfl}{NW4MEPPp-3tHI3f-3} then
   begin
      exit;
   end;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
   begin
      exit;
   end;
   
   \nwlinkedidentc{ProcessReductions}{NW4MEPPp-2RSnyx-1};
   
   \nwlinkedidentc{InitSuperClusterForComplex}{NW4MEPPp-2kjDN2-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{UnionEqualsForNonComplex}{NW4MEPPp-1AYPAS-1}(lEqPendings);
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   // Initialisation of the Polynomial Values for numbers
   \nwlinkedidentc{InitPolynomialValues}{NW4MEPPp-opCJA-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{SubsituteSettings}{NW4MEPPp-4Jbl3X-1}(lSetting);
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{EquatePolynomialValues}{NW4MEPPp-1nOrG8-1}(lEqPendings);
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   
   \nwlinkedidentc{ProcessLinearEquations}{NW4MEPPp-3H6RSw-1}(lEqPendings,lPolynomials);
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   while lEqPendings.Count > 0 do
   begin
      with lEqPendings.Items^[0] do
         \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
      lEqPendings.AtDelete(0);
   end;
   lEqPendings.Done;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   repeat
      \nwlinkedidentc{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1};
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      \nwlinkedidentc{Identities}{NW4MEPPp-aZNaO-1}(true);
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   until not clash;
   \nwlinkedidentc{RenumEqClasses}{NW4MEPPp-43MMpW-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   \nwlinkedidentc{ContradictionVerify}{NW4MEPPp-ZKp2x-1};
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   
   //  \nwlinkedidentc{ProcessPolynomialValues}{NW4MEPPp-19YZc6-1}(lEqPendings,lPolynomials);
   lPolynomials.Done;
   if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   if lEqPendings.Count > 0 then
   begin
      repeat
         with lEqPendings.Items^[0] do
            \nwlinkedidentc{UnionTrms}{NW4MEPPp-1zWreN-1}(X,Y);
         lEqPendings.AtDelete(0);
      until lEqPendings.Count = 0;
      lEqPendings.Done;
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      repeat
         \nwlinkedidentc{ClearPolynomialValues}{NW4MEPPp-2W1GeU-1};
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
         \nwlinkedidentc{Identities}{NW4MEPPp-aZNaO-1}(true);
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
         \nwlinkedidentc{EquatePolynomials}{NW4MEPPp-9WAAI-1};
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      until not clash;
      \{ po cholera ta zmiana numeracji ? \}
      \{ what the hell is this numbering change for? \}
      \nwlinkedidentc{RenumEqClasses}{NW4MEPPp-43MMpW-1};
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      \nwlinkedidentc{ContradictionVerify}{NW4MEPPp-ZKp2x-1};
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
   end;
   
   for ii := 0 to \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
      with FrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^ do
         if FrmSort = ikFrmPred then
            with PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[II])^,
   ConstrPtr( Constr[ coPredicate].At(PredNr))^ do
      if syReflexivity in fProperties then
      begin
         GetArgs2(fFirstArg,fSecondArg,lLeftArg,lRightArg,PredArgs);
         lTrmInfo1 := lLeftArg^.TrmInfo;
         lTrmInfo2 := lRightArg^.TrmInfo;
         \nwlinkedidentc{InsertNonEmpty}{NW4MEPPp-1o3Qsj-1}(lTrmInfo1,lTrmInfo2);
         \nwlinkedidentc{InsertNonEmpty}{NW4MEPPp-1o3Qsj-1}(lTrmInfo2,lTrmInfo1);
         \nwlinkedidentc{InsertNonZero}{NW4MEPPp-372vgv-1}(lTrmInfo1,lTrmInfo2);
         \nwlinkedidentc{InsertNonZero}{NW4MEPPp-372vgv-1}(lTrmInfo2,lTrmInfo1);
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then exit;
      end;
   
   AddedAttr := true;
   while AddedAttr do
   begin
      AddedAttr := false;
      for ii := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
         with FrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^ do
      begin
         if FrmSort = ikFrmPred then
         begin
            AdjustFrm(PredFrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[ii]),lPred,lArgs);
            if lPred = gBuiltIn[rqLessOrEqual] then
            begin
               lLeftArg := lArgs^.XTrmPtr;
               lRightArg := lArgs^.NextTrm^.XTrmPtr;
               if (gBuiltIn[rqPositive] > 0) and (gBuiltIn[rqNegative] > 0) then
               begin
                  lPositive := Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil);
                  lNegative := Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil);
                  rPositive := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil);
                  rNegative := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil);
                  if (lPositive<>nil) and (lPositive^.fNeg=ord(true)) then
                  begin
                     if Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil)=nil
                     then AddedAttr := true;
                     Trms[lRightArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqPositive],ord(true),nil);
                     if not Trms[lRightArg^.TrmInfo].Supercluster^.fConsistent then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(26);
                        exit;
                     end;
                  end;
                  if (rNegative<>nil) and (rNegative^.fNeg=ord(true)) then
                  begin
                     if Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil)=nil then AddedAttr := true;
                     Trms[lLeftArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqNegative],ord(true),nil);
                     if not Trms[lLeftArg^.TrmInfo].Supercluster^.fConsistent then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(27);
                        exit;
                     end;
                  end;
                  if (lNegative<>nil) and (lNegative^.fNeg=ord(false)) then
                  begin
                     if Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil)=nil then AddedAttr := true;
                     Trms[lRightArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqNegative],ord(false),nil);
                     if not Trms[lRightArg^.TrmInfo].Supercluster^.fConsistent then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(28);
                        exit;
                     end;
                  end;
                  if (rPositive<>nil) and (rPositive^.fNeg=ord(false)) then
                  begin
                     if Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil)=nil
                     then AddedAttr := true;
                     Trms[lLeftArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqPositive],ord(false),nil);
                     if not Trms[lLeftArg^.TrmInfo].Supercluster^.fConsistent then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(29);
                        exit;
                     end;
                  end;
                  if gBuiltIn[rqZero] > 0 then
                  begin
                     lZero := Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqZero],nil);
                     rZero := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqZero],nil);
                     if (rZero<>nil) and (rZero^.fNeg=ord(false)) and
                           ((lNegative<>nil) and (lNegative^.fNeg=ord(false))) then
                        // or ((lZero<>nil) and (lZero^.fNeg=ord(true))) then
                     begin
                        if Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil)=nil then AddedAttr := true;
                        Trms[lRightArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqPositive],ord(true),nil);
                        if not Trms[lRightArg^.TrmInfo].Supercluster^.fConsistent then
                        begin
                           \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(30);
                           exit;
                        end;
                     end;
                     if (lZero<>nil) and (lZero^.fNeg=ord(false)) and
                           ((rPositive<>nil) and (rPositive^.fNeg=ord(false))) then
                        // or ((rZero<>nil) and (rZero^.fNeg=ord(true))) then
                     begin
                        if Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil)=nil
                        then AddedAttr := true;
                        Trms[lLeftArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqNegative],ord(true),nil);
                        if not Trms[lLeftArg^.TrmInfo].Supercluster^.fConsistent then
                        begin
                           \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(31);
                           exit;
                        end;
                     end
                  end;
               end;
               if Trms[lRightArg^.TrmInfo].NumValue.Determined and
                     Trms[lLeftArg^.TrmInfo].NumValue.Determined and
                     IsRationalGT(Trms[lRightArg^.TrmInfo].NumValue.NumericValue,
                                  Trms[lLeftArg^.TrmInfo].NumValue.NumericValue) then
               begin
                  \{$IFDEF CH_REPORT\}
                  CHReport.Out_NegNumReq2(rqLessOrEqual,
                                          Trms[lLeftArg^.TrmInfo].NumValue.NumericValue,
                                          Trms[lRightArg^.TrmInfo].NumValue.NumericValue);
                  \{$ENDIF\}
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(32);
                  exit;
               end;
            end
            else if lPred = gBuiltIn[rqBelongsTo] then
            begin
               lLeftArg := lArgs^.XTrmPtr; lRightArg := lArgs^.NextTrm^.XTrmPtr;
               if gBuiltIn[rqEmpty] > 0 then
                  Trms[lRightArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqEmpty],0,nil);
               if not Trms[lRightArg^.TrmInfo].Supercluster^.fConsistent then
               begin
                  \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(33);
                  exit;
               end;
               if gBuiltIn[rqElement] > 0 then
               begin
                  lInsTyp := NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                            gBuiltIn[rqElement],NewTrmList(lRightArg,nil));
                  \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(lInsTyp,lLeftArg^.TrmInfo);
               end;
            end
            else if (lPred = gBuiltIn[rqInclusion]) and
                       (gBuiltIn[rqElement] > 0) and (gBuiltIn[rqPowerSet] > 0)  then
            begin lLeftArg := lArgs^.XTrmPtr;
            lRightArg := lArgs^.NextTrm^.XTrmPtr;
            \{ Czy tu przenosic niepustosc na nadzbior ? \}
            \{ Should we transfer non-emptiness to a superset? \}
            lRightArg := 
               NewFuncTrm(gBuiltIn[rqPowerSet],NewTrmList(CopyTerm(lRightArg),nil));
            \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lRightArg);
            lInsTyp := NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                      gBuiltIn[rqElement],NewTrmList(lRightArg,nil));
            \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(lInsTyp,lLeftArg^.TrmInfo);
            end;
         end;
      end;
   end;
   
   \{ Zaszycie (czesciowe) BOOLE:11, :) :) \}
   \{ Patch (partial) BOOLE:11, :) :) \}
   for b11 := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
      for ii := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
         with FrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^ do
            if FrmSort = ikFrmPred then
            begin
               AdjustFrm(PredFrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[ii]),lPred,lArgs);
               if lPred = gBuiltIn[rqBelongsTo] then
               begin
                  lLeftArg := lArgs^.XTrmPtr;
                  lRightArg := lArgs^.NextTrm^.XTrmPtr;
                  lTypClass.Init(0,4);
                  for z := 0 to \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lRightArg^.TrmInfo].XTypClass.Count-1 do
                  begin
                     TypPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lRightArg^.TrmInfo].XTypClass.Items^[z])^.AdjustTyp(b11ModNr,b11Args);
                     if (TypPtr(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[lRightArg^.TrmInfo].XTypClass.Items^[z])^.TypSort = ikTypMode)
                        and (b11ModNr = gBuiltIn[rqElement]) then
                     begin
                        llTL1 := Trms[b11Args^.XTrmPtr^.TrmInfo].EqClass;
                        while llTL1<>nil do
                        begin
                           if (llTL1^.XTrmPtr^.TrmSort = ikTrmFunctor) and
                                 (FuncTrmPtr(llTL1^.XTrmPtr)^.FuncNr = gBuiltIn[rqPowerSet]) then
                           begin
                              lTrmInfo := FuncTrmPtr(llTL1^.XTrmPtr)^.FuncArgs^.XTrmPtr^.TrmInfo;
                              \{!!!uwaga czy zawsze jest gBuiltIn[rqEmpty] <> 0\}
                              \{!!!note whether there is always gBuiltIn[rqEmpty] <> 0\}
                              Trms[lTrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqEmpty],0,nil);
                              if not Trms[lTrmInfo].Supercluster^.fConsistent then \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(34);
                              llInsTyp := NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                                         gBuiltIn[rqElement],
                                                         NewTrmList(FuncTrmPtr(llTL1^.XTrmPtr)^.FuncArgs^.XTrmPtr,nil));
                              lTypClass.Insert(llInsTyp);
                           end;
                           llTL1 := llTL1^.NextTrm;
                        end;
                     end;
                  end;
                  if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
                  begin
                     lTypClass.Done;
                     exit;
                  end;
                  for z := 0 to lTypClass.Count-1 do
                     \nwlinkedidentc{InsertType}{NW4MEPPp-Dle7N-1}(TypPtr(lTypClass.Items^[z]),lLeftArg^.TrmInfo);
                  lTypClass.DeleteAll;
                  lTypClass.Done;
               end;
            end;
   \{ ### Tutaj jest problem - szukamy sprzecznosci miedzy formulami,
     nalezaloby wykorzystac "connectedness" - chyba nalezy szukac
     tutaj rozwiazan, a nie dogenerowywac formule.
   \}
   \{ ### Here is the problem - we are looking for contradictions between the formulas,
     you should use "connectedness" - I think you should look for it
     solutions here, rather than regenerating the formula.
   \}

   \{$IFDEF MDEBUG\}
   //writeln(InfoFile,'TRMS ----');
   //infoeqclasses;
   \{$ENDIF\} ;

   AddedAttr := true;
   while AddedAttr do
   begin
      AddedAttr := false;
      for ii := 0 to \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
      begin
         case FrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.FrmSort of
            ikFrmAttr:
               begin
                  with PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^ do
                     lAttr := Trms[LastArg(PredArgs)^.TrmInfo].SuperCluster^.GetAttr(PredNr,CopyTermList1(PredArgs));
                  if (lAttr<>nil) and (lAttr^.fNeg=ord(true)) then
                  begin
                     \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(35);
                     exit;
                  end;
                  goto 111;
               end;
            ikFrmSchPred,ikFrmPrivPred:
               111:  begin
                        for j := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
                           if FrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[j])^.FrmSort=FrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.FrmSort then
                              if PredFrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[j])^.PredNr=PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.PredNr then
                                 if \nwlinkedidentc{EqTrmLists}{NW4MEPPp-40vpaW-1}(PredFrmPtr(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[j])^.PredArgs,PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.PredArgs) then
                                 begin
                                    \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(36);
                                    exit;
                                 end;
                     end;
            ikFrmPred:
               begin
                  AdjustFrm(PredFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii]),lPred,lArgs);
                  if lPred =  gBuiltIn[rqLessOrEqual] then
                  begin
                     lLeftArg := lArgs^.XTrmPtr;
                     lRightArg := lArgs^.NextTrm^.XTrmPtr;
                     if (gBuiltIn[rqPositive] > 0) and (gBuiltIn[rqNegative] > 0) then
                     begin
                        lPositive := Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil);
                        lNegative := Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil);
                        rPositive := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil);
                        rNegative := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil);
                        if (lPositive<>nil) and (lPositive^.fNeg=ord(false)) then
                        begin
                           if Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqNegative],nil)=nil then AddedAttr := true;
                           Trms[lRightArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqNegative],ord(true),nil);
                           if not Trms[lRightArg^.TrmInfo].Supercluster^.fConsistent then
                           begin
                              \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(37);
                              exit;
                           end;
                        end;
                        if (rNegative<>nil) and (rNegative^.fNeg=ord(false)) then
                        begin
                           if Trms[lLeftArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqPositive],nil)=nil
                           then AddedAttr := true;
                           Trms[lLeftArg^.TrmInfo].Supercluster^.InsertAttr(gBuiltIn[rqPositive],ord(true),nil);
                           if not Trms[lLeftArg^.TrmInfo].Supercluster^.fConsistent then
                           begin
                              \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(38);
                              exit;
                           end;
                        end;
                     end;
                     if Trms[lRightArg^.TrmInfo].NumValue.Determined and
                           Trms[lLeftArg^.TrmInfo].NumValue.Determined and
                           IsRationalLE(Trms[lLeftArg^.TrmInfo].NumValue.NumericValue,
                                        Trms[lRightArg^.TrmInfo].NumValue.NumericValue) then
                     begin
                        \{$IFDEF CH_REPORT\}
                        CHReport.Out_NumReq2(rqLessOrEqual,
                                             Trms[lLeftArg^.TrmInfo].NumValue.NumericValue,
                                             Trms[lRightArg^.TrmInfo].NumValue.NumericValue);
                        \{$ENDIF\}
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(39);
                        exit;
                     end;
                  end
                  else if (lPred = gBuiltIn[rqBelongsTo]) and
                             (gBuiltIn[rqElement] > 0 ) then
                  begin lLeftArg := lArgs^.XTrmPtr;
                  lRightArg := lArgs^.NextTrm^.XTrmPtr;
                  \{ Sprawdzamy, czy zbior RightArg jest niepusty \}
                  \{ We check whether the RightArg set is non-empty \}
                  lAttr := Trms[lRightArg^.TrmInfo].Supercluster^.GetAttr(gBuiltIn[rqEmpty],nil);
                  if (lAttr<>nil) and (lAttr^.fNeg=ord(false)) then
                  begin
                     lTyp := NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                            gBuiltIn[rqElement],
                                            NewTrmList(CopyTerm(lRightArg),nil));
                     with Trms[lLeftArg^.TrmInfo].XTypClass do
                     begin
                        zz1 := 0;
                        while (zz1 < Count) and not(TypPtr(Items^[zz1])^.DecreasingAttrs(lTyp,\nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1})  \{***\}
                                                    and lTyp^.EqRadices(Items^[zz1])) do Inc(zz1);
                        if zz1 < Count then
                        begin
                           dispose(lTyp,Done);
                           \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(40);
                           exit;
                        end;
                     end;
                     dispose(lTyp,Done);
                  end;
                  end
                  else if (lPred = gBuiltIn[rqInclusion]) and
                             (gBuiltIn[rqElement] > 0) and (gBuiltIn[rqPowerSet] > 0)  then
                  begin
                     lLeftArg := lArgs^.XTrmPtr;
                     lRightArg := lArgs^.NextTrm^.XTrmPtr;
                     lRightArg := 
                        NewFuncTrm(gBuiltIn[rqPowerSet],NewTrmList(CopyTerm(lRightArg),nil));
                     \nwlinkedidentc{YTerm}{NW4MEPPp-1kz7f3-1}(lRightArg);
                     lTyp := NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                            gBuiltIn[rqElement],NewTrmList(lRightArg,nil));
                     with Trms[lLeftArg^.TrmInfo].XTypClass do
                     begin
                        zz2 := 0;
                        while (zz2 < Count) and not(TypPtr(Items^[zz2])^.DecreasingAttrs(lTyp,\nwlinkedidentc{EqAttrs}{NW4MEPPp-3UkYuK-1})  \{***\}
                                                    and lTyp^.EqRadices(Items^[zz2])) do Inc(zz2);
                        if zz2 < Count then
                        begin dispose(lTyp,Done);
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(41);
                        exit;
                        end;
                     end;
                     dispose(lTyp,Done);
                  end;
                  for j := 0 to \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Count-1 do
                     if \nwlinkedidentc{EqFrms}{NW4MEPPp-3iPvQ-1}(\nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Items^[j],\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii]) then
                     begin
                        \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(42);
                        exit;
                     end;
               end;
            ikFrmQual:
               begin hQualTyp := QualFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.QualTyp;
               with hQualTyp^,Trms[QualFrmPtr(\nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Items^[ii])^.QualTrm^.TrmInfo].XTypClass do
                                 for zz := 0 to Count-1 do
                                    if EqRadices(TypPtr(Items^[zz])) then
                                    begin
                                       \nwlinkedidentc{SetContr}{NW4MEPPp-2F63Xo-1}(43);
                                       exit;
                                    end;
               end;
         end;
      end;
   end;
   
   //Start of EqStack

   \{$IFDEF DEBUGSUPERCLUSTERS\}
   writeln(InfoFile,'---------------------- ANEqClasses:');
   infoeqclasses;
   writeln(InfoFile,'---------------------- ');
   infonewline;writeln(infofile,'CCLUSTERS:',ConditionalCluster.Count);
   for ANj := 0 to ConditionalCluster.Count-1 do
   begin
      infonewline;writeln(infofile,'(',anj,'):');
      infostring('ante:');infocluster(cclusterptr(conditionalcluster.items^[anj])^.nantecedent);infonewline;
      infostring('cons:');infocluster(cclusterptr(conditionalcluster.items^[anj])^.nconsequent.upper);infonewline;
      infostring('type:');infotype(cclusterptr(conditionalcluster.items^[anj])^.nclustertype);infonewline;
      infostring('prim:');infotypecoll(cclusterptr(conditionalcluster.items^[anj])^.nprimarylist);infonewline;
   end;
   infonewline;writeln(infofile,'FCLUSTERS:',FunctorCluster.Count);
   for ANj := 0 to FunctorCluster.Count-1 do
   begin
      infonewline;writeln(infofile,'(',anj,'):');
      infostring('cons:');infocluster(fclusterptr(functorcluster.items^[anj])^.nconsequent.upper);infonewline;
      infostring('type:');if fclusterptr(functorcluster.items^[anj])^.nclustertype <> nil then infotype(fclusterptr(functorcluster.items^[anj])^.nclustertype) else write(infofile,'NIL type');infonewline;
      infostring('term:');infoterm(fclusterptr(functorcluster.items^[anj])^.nclusterterm);infonewline;
      infostring('prim:');infotypecoll(fclusterptr(functorcluster.items^[anj])^.nprimarylist);infonewline;
   end;
   \{$ENDIF\}
   
   \{$IFDEF MINI_PROFILER\}
   MiniProfiler.SectionBegin ('3.2. SuperclusterRound');
   \{$ENDIF\}
   for ANi := 1 to trmnbr do
   begin
      ns1 := \nwlinkedidentc{DependentClasses}{NW4MEPPp-3vUQ6B-1}(ANi);
      gDependencies.Insert(ns1);
      \{$IFDEF DEBUGSUPERCLUSTERS\}
      if ns1<>nil then begin write(infofile,'Dep[',ani,']:');infonatset(ns1^);infonewline; end;
      \{$ENDIF\}
   end;
   for ANi := 1 to trmnbr do
   begin
      if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ANi].EqClass<>nil then
         ANEqStack.InsertElem(ANi);
   end;
   while ANEqStack.Count > 0 do
   begin
      ANi := ANEqStack.Items^[0].X;
      ANEqStack.DeleteElem(ANi);
      \{$IFDEF DEBUGSUPERCLUSTERS\}
      writeln(infofile,'Rounding:    ',ani);
      \{$ENDIF\}
      if \nwlinkedidentc{RoundUpSuperCluster}{NW4MEPPp-1qAXg2-1}(ANi) then
      begin
         if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
         begin
            \{$IFDEF MINI_PROFILER\}
            MiniProfiler.SectionEnd;
            \{$ENDIF\}
            exit;
         end;
         for ANj := 1 to trmnbr do
            if \nwlinkedidentc{DependsOn}{NW4MEPPp-4UL8Iu-1}(ANi,ANj) then
               with NatFuncPtr(gDependencies.Items^[anj-1])^ do
                  if not HasInDom(ANi) then
                  begin
                     InsertElem(ANi);
                     \{$IFDEF DEBUGSUPERCLUSTERS\}
                     writeln(infofile,'Extra inserted:',ani,' w ', anj);
                     \{$ENDIF\}
                  end;
         ns1 := \nwlinkedidentc{DependentClasses}{NW4MEPPp-3vUQ6B-1}(ANi);
         if ns1 <> nil then
         begin
            for ANj := 0 to ns1^.Count-1 do
               ANEqStack.InsertElem(ns1^.items^[anj].X);
            dispose(ns1,Done);
         end;
      end;
      if \nwlinkedidentc{Contr}{NW4MEPPp-3tHI3f-3} > 0 then
      begin
         \{$IFDEF MINI_PROFILER\}
         MiniProfiler.SectionEnd;
         \{$ENDIF\}
         exit;
      end;
   end;
   \{$IFDEF MINI_PROFILER\}
   MiniProfiler.SectionEnd;
   \{$ENDIF\}
   
   //End of EqStack
   
   \{$IFDEF MDEBUG\}
   //writeln(InfoFile,'TRMS ----');
   //infoeqclasses;
   \{$ENDIF\} ;
   
   EndEquate:
      
end \{ \nwlinkedidentc{Equate}{NW4MEPPp-3NW9rx-1} \};
\nwindexdefn{\nwixident{Equate}}{Equate}{NW4MEPPp-3NW9rx-1}\eatline
\nwnotused{Equate}\nwidentdefs{\\{{\nwixident{Equate}}{Equate}}}\nwidentuses{\\{{\nwixident{AddEquality}}{AddEquality}}\\{{\nwixident{ClearPolynomialValues}}{ClearPolynomialValues}}\\{{\nwixident{Contr}}{Contr}}\\{{\nwixident{ContradictionVerify}}{ContradictionVerify}}\\{{\nwixident{DependentClasses}}{DependentClasses}}\\{{\nwixident{DependsOn}}{DependsOn}}\\{{\nwixident{EqAttrs}}{EqAttrs}}\\{{\nwixident{EqClassNbr}}{EqClassNbr}}\\{{\nwixident{EqFrms}}{EqFrms}}\\{{\nwixident{EqTrmLists}}{EqTrmLists}}\\{{\nwixident{EquatePolynomials}}{EquatePolynomials}}\\{{\nwixident{EquatePolynomialValues}}{EquatePolynomialValues}}\\{{\nwixident{Identities}}{Identities}}\\{{\nwixident{InitAllowedClusters}}{InitAllowedClusters}}\\{{\nwixident{InitEmptyInEqClass}}{InitEmptyInEqClass}}\\{{\nwixident{InitPolynomialValues}}{InitPolynomialValues}}\\{{\nwixident{InitStructuresInEqClass}}{InitStructuresInEqClass}}\\{{\nwixident{InitSuperClusterForComplex}}{InitSuperClusterForComplex}}\\{{\nwixident{InsertNonEmpty}}{InsertNonEmpty}}\\{{\nwixident{InsertNonZero}}{InsertNonZero}}\\{{\nwixident{InsertType}}{InsertType}}\\{{\nwixident{NegBas}}{NegBas}}\\{{\nwixident{PosBas}}{PosBas}}\\{{\nwixident{ProcessLinearEquations}}{ProcessLinearEquations}}\\{{\nwixident{ProcessPolynomialValues}}{ProcessPolynomialValues}}\\{{\nwixident{ProcessReductions}}{ProcessReductions}}\\{{\nwixident{RenumEqClasses}}{RenumEqClasses}}\\{{\nwixident{RoundUpSuperCluster}}{RoundUpSuperCluster}}\\{{\nwixident{SetContr}}{SetContr}}\\{{\nwixident{SubsituteSettings}}{SubsituteSettings}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmOvfl}}{TrmOvfl}}\\{{\nwixident{TrmS}}{TrmS}}\\{{\nwixident{UnionEqualsForNonComplex}}{UnionEqualsForNonComplex}}\\{{\nwixident{UnionTrms}}{UnionTrms}}\\{{\nwixident{ValRec}}{ValRec}}\\{{\nwixident{YFormula}}{YFormula}}\\{{\nwixident{YTerm}}{YTerm}}\\{{\nwixident{YTermList}}{YTermList}}\\{{\nwixident{YType}}{YType}}\\{{\nwixident{YYTerm}}{YYTerm}}}\nwindexuse{\nwixident{AddEquality}}{AddEquality}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ClearPolynomialValues}}{ClearPolynomialValues}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{Contr}}{Contr}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ContradictionVerify}}{ContradictionVerify}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{DependentClasses}}{DependentClasses}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{DependsOn}}{DependsOn}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EqAttrs}}{EqAttrs}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EqClassNbr}}{EqClassNbr}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EqFrms}}{EqFrms}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EqTrmLists}}{EqTrmLists}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EquatePolynomials}}{EquatePolynomials}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{EquatePolynomialValues}}{EquatePolynomialValues}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{Identities}}{Identities}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InitAllowedClusters}}{InitAllowedClusters}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InitEmptyInEqClass}}{InitEmptyInEqClass}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InitPolynomialValues}}{InitPolynomialValues}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InitStructuresInEqClass}}{InitStructuresInEqClass}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InitSuperClusterForComplex}}{InitSuperClusterForComplex}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InsertNonEmpty}}{InsertNonEmpty}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InsertNonZero}}{InsertNonZero}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{InsertType}}{InsertType}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{NegBas}}{NegBas}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{PosBas}}{PosBas}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ProcessLinearEquations}}{ProcessLinearEquations}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ProcessPolynomialValues}}{ProcessPolynomialValues}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ProcessReductions}}{ProcessReductions}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{RenumEqClasses}}{RenumEqClasses}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{RoundUpSuperCluster}}{RoundUpSuperCluster}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{SetContr}}{SetContr}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{SubsituteSettings}}{SubsituteSettings}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{TrmOvfl}}{TrmOvfl}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{UnionEqualsForNonComplex}}{UnionEqualsForNonComplex}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{UnionTrms}}{UnionTrms}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{ValRec}}{ValRec}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{YFormula}}{YFormula}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{YTerm}}{YTerm}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{YTermList}}{YTermList}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{YType}}{YType}{NW4MEPPp-3NW9rx-1}\nwindexuse{\nwixident{YYTerm}}{YYTerm}{NW4MEPPp-3NW9rx-1}\nwendcode{}\nwbegindocs{208}\nwdocspar
\nwenddocs{}\nwbegincode{209}\sublabel{NW4MEPPp-4Or4Va-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-4Or4Va-1}}}\moddef{Dispose equations~{\nwtagstyle{}\subpageref{NW4MEPPp-4Or4Va-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{DispEquations}{NW4MEPPp-4Or4Va-1};
var
   ii: integer;
   e: ComplexTrmExprKind;
begin
   \nwlinkedidentc{NegBas}{NW4MEPPp-3tHI3f-3}.Done;
   \nwlinkedidentc{PosBas}{NW4MEPPp-3tHI3f-3}.Done;
   
   DTrm.DeleteAll;
   DTrm.Done;
   for e := Low(FuncTrmExprKind) to High(FuncTrmExprKind) do
      FuncTrmList[e].Done;
   FrOper.DeleteAll;
   FrOper.Done;
   ChoiceTerm.DeleteAll;
   ChoiceTerm.Done;
   // lConstSet.Done;

   AllowedCCluster.Done;
   AllowedFCluster.Done;
   
   gDependencies.Done;
   ANEqStack.Done;
   
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
   begin
      if \nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii].EqClass <> nil then
      begin
         DisposingSuperclusters := true;
         dispose(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii].SuperCluster,Done);
         DisposingSuperclusters := false;
      end; 
      dispose(\nwlinkedidentc{TrmS}{NW4MEPPp-3tHI3f-3}[ii].Term);
   end;
end;
\nwindexdefn{\nwixident{DispEquations}}{DispEquations}{NW4MEPPp-4Or4Va-1}\eatline
\nwnotused{Dispose equations}\nwidentdefs{\\{{\nwixident{DispEquations}}{DispEquations}}}\nwidentuses{\\{{\nwixident{NegBas}}{NegBas}}\\{{\nwixident{PosBas}}{PosBas}}\\{{\nwixident{TrmNbr}}{TrmNbr}}\\{{\nwixident{TrmS}}{TrmS}}}\nwindexuse{\nwixident{NegBas}}{NegBas}{NW4MEPPp-4Or4Va-1}\nwindexuse{\nwixident{PosBas}}{PosBas}{NW4MEPPp-4Or4Va-1}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-4Or4Va-1}\nwindexuse{\nwixident{TrmS}}{TrmS}{NW4MEPPp-4Or4Va-1}\nwendcode{}\nwbegindocs{210}\nwdocspar
\nwenddocs{}\nwbegincode{211}\sublabel{NW4MEPPp-2VDfy8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4MEPPp-2VDfy8-1}}}\moddef{Dispose E Class in terms~{\nwtagstyle{}\subpageref{NW4MEPPp-2VDfy8-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{DispEqClassInTrms}{NW4MEPPp-2VDfy8-1};
var
   ii: integer;
begin
   for ii := 1 to \nwlinkedidentc{TrmNbr}{NW4MEPPp-3tHI3f-3} do
      with Trms[ii] do
   begin
      if EqClass <> nil then DisposeTrmList(EqClass);
      XTypClass.Done;
   end;
end;
\nwindexdefn{\nwixident{DispEqClassInTrms}}{DispEqClassInTrms}{NW4MEPPp-2VDfy8-1}\eatline

\nwnotused{Dispose E Class in terms}\nwidentdefs{\\{{\nwixident{DispEqClassInTrms}}{DispEqClassInTrms}}}\nwidentuses{\\{{\nwixident{TrmNbr}}{TrmNbr}}}\nwindexuse{\nwixident{TrmNbr}}{TrmNbr}{NW4MEPPp-2VDfy8-1}\nwendcode{}

\nwixlogsorted{c}{{(Lattice) join with another AN instance collection}{NW4MEPPp-EOnOh-1}{\nwixd{NW4MEPPp-EOnOh-1}}}%
\nwixlogsorted{c}{{``XXX''}{NW4MEPPp-40vKAU-1}{\nwixd{NW4MEPPp-40vKAU-1}}}%
\nwixlogsorted{c}{{Add an integer to both sides of an equation}{NW4MEPPp-2lqlVt-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-2lqlVt-1}}}%
\nwixlogsorted{c}{{Add polynomial values}{NW4MEPPp-k1T1A-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-k1T1A-1}}}%
\nwixlogsorted{c}{{Add two rationals}{NW4MEPPp-2fQfeG-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-2fQfeG-1}}}%
\nwixlogsorted{c}{{Allocate a term to a constant collection}{NW4MEPPp-2nHUFT-1}{\nwixd{NW4MEPPp-2nHUFT-1}}}%
\nwixlogsorted{c}{{AN Instance Collection}{NW4MEPPp-4TSA9Z-1}{\nwixd{NW4MEPPp-4TSA9Z-1}}}%
\nwixlogsorted{c}{{Apply all possible reductions to a given E class}{NW4MEPPp-2Tqh0j-1}{\nwixd{NW4MEPPp-2Tqh0j-1}}}%
\nwixlogsorted{c}{{Apply all possible registrations to a given E class}{NW4MEPPp-1qAXg2-1}{\nwixd{NW4MEPPp-1qAXg2-1}}}%
\nwixlogsorted{c}{{Apply arithmetical identities}{NW4MEPPp-aZNaO-1}{\nwixd{NW4MEPPp-aZNaO-1}}}%
\nwixlogsorted{c}{{Check class dependence}{NW4MEPPp-4UL8Iu-1}{\nwixd{NW4MEPPp-4UL8Iu-1}}}%
\nwixlogsorted{c}{{Check for E class in arguments}{NW4MEPPp-1TNvWL-1}{\nwixd{NW4MEPPp-1TNvWL-1}}}%
\nwixlogsorted{c}{{Check if a cluster is a complex number}{NW4MEPPp-z6Fof-1}{\nwixd{NW4MEPPp-z6Fof-1}}}%
\nwixlogsorted{c}{{Check if a formula contains bound variables}{NW4MEPPp-qAgRS-1}{\nwixd{NW4MEPPp-qAgRS-1}}}%
\nwixlogsorted{c}{{Check if a formula contains D constants unavailable in the inference}{NW4MEPPp-wWzhz-1}{\nwixd{NW4MEPPp-wWzhz-1}}}%
\nwixlogsorted{c}{{Check if a term list is the empty set}{NW4MEPPp-2jO3Qb-1}{\nwixd{NW4MEPPp-2jO3Qb-1}}}%
\nwixlogsorted{c}{{Check if attribute is strict}{NW4MEPPp-ktNEN-1}{\nwixd{NW4MEPPp-ktNEN-1}}}%
\nwixlogsorted{c}{{Check if formula does not contain equality}{NW4MEPPp-1jv2gP-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-1jv2gP-1}}}%
\nwixlogsorted{c}{{Check if term lists are equal}{NW4MEPPp-40vpaW-1}{\nwixd{NW4MEPPp-40vpaW-1}}}%
\nwixlogsorted{c}{{Check if term lists are equal, except for the last item}{NW4MEPPp-GMQ7O-1}{\nwixd{NW4MEPPp-GMQ7O-1}}}%
\nwixlogsorted{c}{{Check if two terms are equal}{NW4MEPPp-4WdwKE-1}{\nwixd{NW4MEPPp-4WdwKE-1}}}%
\nwixlogsorted{c}{{Choice Constraint destructor}{NW4MEPPp-UaG4r-1}{\nwixd{NW4MEPPp-UaG4r-1}}}%
\nwixlogsorted{c}{{Choice constructor}{NW4MEPPp-UuAXD-1}{\nwixd{NW4MEPPp-UuAXD-1}}}%
\nwixlogsorted{c}{{Clear polynomial values}{NW4MEPPp-2W1GeU-1}{\nwixd{NW4MEPPp-2W1GeU-1}}}%
\nwixlogsorted{c}{{Construct AN instance collection from an atom}{NW4MEPPp-4Bn3U1-1}{\nwixd{NW4MEPPp-4Bn3U1-1}}}%
\nwixlogsorted{c}{{Constructor for AN Cluster object}{NW4MEPPp-1C9cBZ-1}{\nwixd{NW4MEPPp-1C9cBZ-1}}}%
\nwixlogsorted{c}{{Convert attribute collections to hold attributes with E constants}{NW4MEPPp-1h9hfF-1}{\nwixd{NW4MEPPp-1h9hfF-1}}}%
\nwixlogsorted{c}{{Convert attribute to E classes}{NW4MEPPp-2H0WBZ-1}{\nwixd{NW4MEPPp-2H0WBZ-1}}}%
\nwixlogsorted{c}{{Destruct AN instance collection}{NW4MEPPp-1KrR39-1}{\nwixd{NW4MEPPp-1KrR39-1}}}%
\nwixlogsorted{c}{{Destructor for AN Cluster object}{NW4MEPPp-HGue5-1}{\nwixd{NW4MEPPp-HGue5-1}}}%
\nwixlogsorted{c}{{Determine allowed attribute in cluster}{NW4MEPPp-3Fy5tU-1}{\nwixd{NW4MEPPp-3Fy5tU-1}}}%
\nwixlogsorted{c}{{Determine set of dependent classes}{NW4MEPPp-3vUQ6B-1}{\nwixd{NW4MEPPp-3vUQ6B-1}}}%
\nwixlogsorted{c}{{Dispose E Class in terms}{NW4MEPPp-2VDfy8-1}{\nwixd{NW4MEPPp-2VDfy8-1}}}%
\nwixlogsorted{c}{{Dispose equations}{NW4MEPPp-4Or4Va-1}{\nwixd{NW4MEPPp-4Or4Va-1}}}%
\nwixlogsorted{c}{{Dispose term recurse and list}{NW4MEPPp-3MAeyg-1}{\nwixd{NW4MEPPp-3MAeyg-1}}}%
\nwixlogsorted{c}{{Equalizer implementation}{NW4MEPPp-1WFdzs-1}{\nwixu{NW4MEPPp-2tMLZ6-1}\nwixd{NW4MEPPp-1WFdzs-1}}}%
\nwixlogsorted{c}{{Equalizer interface}{NW4MEPPp-3tHI3f-1}{\nwixu{NW4MEPPp-2tMLZ6-1}\nwixd{NW4MEPPp-3tHI3f-1}\nwixd{NW4MEPPp-3tHI3f-2}\nwixd{NW4MEPPp-3tHI3f-3}\nwixd{NW4MEPPp-3tHI3f-4}}}%
\nwixlogsorted{c}{{Equate}{NW4MEPPp-3NW9rx-1}{\nwixd{NW4MEPPp-3NW9rx-1}}}%
\nwixlogsorted{c}{{Equate complex values}{NW4MEPPp-22qC3q-1}{\nwixd{NW4MEPPp-22qC3q-1}}}%
\nwixlogsorted{c}{{Equate polynomial values}{NW4MEPPp-1nOrG8-1}{\nwixd{NW4MEPPp-1nOrG8-1}}}%
\nwixlogsorted{c}{{Equate polynomials}{NW4MEPPp-9WAAI-1}{\nwixd{NW4MEPPp-9WAAI-1}}}%
\nwixlogsorted{c}{{Execute one reduction}{NW4MEPPp-3rjq8o-1}{\nwixd{NW4MEPPp-3rjq8o-1}}}%
\nwixlogsorted{c}{{Find a term in a constant collection}{NW4MEPPp-3r8YNG-1}{\nwixd{NW4MEPPp-3r8YNG-1}}}%
\nwixlogsorted{c}{{Initialize allowed clusters}{NW4MEPPp-2bF02H-1}{\nwixd{NW4MEPPp-2bF02H-1}}}%
\nwixlogsorted{c}{{Initialize bottom of AN instance collection}{NW4MEPPp-4G0mLr-1}{\nwixd{NW4MEPPp-4G0mLr-1}}}%
\nwixlogsorted{c}{{Initialize Empty in Equality Class}{NW4MEPPp-1aEz1p-1}{\nwixd{NW4MEPPp-1aEz1p-1}}}%
\nwixlogsorted{c}{{Initialize polynomial values}{NW4MEPPp-opCJA-1}{\nwixd{NW4MEPPp-opCJA-1}}}%
\nwixlogsorted{c}{{Initialize structures in equality class}{NW4MEPPp-E6LZj-1}{\nwixd{NW4MEPPp-E6LZj-1}}}%
\nwixlogsorted{c}{{Initialize super cluster for complex numbers}{NW4MEPPp-2kjDN2-1}{\nwixd{NW4MEPPp-2kjDN2-1}}}%
\nwixlogsorted{c}{{Initialize top (of AN instance collection)}{NW4MEPPp-1Tt0jF-1}{\nwixd{NW4MEPPp-1Tt0jF-1}}}%
\nwixlogsorted{c}{{Insert and absorb an element into AN instance collection}{NW4MEPPp-IFzSt-1}{\nwixd{NW4MEPPp-IFzSt-1}}}%
\nwixlogsorted{c}{{Insert complex}{NW4MEPPp-2kKu1H-1}{\nwixd{NW4MEPPp-2kKu1H-1}}}%
\nwixlogsorted{c}{{Insert non-empty (attribute?)}{NW4MEPPp-1o3Qsj-1}{\nwixd{NW4MEPPp-1o3Qsj-1}}}%
\nwixlogsorted{c}{{Insert non-zero attribute}{NW4MEPPp-372vgv-1}{\nwixd{NW4MEPPp-372vgv-1}}}%
\nwixlogsorted{c}{{Insert type}{NW4MEPPp-Dle7N-1}{\nwixd{NW4MEPPp-Dle7N-1}}}%
\nwixlogsorted{c}{{Invert a rational number}{NW4MEPPp-4Wy9FH-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-4Wy9FH-1}}}%
\nwixlogsorted{c}{{kernel/equalizer.pas}{NW4MEPPp-2tMLZ6-1}{\nwixd{NW4MEPPp-2tMLZ6-1}}}%
\nwixlogsorted{c}{{Log a lattice collection(?)}{NW4MEPPp-43LvJn-1}{\nwixd{NW4MEPPp-43LvJn-1}}}%
\nwixlogsorted{c}{{Log a substitution in an AN}{NW4MEPPp-3om7vU-1}{\nwixd{NW4MEPPp-3om7vU-1}}}%
\nwixlogsorted{c}{{Match loci with classes in an attribute collection}{NW4MEPPp-2YvKKn-1}{\nwixd{NW4MEPPp-2YvKKn-1}}}%
\nwixlogsorted{c}{{Match loci with classes in attributes}{NW4MEPPp-1wkHGU-1}{\nwixd{NW4MEPPp-1wkHGU-1}}}%
\nwixlogsorted{c}{{Match loci with classes in conditional registrations}{NW4MEPPp-xRTSq-1}{\nwixd{NW4MEPPp-xRTSq-1}}}%
\nwixlogsorted{c}{{Match loci with classes in radix types}{NW4MEPPp-2EAQ15-1}{\nwixd{NW4MEPPp-2EAQ15-1}}}%
\nwixlogsorted{c}{{Match loci with classes in term registrations}{NW4MEPPp-2D5MuC-1}{\nwixd{NW4MEPPp-2D5MuC-1}}}%
\nwixlogsorted{c}{{Match loci with classes in terms}{NW4MEPPp-15kCPx-1}{\nwixd{NW4MEPPp-15kCPx-1}}}%
\nwixlogsorted{c}{{Match loci with classes in types}{NW4MEPPp-vVcE1-1}{\nwixd{NW4MEPPp-vVcE1-1}}}%
\nwixlogsorted{c}{{Multiply rational numbers}{NW4MEPPp-4bOVm6-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-4bOVm6-1}}}%
\nwixlogsorted{c}{{Negate rational number}{NW4MEPPp-1alA74-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-1alA74-1}}}%
\nwixlogsorted{c}{{Process a system of linear equations}{NW4MEPPp-3H6RSw-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-3H6RSw-1}}}%
\nwixlogsorted{c}{{Process Polynomial values}{NW4MEPPp-19YZc6-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-19YZc6-1}}}%
\nwixlogsorted{c}{{Process reductions}{NW4MEPPp-2RSnyx-1}{\nwixd{NW4MEPPp-2RSnyx-1}}}%
\nwixlogsorted{c}{{Rational arithmetic functions}{NW4MEPPp-1QLcNW-1}{\nwixd{NW4MEPPp-1QLcNW-1}}}%
\nwixlogsorted{c}{{Rational successor function}{NW4MEPPp-46PllF-1}{\nwixu{NW4MEPPp-1QLcNW-1}\nwixd{NW4MEPPp-46PllF-1}}}%
\nwixlogsorted{c}{{Renumber E classes}{NW4MEPPp-43MMpW-1}{\nwixd{NW4MEPPp-43MMpW-1}}}%
\nwixlogsorted{c}{{Round up super clusters}{NW4MEPPp-2KruEm-1}{\nwixd{NW4MEPPp-2KruEm-1}}}%
\nwixlogsorted{c}{{Set contr}{NW4MEPPp-2F63Xo-1}{\nwixd{NW4MEPPp-2F63Xo-1}}}%
\nwixlogsorted{c}{{State variables for AN Cluster Objects}{NW4MEPPp-3tfB6L-1}{\nwixd{NW4MEPPp-3tfB6L-1}}}%
\nwixlogsorted{c}{{Substitute pending variables}{NW4MEPPp-cNbbp-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-cNbbp-1}}}%
\nwixlogsorted{c}{{Substitute settings}{NW4MEPPp-4Jbl3X-1}{\nwixd{NW4MEPPp-4Jbl3X-1}}}%
\nwixlogsorted{c}{{Substitute variable}{NW4MEPPp-390Yo4-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-390Yo4-1}\nwixd{NW4MEPPp-390Yo4-2}}}%
\nwixlogsorted{c}{{Take the union of two AN instance collections}{NW4MEPPp-1u8Tus-1}{\nwixd{NW4MEPPp-1u8Tus-1}}}%
\nwixlogsorted{c}{{Test if two attributes are equal}{NW4MEPPp-3UkYuK-1}{\nwixd{NW4MEPPp-3UkYuK-1}}}%
\nwixlogsorted{c}{{Test if two types are equal}{NW4MEPPp-141Af5-1}{\nwixd{NW4MEPPp-141Af5-1}}}%
\nwixlogsorted{c}{{Test two formulas for equality}{NW4MEPPp-3iPvQ-1}{\nwixd{NW4MEPPp-3iPvQ-1}}}%
\nwixlogsorted{c}{{Try to match a list of terms}{NW4MEPPp-1zYHzy-1}{\nwixd{NW4MEPPp-1zYHzy-1}}}%
\nwixlogsorted{c}{{Try to match a term to an external class}{NW4MEPPp-2F8gN0-1}{\nwixd{NW4MEPPp-2F8gN0-1}}}%
\nwixlogsorted{c}{{Types internal to the equalizer}{NW4MEPPp-54Dll-1}{\nwixu{NW4MEPPp-1WFdzs-1}\nwixd{NW4MEPPp-54Dll-1}}}%
\nwixlogsorted{c}{{Union equals (for non-complex equations)}{NW4MEPPp-1AYPAS-1}{\nwixd{NW4MEPPp-1AYPAS-1}}}%
\nwixlogsorted{c}{{Union terms}{NW4MEPPp-1zWreN-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-1zWreN-1}}}%
\nwixlogsorted{c}{{Verify contradiction}{NW4MEPPp-ZKp2x-1}{\nwixd{NW4MEPPp-ZKp2x-1}}}%
\nwixlogsorted{c}{{Write all equality classes information to file}{NW4MEPPp-3njkGZ-1}{\nwixd{NW4MEPPp-3njkGZ-1}}}%
\nwixlogsorted{c}{{Write equality class information to info file}{NW4MEPPp-1OzTEP-1}{\nwixd{NW4MEPPp-1OzTEP-1}}}%
\nwixlogsorted{c}{{Write function term list information to file}{NW4MEPPp-13aFp2-1}{\nwixd{NW4MEPPp-13aFp2-1}}}%
\nwixlogsorted{c}{{Y Attribute}{NW4MEPPp-4KjpLo-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-4KjpLo-1}}}%
\nwixlogsorted{c}{{Y Cluster}{NW4MEPPp-1RVFLZ-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-1RVFLZ-1}}}%
\nwixlogsorted{c}{{Y Equality Class}{NW4MEPPp-Q6gAz-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-Q6gAz-1}}}%
\nwixlogsorted{c}{{Y Formula}{NW4MEPPp-2R1rnI-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-2R1rnI-1}}}%
\nwixlogsorted{c}{{Y Procedures}{NW4MEPPp-1KdKcq-1}{\nwixd{NW4MEPPp-1KdKcq-1}}}%
\nwixlogsorted{c}{{Y Term}{NW4MEPPp-1kz7f3-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-1kz7f3-1}}}%
\nwixlogsorted{c}{{Y Term list}{NW4MEPPp-stOEL-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-stOEL-1}}}%
\nwixlogsorted{c}{{Y Type}{NW4MEPPp-1ByE5t-1}{\nwixd{NW4MEPPp-1ByE5t-1}}}%
\nwixlogsorted{c}{{YY Term}{NW4MEPPp-1G6XDl-1}{\nwixu{NW4MEPPp-1KdKcq-1}\nwixd{NW4MEPPp-1G6XDl-1}}}%
\nwixlogsorted{i}{{\nwixident{AddEquality}}{AddEquality}}%
\nwixlogsorted{i}{{\nwixident{AddPolynomialValues}}{AddPolynomialValues}}%
\nwixlogsorted{i}{{\nwixident{AllocTerm}}{AllocTerm}}%
\nwixlogsorted{i}{{\nwixident{AllowedAttributeInCluster}}{AllowedAttributeInCluster}}%
\nwixlogsorted{i}{{\nwixident{ANClusterObj}}{ANClusterObj}}%
\nwixlogsorted{i}{{\nwixident{ANClusterPtr}}{ANClusterPtr}}%
\nwixlogsorted{i}{{\nwixident{ANInstCollection}}{ANInstCollection}}%
\nwixlogsorted{i}{{\nwixident{ANInstCollectionPtr}}{ANInstCollectionPtr}}%
\nwixlogsorted{i}{{\nwixident{ChConstrObj}}{ChConstrObj}}%
\nwixlogsorted{i}{{\nwixident{Check{\_}E}}{Check:unE}}%
\nwixlogsorted{i}{{\nwixident{CheckBound}}{CheckBound}}%
\nwixlogsorted{i}{{\nwixident{CheckForClass}}{CheckForClass}}%
\nwixlogsorted{i}{{\nwixident{CheckForDConsts}}{CheckForDConsts}}%
\nwixlogsorted{i}{{\nwixident{ClearPolynomialValues}}{ClearPolynomialValues}}%
\nwixlogsorted{i}{{\nwixident{ConCollection}}{ConCollection}}%
\nwixlogsorted{i}{{\nwixident{ConstrItem}}{ConstrItem}}%
\nwixlogsorted{i}{{\nwixident{Contr}}{Contr}}%
\nwixlogsorted{i}{{\nwixident{ContradictionVerify}}{ContradictionVerify}}%
\nwixlogsorted{i}{{\nwixident{D}}{D}}%
\nwixlogsorted{i}{{\nwixident{DependentClasses}}{DependentClasses}}%
\nwixlogsorted{i}{{\nwixident{DependsOn}}{DependsOn}}%
\nwixlogsorted{i}{{\nwixident{DispEqClassInTrms}}{DispEqClassInTrms}}%
\nwixlogsorted{i}{{\nwixident{DispEquations}}{DispEquations}}%
\nwixlogsorted{i}{{\nwixident{DisposeTrmRecAndList}}{DisposeTrmRecAndList}}%
\nwixlogsorted{i}{{\nwixident{E{\_}free}}{E:unfree}}%
\nwixlogsorted{i}{{\nwixident{EqAttrs}}{EqAttrs}}%
\nwixlogsorted{i}{{\nwixident{EqButLast}}{EqButLast}}%
\nwixlogsorted{i}{{\nwixident{EqClassNbr}}{EqClassNbr}}%
\nwixlogsorted{i}{{\nwixident{EqFrms}}{EqFrms}}%
\nwixlogsorted{i}{{\nwixident{EqTrmLists}}{EqTrmLists}}%
\nwixlogsorted{i}{{\nwixident{EqTrms}}{EqTrms}}%
\nwixlogsorted{i}{{\nwixident{EqTyps}}{EqTyps}}%
\nwixlogsorted{i}{{\nwixident{Equate}}{Equate}}%
\nwixlogsorted{i}{{\nwixident{EquateComplexValue}}{EquateComplexValue}}%
\nwixlogsorted{i}{{\nwixident{EquatePolynomials}}{EquatePolynomials}}%
\nwixlogsorted{i}{{\nwixident{EquatePolynomialValues}}{EquatePolynomialValues}}%
\nwixlogsorted{i}{{\nwixident{ExecuteReduction}}{ExecuteReduction}}%
\nwixlogsorted{i}{{\nwixident{FindTerm}}{FindTerm}}%
\nwixlogsorted{i}{{\nwixident{gANInstantiation}}{gANInstantiation}}%
\nwixlogsorted{i}{{\nwixident{gFound}}{gFound}}%
\nwixlogsorted{i}{{\nwixident{gY}}{gY}}%
\nwixlogsorted{i}{{\nwixident{Identities}}{Identities}}%
\nwixlogsorted{i}{{\nwixident{ImUnit}}{ImUnit}}%
\nwixlogsorted{i}{{\nwixident{InfoEqClass}}{InfoEqClass}}%
\nwixlogsorted{i}{{\nwixident{InfoEqClasses}}{InfoEqClasses}}%
\nwixlogsorted{i}{{\nwixident{InfoFuncTrmList}}{InfoFuncTrmList}}%
\nwixlogsorted{i}{{\nwixident{InfoLatColl}}{InfoLatColl}}%
\nwixlogsorted{i}{{\nwixident{InfoSubstAN}}{InfoSubstAN}}%
\nwixlogsorted{i}{{\nwixident{InitAllowedClusters}}{InitAllowedClusters}}%
\nwixlogsorted{i}{{\nwixident{InitBottom}}{InitBottom}}%
\nwixlogsorted{i}{{\nwixident{InitEmptyInEqClass}}{InitEmptyInEqClass}}%
\nwixlogsorted{i}{{\nwixident{InitPolynomialValues}}{InitPolynomialValues}}%
\nwixlogsorted{i}{{\nwixident{InitSingle}}{InitSingle}}%
\nwixlogsorted{i}{{\nwixident{InitStructuresInEqClass}}{InitStructuresInEqClass}}%
\nwixlogsorted{i}{{\nwixident{InitSuperClusterForComplex}}{InitSuperClusterForComplex}}%
\nwixlogsorted{i}{{\nwixident{InitTop}}{InitTop}}%
\nwixlogsorted{i}{{\nwixident{InsertAndAbsorb}}{InsertAndAbsorb}}%
\nwixlogsorted{i}{{\nwixident{InsertComplex}}{InsertComplex}}%
\nwixlogsorted{i}{{\nwixident{InsertNonEmpty}}{InsertNonEmpty}}%
\nwixlogsorted{i}{{\nwixident{InsertNonZero}}{InsertNonZero}}%
\nwixlogsorted{i}{{\nwixident{InsertType}}{InsertType}}%
\nwixlogsorted{i}{{\nwixident{InstantiateAttr}}{InstantiateAttr}}%
\nwixlogsorted{i}{{\nwixident{InstantiateAttrs}}{InstantiateAttrs}}%
\nwixlogsorted{i}{{\nwixident{InstantiateCCluster}}{InstantiateCCluster}}%
\nwixlogsorted{i}{{\nwixident{InstantiateFCluster}}{InstantiateFCluster}}%
\nwixlogsorted{i}{{\nwixident{InstantiateRadixType}}{InstantiateRadixType}}%
\nwixlogsorted{i}{{\nwixident{InstantiateTerm}}{InstantiateTerm}}%
\nwixlogsorted{i}{{\nwixident{InstantiateType}}{InstantiateType}}%
\nwixlogsorted{i}{{\nwixident{IsComplexNumber}}{IsComplexNumber}}%
\nwixlogsorted{i}{{\nwixident{IsItEmptySet}}{IsItEmptySet}}%
\nwixlogsorted{i}{{\nwixident{IsStrict}}{IsStrict}}%
\nwixlogsorted{i}{{\nwixident{JoinWith}}{JoinWith}}%
\nwixlogsorted{i}{{\nwixident{LocatedAttr}}{LocatedAttr}}%
\nwixlogsorted{i}{{\nwixident{LocatedCluster}}{LocatedCluster}}%
\nwixlogsorted{i}{{\nwixident{LocateTerm}}{LocateTerm}}%
\nwixlogsorted{i}{{\nwixident{LocateTermList}}{LocateTermList}}%
\nwixlogsorted{i}{{\nwixident{NegBas}}{NegBas}}%
\nwixlogsorted{i}{{\nwixident{NilPtr}}{NilPtr}}%
\nwixlogsorted{i}{{\nwixident{One}}{One}}%
\nwixlogsorted{i}{{\nwixident{PosBas}}{PosBas}}%
\nwixlogsorted{i}{{\nwixident{ProcessLinearEquations}}{ProcessLinearEquations}}%
\nwixlogsorted{i}{{\nwixident{ProcessPolynomialValues}}{ProcessPolynomialValues}}%
\nwixlogsorted{i}{{\nwixident{ProcessReductions}}{ProcessReductions}}%
\nwixlogsorted{i}{{\nwixident{ProcessReductionsAN}}{ProcessReductionsAN}}%
\nwixlogsorted{i}{{\nwixident{RatAdd}}{RatAdd}}%
\nwixlogsorted{i}{{\nwixident{RatInv}}{RatInv}}%
\nwixlogsorted{i}{{\nwixident{RatMult}}{RatMult}}%
\nwixlogsorted{i}{{\nwixident{RatOpp}}{RatOpp}}%
\nwixlogsorted{i}{{\nwixident{RatSucc}}{RatSucc}}%
\nwixlogsorted{i}{{\nwixident{RenumEqClasses}}{RenumEqClasses}}%
\nwixlogsorted{i}{{\nwixident{RoundUpSuperCluster}}{RoundUpSuperCluster}}%
\nwixlogsorted{i}{{\nwixident{SetContr}}{SetContr}}%
\nwixlogsorted{i}{{\nwixident{SubsituteSettings}}{SubsituteSettings}}%
\nwixlogsorted{i}{{\nwixident{SubstitutePendingVars}}{SubstitutePendingVars}}%
\nwixlogsorted{i}{{\nwixident{SubstituteVariable}}{SubstituteVariable}}%
\nwixlogsorted{i}{{\nwixident{SubstVar}}{SubstVar}}%
\nwixlogsorted{i}{{\nwixident{ThereAreBound}}{ThereAreBound}}%
\nwixlogsorted{i}{{\nwixident{TrmNbr}}{TrmNbr}}%
\nwixlogsorted{i}{{\nwixident{TrmOvfl}}{TrmOvfl}}%
\nwixlogsorted{i}{{\nwixident{TrmS}}{TrmS}}%
\nwixlogsorted{i}{{\nwixident{UnionEqualsForNonComplex}}{UnionEqualsForNonComplex}}%
\nwixlogsorted{i}{{\nwixident{UnionTrms}}{UnionTrms}}%
\nwixlogsorted{i}{{\nwixident{UnionWith}}{UnionWith}}%
\nwixlogsorted{i}{{\nwixident{ValRec}}{ValRec}}%
\nwixlogsorted{i}{{\nwixident{XXX}}{XXX}}%
\nwixlogsorted{i}{{\nwixident{YAttr}}{YAttr}}%
\nwixlogsorted{i}{{\nwixident{YCluster}}{YCluster}}%
\nwixlogsorted{i}{{\nwixident{YEqClass}}{YEqClass}}%
\nwixlogsorted{i}{{\nwixident{YFormula}}{YFormula}}%
\nwixlogsorted{i}{{\nwixident{YTerm}}{YTerm}}%
\nwixlogsorted{i}{{\nwixident{YTermList}}{YTermList}}%
\nwixlogsorted{i}{{\nwixident{YType}}{YType}}%
\nwixlogsorted{i}{{\nwixident{YYTerm}}{YYTerm}}%

