\nwfilename{src/analyzer.nw}\nwbegindocs{0}% -*- mode: poly-noweb; noweb-code-mode: opascal-mode; -*-% ===> this file was generated automatically by noweave --- better not edit it

\chapter{Analyzer}

Modules (called ``\texttt{unit}''s in Pascal) have two parts: the
public-facing ``\texttt{interface}'' declarations, and the private
``\texttt{implementation}'' code.

\nwenddocs{}\nwbegincode{1}\sublabel{NW4fRSrE-1hWBF8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1hWBF8-1}}}\moddef{kernel/analyzer.pas~{\nwtagstyle{}\subpageref{NW4fRSrE-1hWBF8-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
// The ANALYZER_REPORT ifdefs are left here, even though there is
// no other output. This is because the ifdefs now mark the output
// code precisely, which will be useful when rewriting it for XML.

\{$DEFINE ANALYZER_REPORT\}

unit analyzer;
interface
\LA{}Analyzer interface~{\nwtagstyle{}\subpageref{NW4fRSrE-3aG0Hi-1}}\RA{}
  
implementation
\LA{}Analyzer implementation~{\nwtagstyle{}\subpageref{NW4fRSrE-SJwsI-1}}\RA{}
end;
\nwnotused{kernel/analyzer.pas}\nwendcode{}\nwbegindocs{2}\nwdocspar

The analyzer module has two procedures, {\Tt{}\nwlinkedidentq{Analyze}{NW4fRSrE-1Bkikv-1}\nwendquote} and {\Tt{}\nwlinkedidentq{DisposeAnalyze}{NW4fRSrE-1OBgEQ-1}\nwendquote}.

\nwenddocs{}\nwbegincode{3}\sublabel{NW4fRSrE-3aG0Hi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3aG0Hi-1}}}\moddef{Analyzer interface~{\nwtagstyle{}\subpageref{NW4fRSrE-3aG0Hi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-1hWBF8-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
procedure \nwlinkedidentc{DisposeAnalyze}{NW4fRSrE-1OBgEQ-1};

var  Verifying: boolean = true;

\{$IFDEF FRM2THESIS\}
var inConclusion  : boolean = false;
var inSchemeInfer : boolean = false;
\{$ENDIF\}
\nwused{\\{NW4fRSrE-1hWBF8-1}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{DisposeAnalyze}}{DisposeAnalyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-3aG0Hi-1}\nwindexuse{\nwixident{DisposeAnalyze}}{DisposeAnalyze}{NW4fRSrE-3aG0Hi-1}\nwendcode{}\nwbegindocs{4}\nwdocspar

The implementation imports some common libraries with the {\Tt{}uses\nwendquote}
keyword, declares some types, defines some constants, then defines a
large number of functions.

\nwenddocs{}\nwbegincode{5}\sublabel{NW4fRSrE-SJwsI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-SJwsI-1}}}\moddef{Analyzer implementation~{\nwtagstyle{}\subpageref{NW4fRSrE-SJwsI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-1hWBF8-1}}\nwenddeflinemarkup
\LA{}Import common libraries for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3rQeqV-1}}\RA{}

\LA{}Declare types for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-4Jho5-1}}\RA{}

\{+-------------------------------------------------------------------+\}
\LA{}Define constants for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3qWqPm-1}}\RA{}

\LA{}Declare state variables for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3XFrHZ-1}}\RA{}

\LA{}Analyzer methods~{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}\RA{}
\nwused{\\{NW4fRSrE-1hWBF8-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\nwenddocs{}\nwbegincode{7}\sublabel{NW4fRSrE-3rQeqV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3rQeqV-1}}}\moddef{Import common libraries for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3rQeqV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwenddeflinemarkup
uses lexicon,mconsole,limits,iocorrel,correl,mobjects,generato,identify,
     errhan,inout,mizenv,librenv,builtin,justhan,express,numbers,
     enums,formats,xml_parser,xmldict,xmlpars,mscanner
\{$IFDEF ANALYZER_REPORT\},inlibr,outlibr,inoutmml\{$ENDIF\}
\{$IFDEF SKLTTEST\},comact,edt_han\{$ENDIF\}
\{$IFDEF MDEBUG\},info,outinfo,absinfo\{$ENDIF\};
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\nwenddocs{}\nwbegincode{9}\sublabel{NW4fRSrE-4Jho5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4Jho5-1}}}\moddef{Declare types for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-4Jho5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwenddeflinemarkup
type
   \nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1} = ^\nwlinkedidentc{DefNode}{NW4fRSrE-4Jho5-1};
   \nwlinkedidentc{DefNode}{NW4fRSrE-4Jho5-1} =
      object(MObject)
         nMeansOccurs: char;
         nConstructor: Lexem; \{'R','M','K','V',':'\}
         SkIt,SkId,SkLabId,SkVarNbr: integer;
         DDef: DefPtr;
         nPrefix: RSNENTRY;
         nEssentials: IntSequence;
         nPrimaryList: MCollection;
         constructor
            Init(fMeansOccurs,fKind: char;
                 fLab,fLabId: integer;
                 fDef: DefPtr;
                 fEntry: RSNENTRY);
      end;
\nwindexdefn{\nwixident{DefNodePtr}}{DefNodePtr}{NW4fRSrE-4Jho5-1}\nwindexdefn{\nwixident{DefNode}}{DefNode}{NW4fRSrE-4Jho5-1}\eatline
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwidentdefs{\\{{\nwixident{DefNode}}{DefNode}}\\{{\nwixident{DefNodePtr}}{DefNodePtr}}}\nwendcode{}\nwbegindocs{10}\nwdocspar
The constants defined are mostly error conditions.

\nwenddocs{}\nwbegincode{11}\sublabel{NW4fRSrE-3qWqPm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3qWqPm-1}}}\moddef{Define constants for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3qWqPm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwenddeflinemarkup
const
   errFieldHomonimy = 91;
   errFieldTypeInconsistent = 92;
   errIncompletePrefix = 93;
   errNonStructPrefix = 94;
   CorrCondNbr=6;  // ##TODO: it seems that only 1..5 are used, not 6
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\nwenddocs{}\nwbegincode{13}\sublabel{NW4fRSrE-3XFrHZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3XFrHZ-1}}}\moddef{Declare state variables for analyzer~{\nwtagstyle{}\subpageref{NW4fRSrE-3XFrHZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwenddeflinemarkup
var
   RedefAntonym,gRedef,gSpecified,gPropertiesOcc: boolean;
   ResNbr: integer;
   AnyTyp: TypPtr;
   gProperties:PropertiesRec;
   gStatusOfProperties:integer;
   gDefiniens: DefPtr;
   gDefPos: Position;
   gSuperfluous,dPrimLength,gWhichOne: integer;
   ConstNr: array[1..2*MaxArgNbr] of integer;
   LocusAsConst: array[1..2*MaxArgNbr] of integer;
   gPrimaries: array[1..2*MaxArgNbr] of TypPtr;
   LociOcc: array[1..2*MaxArgNbr] of boolean;
   gNonPermissive: boolean;
   gPrimNbr,
   gBoundInc, \{ o ile inkrementowac zwiazane \}
   gBoundForFirst, gBoundForSecond, gBoundForIt:integer;
   \{ przez jakie zmienne kwantyfikowane, argumenty maja byc zastapione \}
   gCorrCond: array[0..CorrCondNbr] of FrmPtr;
   \{$IFDEF ANALYZER_REPORT\}
   AReport:OutVRFFileObj;
   \{$ENDIF\}   
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\section{Methods}

\nwenddocs{}\nwbegincode{15}\sublabel{NW4fRSrE-24b9uj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}}\moddef{Analyzer methods~{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwprevnextdefs{\relax}{NW4fRSrE-24b9uj-2}\nwenddeflinemarkup
\LA{}Renew primaries~{\nwtagstyle{}\subpageref{NW4fRSrE-3PpPH3-1}}\RA{}
\LA{}Set Loci occurrences~{\nwtagstyle{}\subpageref{NW4fRSrE-c8C2Z-1}}\RA{}
\LA{}Change to constructor~{\nwtagstyle{}\subpageref{NW4fRSrE-1IRHWc-1}}\RA{}
\LA{}Renew Const~{\nwtagstyle{}\subpageref{NW4fRSrE-8NgkM-1}}\RA{}
\LA{}Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-Eqhkd-1}}\RA{}
\LA{}Constructor formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-qSnfu-1}}\RA{}
\LA{}Read a sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-2YZvDi-1}}\RA{}
\LA{}Read type~{\nwtagstyle{}\subpageref{NW4fRSrE-2owkOX-1}}\RA{}
\LA{}Analyze term~{\nwtagstyle{}\subpageref{NW4fRSrE-31Gox1-1}}\RA{}
\LA{}Analyze argument type list~{\nwtagstyle{}\subpageref{NW4fRSrE-WoH1u-1}}\RA{}
\LA{}Read propositions~{\nwtagstyle{}\subpageref{NW4fRSrE-aW1Nc-1}}\RA{}
\LA{}Conjugate a list of propositions~{\nwtagstyle{}\subpageref{NW4fRSrE-2UfBO8-1}}\RA{}
\LA{}Scheme body~{\nwtagstyle{}\subpageref{NW4fRSrE-4O6RPc-1}}\RA{}
\LA{}Open a definition~{\nwtagstyle{}\subpageref{NW4fRSrE-3bvXko-1}}\RA{}
\LA{}Close a definition~{\nwtagstyle{}\subpageref{NW4fRSrE-713M3-1}}\RA{}
\LA{}Change fixed variables to bound variables~{\nwtagstyle{}\subpageref{NW4fRSrE-FAqx7-1}}\RA{}
\LA{}xFormula(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-3ZW69r-1}}\RA{}
\LA{}Get qualified list~{\nwtagstyle{}\subpageref{NW4fRSrE-lPUBf-1}}\RA{}
\LA{}Get constant qualified list~{\nwtagstyle{}\subpageref{NW4fRSrE-4MdvhM-1}}\RA{}
\LA{}Write qualified~{\nwtagstyle{}\subpageref{NW4fRSrE-1GXbPG-1}}\RA{}
\LA{}Append locus~{\nwtagstyle{}\subpageref{NW4fRSrE-2jU5qo-1}}\RA{}
\LA{}Parameter declaration~{\nwtagstyle{}\subpageref{NW4fRSrE-29B9Op-1}}\RA{}
\LA{}Change bound variable and iterate~{\nwtagstyle{}\subpageref{NW4fRSrE-2cKzYF-1}}\RA{}
\LA{}Make list of loci variables~{\nwtagstyle{}\subpageref{NW4fRSrE-1OwTRj-1}}\RA{}
\LA{}Check for compatible arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-4KFoj-1}}\RA{}
\LA{}Correctness conditions~{\nwtagstyle{}\subpageref{NW4fRSrE-26ZHbS-1}}\RA{}
\nwalsodefined{\\{NW4fRSrE-24b9uj-2}\\{NW4fRSrE-24b9uj-3}\\{NW4fRSrE-24b9uj-4}}\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

This is part of cleanup when restoring the state after declaring a
structure type.

\nwenddocs{}\nwbegincode{17}\sublabel{NW4fRSrE-3PpPH3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3PpPH3-1}}}\moddef{Renew primaries~{\nwtagstyle{}\subpageref{NW4fRSrE-3PpPH3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RenewPrimaries}{NW4fRSrE-3PpPH3-1}(fPrevLength:integer);
var
   k : integer;
begin
   for k := fPrevLength + 1 to gPrimNbr do dispose(gPrimaries[k],Done);
   gPrimNbr := fPrevLength;
   dPrimLength := fPrevLength;
end;
\nwindexdefn{\nwixident{RenewPrimaries}}{RenewPrimaries}{NW4fRSrE-3PpPH3-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{RenewPrimaries}}{RenewPrimaries}}}\nwendcode{}\nwbegindocs{18}\nwdocspar
Within a definition, we can set the loci occurrences.

\nwenddocs{}\nwbegincode{19}\sublabel{NW4fRSrE-c8C2Z-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-c8C2Z-1}}}\moddef{Set Loci occurrences~{\nwtagstyle{}\subpageref{NW4fRSrE-c8C2Z-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1}(var fTrm:TrmPtr);
begin
 with VarTrmPtr(fTrm)^ do if TrmSort=ikTrmLocus then LociOcc[VarNr] := true;
end;
\nwindexdefn{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-c8C2Z-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwendcode{}\nwbegindocs{20}\nwdocspar
\nwenddocs{}\nwbegincode{21}\sublabel{NW4fRSrE-1IRHWc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1IRHWc-1}}}\moddef{Change to constructor~{\nwtagstyle{}\subpageref{NW4fRSrE-1IRHWc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeToConst}{NW4fRSrE-1IRHWc-1}(var fTrm : TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do if TrmSort = ikTrmLocus then
   begin
      TrmSort := ikTrmConstant;
      VarNr := gSuperfluous+ConstNr[VarNr]
   end;
end;
\nwindexdefn{\nwixident{ChangeToConst}}{ChangeToConst}{NW4fRSrE-1IRHWc-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ChangeToConst}}{ChangeToConst}}}\nwendcode{}\nwbegindocs{22}\nwdocspar
\nwenddocs{}\nwbegincode{23}\sublabel{NW4fRSrE-8NgkM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-8NgkM-1}}}\moddef{Renew Const~{\nwtagstyle{}\subpageref{NW4fRSrE-8NgkM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RenewConst}{NW4fRSrE-8NgkM-1}(var fTrm : TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      if (TrmSort=ikTrmConstant) and (VarNr > g.VarNbr) then
         VarNr:=g.VarNbr;
end;
\nwindexdefn{\nwixident{RenewConst}}{RenewConst}{NW4fRSrE-8NgkM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{RenewConst}}{RenewConst}}}\nwendcode{}\nwbegindocs{24}\nwdocspar
This appears to produce a list of formal arguments (parameters?) to a
term or type.

\nwenddocs{}\nwbegincode{25}\sublabel{NW4fRSrE-Eqhkd-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-Eqhkd-1}}}\moddef{Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-Eqhkd-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{FormalArgs}{NW4fRSrE-Eqhkd-1}(fNbr:integer):TrmList;
var
   i: integer;
   lTL: TrmList;
begin
   lTL:=nil;
   for i:=fNbr downto 1 do lTL:=NewTrmList(NewVarTrm(ikTrmLocus,i),lTL);
   \nwlinkedidentc{FormalArgs}{NW4fRSrE-Eqhkd-1}:=lTL;
end;
\nwindexdefn{\nwixident{FormalArgs}}{FormalArgs}{NW4fRSrE-Eqhkd-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{FormalArgs}}{FormalArgs}}}\nwendcode{}\nwbegindocs{26}\nwdocspar
\nwenddocs{}\nwbegincode{27}\sublabel{NW4fRSrE-qSnfu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-qSnfu-1}}}\moddef{Constructor formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-qSnfu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{C_FormalArgs}{NW4fRSrE-qSnfu-1}(fNbr : integer) : TrmList;
var
   i: integer;
   lTL: TrmList;
begin
   lTL := nil;
   for i := fNbr downto 1 do lTL := NewTrmList(NewVarTrm(ikTrmConstant,i),lTL);
   \nwlinkedidentc{C_FormalArgs}{NW4fRSrE-qSnfu-1} := lTL;
end;
\nwindexdefn{\nwixident{C{\_}FormalArgs}}{C:unFormalArgs}{NW4fRSrE-qSnfu-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{C{\_}FormalArgs}}{C:unFormalArgs}}}\nwendcode{}\nwbegindocs{28}\nwdocspar
Read in a sentence, produce a pointer to the formula's abstract syntax
tree.

\nwenddocs{}\nwbegincode{29}\sublabel{NW4fRSrE-2YZvDi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2YZvDi-1}}}\moddef{Read a sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-2YZvDi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(Negate: boolean) : FrmPtr;
var
   lSnt : ExpPtr;
   lFrm : FrmPtr;
begin
   BoundVarNbr := 0;
   lSnt := LoadFormula;
   lFrm := lSnt^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   dispose(lSnt,Done);
   if Negate then lFrm := NewNegDis(lFrm);
   \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1} := lFrm;
end;
\nwindexdefn{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-2YZvDi-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ReadSentence}}{ReadSentence}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-2YZvDi-1}\nwendcode{}\nwbegindocs{30}\nwdocspar
Read in a type, and return a pointer to the abstract syntax tree.

\nwenddocs{}\nwbegincode{31}\sublabel{NW4fRSrE-2owkOX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2owkOX-1}}}\moddef{Read type~{\nwtagstyle{}\subpageref{NW4fRSrE-2owkOX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1} : TypPtr;
var
   lExpPtr : ExpPtr;
   lTyp : TypPtr;
begin
   BoundVarNbr  :=  0;
   lExpPtr  :=  LoadType;
   lTyp  :=  lExpPtr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1}  :=  lTyp;
   dispose(lExpPtr,Done);
end;
\nwindexdefn{\nwixident{ReadType}}{ReadType}{NW4fRSrE-2owkOX-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ReadType}}{ReadType}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-2owkOX-1}\nwendcode{}\nwbegindocs{32}\nwdocspar
Analyze an expression pointer as a term pointer.

\nwenddocs{}\nwbegincode{33}\sublabel{NW4fRSrE-31Gox1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-31Gox1-1}}}\moddef{Analyze term~{\nwtagstyle{}\subpageref{NW4fRSrE-31Gox1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{AnalyzeTerm}{NW4fRSrE-31Gox1-1}(aExpr : ExpPtr): TrmPtr;
var
   lTrm,lTrm1: TrmPtr;
begin
   BoundVarNbr := 0;
   lTrm := aExpr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   if lTrm^.TrmSort=ikTrmQua then
   begin
      lTrm1 := CopyTerm(QuaTrmPtr(lTrm)^.TrmProper);
      DisposeTrm(lTrm); lTrm := lTrm1;
   end;
   \nwlinkedidentc{AnalyzeTerm}{NW4fRSrE-31Gox1-1} := lTrm;
end;
\nwindexdefn{\nwixident{AnalyzeTerm}}{AnalyzeTerm}{NW4fRSrE-31Gox1-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{AnalyzeTerm}}{AnalyzeTerm}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-31Gox1-1}\nwendcode{}\nwbegindocs{34}\nwdocspar
\nwenddocs{}\nwbegincode{35}\sublabel{NW4fRSrE-3YycCO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3YycCO-1}}}\moddef{Read a term~{\nwtagstyle{}\subpageref{NW4fRSrE-3YycCO-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1} : TrmPtr;
var
   lTrm,lTrm1: TrmPtr;
   lExpPtr: ExpPtr;
begin
   BoundVarNbr := 0;
   lExpPtr := LoadTerm;
   lTrm := lExpPtr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   dispose(lExpPtr,Done);
   if lTrm^.TrmSort = ikTrmQua then
   begin
      lTrm1 := CopyTerm(QuaTrmPtr(lTrm)^.TrmProper);
      DisposeTrm(lTrm);
      lTrm := lTrm1;
   end;
   \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1} := lTrm;
end;
\nwindexdefn{\nwixident{ReadTerm}}{ReadTerm}{NW4fRSrE-3YycCO-1}\eatline
\nwnotused{Read a term}\nwidentdefs{\\{{\nwixident{ReadTerm}}{ReadTerm}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-3YycCO-1}\nwendcode{}\nwbegindocs{36}\nwdocspar
\nwenddocs{}\nwbegincode{37}\sublabel{NW4fRSrE-WoH1u-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-WoH1u-1}}}\moddef{Analyze argument type list~{\nwtagstyle{}\subpageref{NW4fRSrE-WoH1u-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
var \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1}: integer = MaxArgNbr;
// 'gMaxArgNbr' is changed in the 'REgistration' procedure to '2*MaxArgNbr'
// for an identify registration only.
// In an identify registration two pattern are occuring.
// Two pattern can have 'MaxArgNbr' arguments each one.
// Still the number of locus must be '2*MaxArgNbr' in parameters list as
// a maximal number of locus. The 'MaxArgNbr' locuses for one of the two patterns.
// The 'MaxArgNbr' is a limit for number of arguments in any pattern.

procedure \nwlinkedidentc{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}(var fTypList : MList);
var
   n,z: integer;
   lColl: MCollection;
   lExpPtr:ExpPtr;
begin
   n := 0;
   lColl.Init(2,2);
   inFile.InWord;
   while InFile.Current.Kind <> ';' do
   begin
      lExpPtr := LoadType;
      lColl.Insert(lExpPtr);
      InFile.InWord;
   end;
   fTypList.Init(lColl.Count);
   with lColl do
      for z := 0 to Count-1 do
      begin
         if n >= \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then OverflowError(937);
         inc(n);
         BoundVarNbr := 0;
         LocArgTyp[n] := ExpPtr(Items^[z])^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
         fTypList.Insert(LocArgTyp[n]);
      end;
   lColl.Done;
end;
\nwindexdefn{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}\nwindexdefn{\nwixident{gMaxArgNbr}}{gMaxArgNbr}{NW4fRSrE-WoH1u-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}}\\{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-WoH1u-1}\nwendcode{}\nwbegindocs{38}\nwdocspar
\nwenddocs{}\nwbegincode{39}\sublabel{NW4fRSrE-aW1Nc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-aW1Nc-1}}}\moddef{Read propositions~{\nwtagstyle{}\subpageref{NW4fRSrE-aW1Nc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(var fConditions : MCollection);
var
   lFrm: FrmPtr;
   lLabNr,lLabId: integer;
   lPos: Position;
begin
   fConditions.Init(2,4);
   while InFile.Current.Kind <> ';' do
   begin
      lLabNr := InFile.Current.Nr;
      InFile.InInt(lLabId);
      InFile.InPos(lPos);
      InFile.InWord;
      lFrm := \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(false);
      fConditions.Insert(new(PropositionPtr,Init(lLabNr,lLabId,lFrm,lPos)));
      InFile.InWord;
   end;
end;
\nwindexdefn{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-aW1Nc-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ReadPropositions}}{ReadPropositions}}}\nwidentuses{\\{{\nwixident{ReadSentence}}{ReadSentence}}}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-aW1Nc-1}\nwendcode{}\nwbegindocs{40}\nwdocspar
\nwenddocs{}\nwbegincode{41}\sublabel{NW4fRSrE-2UfBO8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2UfBO8-1}}}\moddef{Conjugate a list of propositions~{\nwtagstyle{}\subpageref{NW4fRSrE-2UfBO8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(const fConditions : MCollection) : FrmPtr;
var
   lFrm:FrmPtr;
   z: integer;
begin
   lFrm := NewVerum;
   with fConditions do
      for z := 0 to Count-1 do
         lFrm := NewConj(lFrm,PropositionPtr(Items^[z])^.nSentence^.CopyFormula);
   \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1} := lFrm;
end;
\nwindexdefn{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}}\nwendcode{}\nwbegindocs{42}\nwdocspar
\nwenddocs{}\nwbegincode{43}\sublabel{NW4fRSrE-4O6RPc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4O6RPc-1}}}\moddef{Scheme body~{\nwtagstyle{}\subpageref{NW4fRSrE-4O6RPc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
var \nwlinkedidentc{gSchemeThesis}{NW4fRSrE-4O6RPc-1}: FrmPtr;

var \nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1},\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}: integer;
procedure \nwlinkedidentc{SchemeBody}{NW4fRSrE-4O6RPc-1};
var
   lSchVarNbr,k,j,lSchId: integer;
   lTypList: MCollection;
   lTyp: TypPtr;
   lConditions: MCollection;
begin
   InFile.InWord;
   InFile.InInt(lSchId);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elSchemeBlock);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XIntAttr(atSchemeNr, InFile.Current.Nr);
   AReport.Out_XIntAttr(atVid, lSchId);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   InFile.InPos(CurPos);
   InFile.InWord;
   \nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1} := 0;
   \nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1} := 0;
   CurSchFuncTyp.Init(MaxFuncVarNbr,0);
   while InFile.Current.Kind<>';' do
      case InFile.Current.Kind of
         ikTrmSchFunc:
            \LA{}Handle term scheme functor~{\nwtagstyle{}\subpageref{NW4fRSrE-1uiOLv-1}}\RA{}
         ikFrmSchPred:
            \LA{}Handle formula scheme predicate~{\nwtagstyle{}\subpageref{NW4fRSrE-4T3rLo-1}}\RA{}
      else
      begin
         \{$IFDEF MDEBUG\}
         writeln(infofile,'InFile.Current.Kind=',InFile.Current.Kind);
         \{$ENDIF\}
         RunTimeError(2064);
      end;
      end;
   CurSchFuncTyp.SetLimit(0);
   InFile.InWord;
   \nwlinkedidentc{gSchemeThesis}{NW4fRSrE-4O6RPc-1} := \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(false);
   InFile.InWord;
   \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart0(elSchemePremises);
   AReport.Out_Propositions(lConditions);
   AReport.Out_XElEnd(elSchemePremises);
   \{$ENDIF\}
   lConditions.Done;
end;
\nwindexdefn{\nwixident{SchemeBody}}{SchemeBody}{NW4fRSrE-4O6RPc-1}\nwindexdefn{\nwixident{gSchemeThesis}}{gSchemeThesis}{NW4fRSrE-4O6RPc-1}\nwindexdefn{\nwixident{gSchPredNbr}}{gSchPredNbr}{NW4fRSrE-4O6RPc-1}\nwindexdefn{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}}\\{{\nwixident{gSchemeThesis}}{gSchemeThesis}}\\{{\nwixident{gSchPredNbr}}{gSchPredNbr}}\\{{\nwixident{SchemeBody}}{SchemeBody}}}\nwidentuses{\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{ReadSentence}}{ReadSentence}}}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-4O6RPc-1}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-4O6RPc-1}\nwendcode{}\nwbegindocs{44}\nwdocspar
\nwenddocs{}\nwbegincode{45}\sublabel{NW4fRSrE-1uiOLv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1uiOLv-1}}}\moddef{Handle term scheme functor~{\nwtagstyle{}\subpageref{NW4fRSrE-1uiOLv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-4O6RPc-1}}\nwenddeflinemarkup
begin
   lSchVarNbr := 0;
   while InFile.Current.Kind<>';' do
   begin
      inc(lSchVarNbr);
      SchFuncArity[\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+lSchVarNbr].nId := InFile.Current.Nr;
      InFile.InWord;
   end;
   Mizassert(2616,\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+lSchVarNbr <= MaxFuncVarNbr);
   \nwlinkedidentc{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}(lTypList);
   InFile.InWord; lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
   for k := 1 to lSchVarNbr do
   begin
      \{ azeby umozliwic dysponowanie, trzeba cala kolekcje skopiowac \}
      with SchFuncArity[\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+k] do
      begin
         SchFuncArity[\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+k].nArity.Init(lTypList.Count);
         for j := 0 to lTypList.Count-1 do
            SchFuncArity[\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+k].nArity.
               Insert(TypPtr(lTypList.Items^[j])^.CopyType);
      end;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elSchemeFuncDecl);
      AReport.Out_XIntAttr(atNr, \nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+k);
      AReport.Out_XIntAttr(atVid, SchFuncArity[\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1}+k].nId);
      AReport.Out_XAttrEnd;
      AReport.Out_ArgTypes(lTypList);
      AReport.Out_Type(lTyp);
      AReport.Out_XElEnd(elSchemeFuncDecl);
      \{$ENDIF\}
      CurSchFuncTyp.Insert(lTyp^.CopyType);
   end;
   lTypList.Done;
   dispose(lTyp,Done);
   inc(\nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1},lSchVarNbr);
   Infile.InWord;
end;
\nwused{\\{NW4fRSrE-4O6RPc-1}}\nwidentuses{\\{{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}}\\{{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}{NW4fRSrE-1uiOLv-1}\nwindexuse{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}{NW4fRSrE-1uiOLv-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-1uiOLv-1}\nwendcode{}\nwbegindocs{46}\nwdocspar

\nwenddocs{}\nwbegincode{47}\sublabel{NW4fRSrE-4T3rLo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4T3rLo-1}}}\moddef{Handle formula scheme predicate~{\nwtagstyle{}\subpageref{NW4fRSrE-4T3rLo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-4O6RPc-1}}\nwenddeflinemarkup
begin
   lSchVarNbr := 0;
   while InFile.Current.Kind<>';' do
   begin
      inc(lSchVarNbr);
      SchPredArity[\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+lSchVarNbr].nId := InFile.Current.Nr;
      InFile.InWord;
   end;
   Mizassert(2517,\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+lSchVarNbr <= MaxPredVarNbr);
   \nwlinkedidentc{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}(lTypList);
   for k := 1 to lSchVarNbr do
      with SchPredArity[\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+k] do
   begin
                  \{$IFDEF ANALYZER_REPORT\}
                  AReport.Out_XElStart(elSchemePredDecl);
                  AReport.Out_XIntAttr(atNr, \nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+k);
                  AReport.Out_XIntAttr(atVid, SchPredArity[\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+k].nId);
                  AReport.Out_XAttrEnd;
                  AReport.Out_ArgTypes(lTypList);
                  AReport.Out_XElEnd(elSchemePredDecl);
                  \{$ENDIF\}
                  nArity.Init(lTypList.Count);
                  for j := 0 to lTypList.Count-1 do
                     SchPredArity[\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1}+k].nArity.
                        Insert(TypPtr(lTypList.Items^[j])^.CopyType);
               end;
               lTypList.Done;
               inc(\nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1},lSchVarNbr);
               InFile.InWord;
            end;
\nwused{\\{NW4fRSrE-4O6RPc-1}}\nwidentuses{\\{{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}}\\{{\nwixident{gSchPredNbr}}{gSchPredNbr}}}\nwindexuse{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}{NW4fRSrE-4T3rLo-1}\nwindexuse{\nwixident{gSchPredNbr}}{gSchPredNbr}{NW4fRSrE-4T3rLo-1}\nwendcode{}\nwbegindocs{48}\nwdocspar

\nwenddocs{}\nwbegincode{49}\sublabel{NW4fRSrE-3bvXko-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3bvXko-1}}}\moddef{Open a definition~{\nwtagstyle{}\subpageref{NW4fRSrE-3bvXko-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
var \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}: LevelRec;

procedure \nwlinkedidentc{OpenDef}{NW4fRSrE-3bvXko-1};
begin
   InFile.InWord;
   gNonPermissive := true;
   gPrimNbr := 0;
   dPrimLength := 0;
   gDefBase := g.VarNbr;
end;
\nwindexdefn{\nwixident{OpenDef}}{OpenDef}{NW4fRSrE-3bvXko-1}\nwindexdefn{\nwixident{D}}{D}{NW4fRSrE-3bvXko-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{D}}{D}}\\{{\nwixident{OpenDef}}{OpenDef}}}\nwendcode{}\nwbegindocs{50}\nwdocspar
\nwenddocs{}\nwbegincode{51}\sublabel{NW4fRSrE-713M3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-713M3-1}}}\moddef{Close a definition~{\nwtagstyle{}\subpageref{NW4fRSrE-713M3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{CloseDef}{NW4fRSrE-713M3-1};
var
   k: integer;
   nk: NotationKind;
begin
   for nk := Low(NotationKind) to High(NotationKind) do
      with Notat[nk] do
   begin
      \{$IFDEF ANALYZER_REPORT\}
      for k :=  Count to Count + fExtCount - 1 do
      begin
         if (nk = noMode) and (PatternPtr(Items^[k])^.Expansion <> nil) then
         begin
            PatternPtr(Items^[k])^.Expansion^.LowerCluster^.ClearPids;
            PatternPtr(Items^[k])^.Expansion^.UpperCluster^.ClearPids;
         end;
      end;
      \{$ENDIF\}
      Notat[nk].AddExtItems;
   end;
   gPrimNbr := 0;
   dPrimLength := 0;
   for k := 1 to gPrimNbr do
      dispose(gPrimaries[k],Done);
   RegisteredCluster.AddExtItems;
   ConditionalCluster.AddExtItems;
   FunctorCluster.AddExtItems;
end;
\nwindexdefn{\nwixident{CloseDef}}{CloseDef}{NW4fRSrE-713M3-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{CloseDef}}{CloseDef}}}\nwendcode{}\nwbegindocs{52}\nwdocspar
\nwenddocs{}\nwbegincode{53}\sublabel{NW4fRSrE-FAqx7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-FAqx7-1}}}\moddef{Change fixed variables to bound variables~{\nwtagstyle{}\subpageref{NW4fRSrE-FAqx7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
var \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}: integer;

procedure \nwlinkedidentc{ChangeFixedToBound}{NW4fRSrE-FAqx7-1}(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmBound:
            inc(VarNr, g.VarNbr - \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1});
         ikTrmConstant:
            if VarNr > \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} then
            begin
               TrmSort := ikTrmBound;
               dec(VarNr, \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1})
            end;
      end;
end;
\nwindexdefn{\nwixident{ChangeFixedToBound}}{ChangeFixedToBound}{NW4fRSrE-FAqx7-1}\nwindexdefn{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-FAqx7-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ChangeFixedToBound}}{ChangeFixedToBound}}\\{{\nwixident{gFixedBase}}{gFixedBase}}}\nwendcode{}\nwbegindocs{54}\nwdocspar
The {\Tt{}\nwlinkedidentq{xFormula}{NW4fRSrE-3ZW69r-1}\nwendquote} function appears to transform a formula into ``Mizar
normal form'' as a semantic correlate.

The {\Tt{}NewNegDis\nwendquote} is a method defined in the semantic correlate library,
which negates constructs a new formula and {\Tt{}dispose\nwendquote} the argument
passed to it.

\nwenddocs{}\nwbegincode{55}\sublabel{NW4fRSrE-3ZW69r-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3ZW69r-1}}}\moddef{xFormula(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-3ZW69r-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1}(fForm: FrmPtr): FrmPtr;
var
   lTyp: TypPtr;
   kk: integer;
begin
   fForm := NewNegDis(fForm);
   for kk := g.VarNbr downto \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} + 1 do
   begin
      lTyp := FixedVar[kk].nTyp;
      if lTyp^.TypSort=ikError then
      begin
         \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1} := NewInCorFrm;
         exit;
      end;
      fForm := NewUnivI(FixedVar[kk].nIdent, lTyp^.CopyType, fForm);
   end;
   WithInFormula(fForm, \nwlinkedidentc{ChangeFixedToBound}{NW4fRSrE-FAqx7-1});
   \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1} := NewNegDis(fForm);
end;
\nwindexdefn{\nwixident{xFormula}}{xFormula}{NW4fRSrE-3ZW69r-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{xFormula}}{xFormula}}}\nwidentuses{\\{{\nwixident{ChangeFixedToBound}}{ChangeFixedToBound}}\\{{\nwixident{gFixedBase}}{gFixedBase}}}\nwindexuse{\nwixident{ChangeFixedToBound}}{ChangeFixedToBound}{NW4fRSrE-3ZW69r-1}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-3ZW69r-1}\nwendcode{}\nwbegindocs{56}\nwdocspar
\nwenddocs{}\nwbegincode{57}\sublabel{NW4fRSrE-lPUBf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-lPUBf-1}}}\moddef{Get qualified list~{\nwtagstyle{}\subpageref{NW4fRSrE-lPUBf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
var
   lNbr,i: integer;
   lTyp: TypPtr;
begin
   \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} := g.VarNbr;
   InFile.InWord;
   while InFile.Current.Kind = 'Q' do
   begin
      lNbr := g.VarNbr;
      inc(g.VarNbr,InFile.Current.Nr);
      for i := 1 to InFile.Current.Nr do
      begin
         InFile.InWord; // 'I'
         FixedVar[lNbr+i].nIdent := InFile.Current.Nr;
      end;
      lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      for i := lNbr + 1 to g.VarNbr do
      begin
         FixedVar[i].nSkelConstNr := 0;
         if i = g.VarNbr then
            FixedVar[i].nTyp := lTyp
         else
            FixedVar[i].nTyp := lTyp^.CopyType;
         FixedVar[i].nExp := false;
      end;
      // dispose(lTyp,Done);
      InFile.InWord;
   end;
end;
\nwindexdefn{\nwixident{GetQualifiedList}}{GetQualifiedList}{NW4fRSrE-lPUBf-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{GetQualifiedList}}{GetQualifiedList}}}\nwidentuses{\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-lPUBf-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-lPUBf-1}\nwendcode{}\nwbegindocs{58}\nwdocspar
\nwenddocs{}\nwbegincode{59}\sublabel{NW4fRSrE-4MdvhM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4MdvhM-1}}}\moddef{Get constant qualified list~{\nwtagstyle{}\subpageref{NW4fRSrE-4MdvhM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{GetConstQualifiedList}{NW4fRSrE-4MdvhM-1};
var
   lNbr,i: integer;
   lTyp: TypPtr;
begin
   \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} := g.VarNbr;
   InFile.InWord;
   while InFile.Current.Kind = 'Q' do
   begin
      lNbr := g.VarNbr;
      inc(g.VarNbr,InFile.Current.Nr);
      for i := 1 to InFile.Current.Nr do
      begin InFile.InWord; // 'I'
      FixedVar[lNbr + i].nIdent := InFile.Current.Nr;
      end;
      lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      for i := lNbr + 1 to g.VarNbr do
      begin
         FixedVar[i].nSkelConstNr := -1;
         if i=g.VarNbr then
            FixedVar[i].nTyp := lTyp
         else FixedVar[i].nTyp := lTyp^.CopyType;
         FixedVar[i].nExp := false;
      end;
      //   dispose(lTyp,Done);
      InFile.InWord;
   end;
end;
\nwindexdefn{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}{NW4fRSrE-4MdvhM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}}}\nwidentuses{\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-4MdvhM-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-4MdvhM-1}\nwendcode{}\nwbegindocs{60}\nwdocspar
\nwenddocs{}\nwbegincode{61}\sublabel{NW4fRSrE-1GXbPG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1GXbPG-1}}}\moddef{Write qualified~{\nwtagstyle{}\subpageref{NW4fRSrE-1GXbPG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
var
   i: integer;
begin
   \{$IFDEF ANALYZER_REPORT\}
   for i := \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}+1 to g.VarNbr do
      AReport.Out_TypeWithId(FixedVar[i].nTyp,FixedVar[i].nIdent);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-1GXbPG-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{WriteQualified}}{WriteQualified}}}\nwidentuses{\\{{\nwixident{gFixedBase}}{gFixedBase}}}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-1GXbPG-1}\nwendcode{}\nwbegindocs{62}\nwdocspar
\nwenddocs{}\nwbegincode{63}\sublabel{NW4fRSrE-2jU5qo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2jU5qo-1}}}\moddef{Append locus~{\nwtagstyle{}\subpageref{NW4fRSrE-2jU5qo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AppendLocus}{NW4fRSrE-2jU5qo-1}(fTyp: TypPtr);
begin
   inc(g.VarNbr);
   \{ brak kotroli OverFlow !!!!!!!!!!!!!! \}
   FixedVar[g.VarNbr].nIdent := 0;
   FixedVar[g.VarNbr].nTyp := fTyp;
   FixedVar[g.VarNbr].nExp := false;
   if dPrimLength >= \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then OverflowError(937);
   inc(dPrimLength);
   if gPrimNbr >= \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then OverflowError(937);
   inc(gPrimNbr);
   inc(g.GenCount);
   FixedVar[g.VarNbr].nSkelConstNr := g.GenCount;
   LocusAsConst[g.GenCount] := g.VarNbr;
   ConstNr[gPrimNbr] := g.VarNbr;
   gPrimaries[gPrimNbr] := AdjustedType(fTyp);
   gPrimaries[gPrimNbr]^.WithinType(ChangeToLoci)
end;
\nwindexdefn{\nwixident{AppendLocus}}{AppendLocus}{NW4fRSrE-2jU5qo-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{AppendLocus}}{AppendLocus}}}\nwidentuses{\\{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}}\nwindexuse{\nwixident{gMaxArgNbr}}{gMaxArgNbr}{NW4fRSrE-2jU5qo-1}\nwendcode{}\nwbegindocs{64}\nwdocspar
\nwenddocs{}\nwbegincode{65}\sublabel{NW4fRSrE-29B9Op-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-29B9Op-1}}}\moddef{Parameter declaration~{\nwtagstyle{}\subpageref{NW4fRSrE-29B9Op-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ParamDecl}{NW4fRSrE-29B9Op-1}(fVarBase: integer);
var
   i: integer;
begin
   dPrimLength := g.GenCount + g.VarNbr - fVarBase;
   if dPrimLength>\nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then OverflowError(479);
   for i := fVarBase + 1 to g.VarNbr do
   begin
      if gPrimNbr >= \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then OverflowError(937);
      inc(gPrimNbr);
      inc(g.GenCount);
      FixedVar[i].nSkelConstNr := g.GenCount;
      LocusAsConst[g.GenCount] := i;
      ConstNr[gPrimNbr] := i;
      gPrimaries[gPrimNbr] := AdjustedType(FixedVar[i].nTyp);
      gPrimaries[gPrimNbr]^.WithinType(ChangeToLoci);
   end;
end;
\nwindexdefn{\nwixident{ParamDecl}}{ParamDecl}{NW4fRSrE-29B9Op-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ParamDecl}}{ParamDecl}}}\nwidentuses{\\{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}}\nwindexuse{\nwixident{gMaxArgNbr}}{gMaxArgNbr}{NW4fRSrE-29B9Op-1}\nwendcode{}\nwbegindocs{66}\nwdocspar
\nwenddocs{}\nwbegincode{67}\sublabel{NW4fRSrE-2cKzYF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2cKzYF-1}}}\moddef{Change bound variable and iterate~{\nwtagstyle{}\subpageref{NW4fRSrE-2cKzYF-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeBoundAndIt}{NW4fRSrE-2cKzYF-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmIt:
            begin
               lTrm := fTrm;
               fTrm := NewVarTrm(ikTrmBound,1);
               dispose(lTrm,Done);
            end;
         ikTrmBound: inc(VarNr);
      end;
end;
\nwindexdefn{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}{NW4fRSrE-2cKzYF-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}}}\nwendcode{}\nwbegindocs{68}\nwdocspar
\nwenddocs{}\nwbegincode{69}\sublabel{NW4fRSrE-1OwTRj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1OwTRj-1}}}\moddef{Make list of loci variables~{\nwtagstyle{}\subpageref{NW4fRSrE-1OwTRj-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
function \nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(fLength: integer): TrmList;
var
   lTrmList: TrmList;
   k: integer;
begin
   lTrmList := nil;
   for k := fLength downto gSuperfluous+1 do
      lTrmList := NewTrmList(NewVarTrm(ikTrmConstant,LocusAsConst[k]),lTrmList);
   \nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1} := lTrmList;
end;
\nwindexdefn{\nwixident{LociList}}{LociList}{NW4fRSrE-1OwTRj-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{LociList}}{LociList}}}\nwendcode{}\nwbegindocs{70}\nwdocspar
\nwenddocs{}\nwbegincode{71}\sublabel{NW4fRSrE-4KFoj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4KFoj-1}}}\moddef{Check for compatible arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-4KFoj-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
\{ ComaptibleArgs, ktore tak naprawde sa identyfikacja oryginalu, sa
  dobrym miejscem, zeby skonstruowac liste argumentow definiendum.
\}
\{ Google translate:
  ComaptibleArgs, which are actually the identification of the original,
  are a good place to construct the definiendum argument list. \}

var \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}: TrmList;
    \nwlinkedidentc{gDefArgsError}{NW4fRSrE-4KFoj-1}: boolean;

function \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(L: integer): boolean;
var
   i,S: integer;
   procedure CompError(fErrNr:integer);
   begin
      ErrImm(fErrNr);
      S := 0;
      \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1} := false;
      \nwlinkedidentc{gDefArgsError}{NW4fRSrE-4KFoj-1} := true;
   end;
begin
   S := dPrimLength-L;
   \nwlinkedidentc{gDefArgsError}{NW4fRSrE-4KFoj-1} := false;
   if S < 0 then begin CompError(107); exit end;
   for i := 1 to L do
      with VarTrmPtr(gSubstTrm[i])^ do
         if (TrmSort=ikTrmConstant) and(FixedVar[VarNr].nSkelConstNr<>0) then
         begin
            if FixedVar[VarNr].nSkelConstNr<>S+i then begin CompError(109); exit end
         end
         else begin CompError(108); exit end;
   \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1} := true;
   \{-----\}
   \{- \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil; -\}
   for i := L downto 1 do
      \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := NewTrmList(CopyTerm(gSubstTrm[i]),\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1});
end;
\nwindexdefn{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-4KFoj-1}\nwindexdefn{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}\nwindexdefn{\nwixident{gDefArgsError}}{gDefArgsError}{NW4fRSrE-4KFoj-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-1}}\nwidentdefs{\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{gDefArgsError}}{gDefArgsError}}\\{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}}\nwendcode{}\nwbegindocs{72}\nwdocspar
\nwenddocs{}\nwbegincode{73}\sublabel{NW4fRSrE-3w2GDr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3w2GDr-1}}}\moddef{Write definiens label~{\nwtagstyle{}\subpageref{NW4fRSrE-3w2GDr-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
var
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}:
      record
         MeansOccurs: char;
         Specified,Positive: boolean;
         Pos1,Pos2: Position;
         Kind: char;
         LabNr,LabId,Length: integer;
         fPrimaries: MCollection;
         \{ Poniewaz nie wiadomo, czy bedzie nowy konstruktor,
           trzeba je na razie tutaj uzbierac.
         \}
         \{ Google translate:
           Since it is not known whether there will be a new constructor,
           they need to be collected here for now. \}
      end;
   \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1}: boolean;

\{$IFDEF ANALYZER_REPORT\}
procedure \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
begin
   if \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs<>' ' then
   begin
      AReport.Out_XIntAttr(atNr, \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabNr);
      AReport.Out_XIntAttr(atVid, \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabId);
      AReport.Out_PosAsAttrs(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Pos2);
   end;
end;
\{$ENDIF\}
\nwindexdefn{\nwixident{WriteDefiniensLabel}}{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1}\nwindexdefn{\nwixident{gConstErr}}{gConstErr}{NW4fRSrE-3w2GDr-1}\nwindexdefn{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-3w2GDr-1}\eatline
\nwnotused{Write definiens label}\nwidentdefs{\\{{\nwixident{gConstErr}}{gConstErr}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{WriteDefiniensLabel}}{WriteDefiniensLabel}}}\nwendcode{}\nwbegindocs{74}\nwdocspar
\section{Correctness Conditions}

Definitions have associated correctness conditions (except for
attributes and predicates). These are analyzed in these functions.

\nwenddocs{}\nwbegincode{75}\sublabel{NW4fRSrE-26ZHbS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-26ZHbS-1}}}\moddef{Correctness conditions~{\nwtagstyle{}\subpageref{NW4fRSrE-26ZHbS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-1}}\nwenddeflinemarkup
\LA{}Coherence~{\nwtagstyle{}\subpageref{NW4fRSrE-1tzT4S-1}}\RA{}
\LA{}Compatibility~{\nwtagstyle{}\subpageref{NW4fRSrE-sLbTR-1}}\RA{}
\LA{}Consistency~{\nwtagstyle{}\subpageref{NW4fRSrE-40T82k-1}}\RA{}
\LA{}Existence~{\nwtagstyle{}\subpageref{NW4fRSrE-4TUJX-1}}\RA{}
\LA{}Parse coherence in equals definition~{\nwtagstyle{}\subpageref{NW4fRSrE-3pxze-1}}\RA{}
\LA{}Change bound variables and iterate (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-1XvsOm-1}}\RA{}
\LA{}Copy formula with fresh bound variables~{\nwtagstyle{}\subpageref{NW4fRSrE-1DN1eC-1}}\RA{}
\LA{}Change bound variables and iterate (two)~{\nwtagstyle{}\subpageref{NW4fRSrE-1k6dgM-1}}\RA{}
\LA{}Partial uniqueness condition~{\nwtagstyle{}\subpageref{NW4fRSrE-1ZhYjH-1}}\RA{}
\LA{}Parse uniqueness condition~{\nwtagstyle{}\subpageref{NW4fRSrE-3FE2SD-1}}\RA{}

\nwused{\\{NW4fRSrE-24b9uj-1}}\nwendcode{}\nwbegindocs{76}\nwdocspar

\nwenddocs{}\nwbegincode{77}\sublabel{NW4fRSrE-1tzT4S-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1tzT4S-1}}}\moddef{Coherence~{\nwtagstyle{}\subpageref{NW4fRSrE-1tzT4S-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{Coherence}{NW4fRSrE-1tzT4S-1}(ff: char): FrmPtr;
var
   OldType: TypPtr;
   Sample: TrmPtr;
   cFrm: FrmPtr;
   lArgs: TrmList;
begin
   case ff of
      'M':
         with Notat[noMode] do
         begin
            lArgs := \nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(PatternPtr(Items^[Count+fExtCount-1])^.fPrimTypes.Count);
            with  ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^ do
               OldType := 
               NewStandardTyp(ikTypMode,NewEmptyCluster,
                              InstCluster(fConstrTyp^.UpperCluster,lArgs),
                              gWhichOne,lArgs);
            Sample := NewVarTrm(ikTrmBound,1);
            cFrm := NewUniv(OldType,NewQualFrm(Sample,ItTyp^.CopyType));
         end;
      'K':
         with Notat[noFunctor] do
         begin
            lArgs := \nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(PatternPtr(Items^[Count+fExtCount-1])^.fPrimTypes.Count);
            Sample := NewFuncTrm(gWhichOne,lArgs);
            cFrm := NewQualFrm(Sample,ItTyp^.CopyType);
         end;
      else
         RunTimeError(2005);
   end;
   \nwlinkedidentc{Coherence}{NW4fRSrE-1tzT4S-1} := cFrm;
end;
\nwindexdefn{\nwixident{Coherence}}{Coherence}{NW4fRSrE-1tzT4S-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{Coherence}}{Coherence}}}\nwidentuses{\\{{\nwixident{LociList}}{LociList}}}\nwindexuse{\nwixident{LociList}}{LociList}{NW4fRSrE-1tzT4S-1}\nwendcode{}\nwbegindocs{78}\nwdocspar
\nwenddocs{}\nwbegincode{79}\sublabel{NW4fRSrE-sLbTR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-sLbTR-1}}}\moddef{Compatibility~{\nwtagstyle{}\subpageref{NW4fRSrE-sLbTR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{Compatibility}{NW4fRSrE-sLbTR-1}(ff: char): FrmPtr;
var
   lDefiniendum: FrmPtr;
   function PartBiCond(fFrm: FrmPtr): FrmPtr;
   begin
      PartBiCond := NewBiCond(lDefiniendum^.CopyFormula,fFrm^.CopyFormula)
   end;
var
   z: integer;
   lOth,cFrm,lFrm: FrmPtr;
begin
   if (gDefiniens = nil) or \nwlinkedidentc{gDefArgsError}{NW4fRSrE-4KFoj-1} or (gWhichOne=0) then
   begin
      \nwlinkedidentc{Compatibility}{NW4fRSrE-sLbTR-1} := NewInCorFrm;
      exit;
   end;
   case ff of
      'M':
         lDefiniendum := 
         NewQualFrm(NewItTrm,
                    NewStandardTyp(ikTypMode,NewEmptyCluster,
                                   InstCluster(ItTyp^.UpperCluster,\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}),
                                   gWhichOne,\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}));
      'K':
         with ConstrTypPtr(Constr[coFunctor].Items^[gWhichOne])^.nPrimaries do
         lDefiniendum := NewEqFrm(NewItTrm,NewFuncTrm(gWhichOne,ReNewArgs(Count,\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1})));
      'R': lDefiniendum := NewPredFrm(ikFrmPred,gWhichOne,\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1},0);
      'V':
         with ConstrTypPtr(Constr[ coAttribute].Items^[gWhichOne])^.nPrimaries do
         lDefiniendum := NewPredFrm(ikFrmAttr,gWhichOne,ReNewArgs(Count,\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}),0);
      else
      begin
         \{$IFDEF MDEBUG\}
         writeln(InfoFile,ff,'|');
         \{$ENDIF\}
         RunTimeError(2006);
      end;
   end;
   \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   with gDefiniens^ do
   begin
      if nOtherwise <> nil then lOth := NewVerum;
      cFrm := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do 
            with PartDefPtr(Items^[z])^ do
         begin
            if gDefiniens^.nOtherwise <> nil then
               lOth := NewConj(lOth,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
            case DefSort of
               'm': lFrm := FrmPtr(nPartDefiniens);
               'e': lFrm := NewEqFrm(NewItTrm,TrmPtr(nPartDefiniens));
               else RunTimeError(2503);
            end;
            cFrm := NewConj(cFrm,NewImpl(FrmPtr(nGuard)^.CopyFormula,PartBiCond(lFrm)));
         end;
      if nOtherwise <> nil then
      begin
         case DefSort of
            'm': lFrm := FrmPtr(nOtherwise);
            'e': lFrm := NewEqFrm(NewItTrm,TrmPtr(nOtherwise));
            else RunTimeError(2504);
         end;
         cFrm := NewConj(cFrm,NewImpl(lOth,PartBiCond(lFrm)));
      end
   end;
   if ff in ['K','M'] then
   begin
      WithInFormula(cFrm,\nwlinkedidentc{ChangeBoundAndIt}{NW4fRSrE-2cKzYF-1});
      cFrm := NewUniv(ItTyp^.CopyType,cFrm);
   end;
   dispose(lDefiniendum,Done);
   \nwlinkedidentc{Compatibility}{NW4fRSrE-sLbTR-1} := cFrm;
end;
\nwindexdefn{\nwixident{Compatibility}}{Compatibility}{NW4fRSrE-sLbTR-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{Compatibility}}{Compatibility}}}\nwidentuses{\\{{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}}\\{{\nwixident{gDefArgsError}}{gDefArgsError}}\\{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}}\nwindexuse{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}{NW4fRSrE-sLbTR-1}\nwindexuse{\nwixident{gDefArgsError}}{gDefArgsError}{NW4fRSrE-sLbTR-1}\nwindexuse{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}{NW4fRSrE-sLbTR-1}\nwendcode{}\nwbegindocs{80}\nwdocspar
\nwenddocs{}\nwbegincode{81}\sublabel{NW4fRSrE-40T82k-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-40T82k-1}}}\moddef{Consistency~{\nwtagstyle{}\subpageref{NW4fRSrE-40T82k-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1}(ff: char): FrmPtr;
var
   cFrm,cFrm2,EqFrm,lFrm1,lFrm2: FrmPtr;
   i,j: integer;
begin
   \{if gErrorInDefinition then begin \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1} := NewInCorFrm; exit end;
    watpliwe czy taki ogolny warunek ma sens, w koncu do sformulowania
    "consistency" potrzebujemy jedynie definiensu, a jezeli byly jakies
    niepoprawne zdania w definiensie, to chyba generowanie zdan powinno to
    zalatwic.
   \}
   \{ Google translate:
    if gErrorInDefinition then begin \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1} := NewInCorFrm; exit end;
    it is doubtful whether such a general condition makes sense, after all, to formulate
    "consistency" we only need a definiens, and if there were any
    incorrect sentences in the definiens, then generating sentences should probably
    take care of it. \}
   if gDefiniens = nil then
   begin
      \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1} := NewInCorFrm; exit;
   end;
   Mizassert(2522,gDefiniens^.nPartialDefinientia.Count <> 0);
   cFrm := NewVerum;
   with gDefiniens^ do
      for i := 0 to nPartialDefinientia.Count - 1 do
         with PartDefPtr(nPartialDefinientia.Items^[i])^ do
      begin
         for j :=  i+1 to nPartialDefinientia.Count - 1 do
         begin
            cFrm2 := NewConj(FrmPtr(nGuard)^.CopyFormula,
                             FrmPtr(PartDefPtr(nPartialDefinientia.Items^[j])^.nGuard)^.CopyFormula);
            case DefSort of
               'm':
                  begin
                     lFrm1 := FrmPtr(nPartDefiniens)^.CopyFormula;
                     lFrm2 := FrmPtr(PartDefPtr(nPartialDefinientia.Items^[j])^.nPartDefiniens)^.CopyFormula
                  end;
               'e':
                  begin
                     lFrm1 := NewEqFrm(NewItTrm,CopyTerm(TrmPtr(nPartDefiniens)));
                     lFrm2 := NewEqFrm(NewItTrm,CopyTerm(TrmPtr(PartDefPtr(nPartialDefinientia.Items^[j])^.nPartDefiniens)))
                  end;
               else RunTimeError(2505);
            end;
            EqFrm := NewBiCond(lFrm1,lFrm2);
            cFrm := NewConj(cFrm,NewImpl(cFrm2,EqFrm));
         end;
      end;
   if ff in ['M','K'] then
   begin
      WithInFormula(cFrm,\nwlinkedidentc{ChangeBoundAndIt}{NW4fRSrE-2cKzYF-1});
      cFrm := NewUniv(ItTyp^.CopyType,cFrm);
   end;
   \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1} := cFrm;
end;
\nwindexdefn{\nwixident{Consistency}}{Consistency}{NW4fRSrE-40T82k-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{Consistency}}{Consistency}}}\nwidentuses{\\{{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}}}\nwindexuse{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}{NW4fRSrE-40T82k-1}\nwendcode{}\nwbegindocs{82}\nwdocspar
\nwenddocs{}\nwbegincode{83}\sublabel{NW4fRSrE-4TUJX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4TUJX-1}}}\moddef{Existence~{\nwtagstyle{}\subpageref{NW4fRSrE-4TUJX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{Existence}{NW4fRSrE-4TUJX-1}(ff: char): FrmPtr;
var
   lOth,cFrm:FrmPtr;
   function PartExCond(fFrm: FrmPtr): FrmPtr;
   begin
      fFrm := fFrm^.CopyFormula;
      if fFrm^.FrmSort <> ikError then
      begin
         WithInFormula(fFrm,\nwlinkedidentc{ChangeBoundAndIt}{NW4fRSrE-2cKzYF-1});
         fFrm := NewExis(ItTyp^.CopyType,fFrm);
      end;
      PartExCond := fFrm;
   end;
var
   z: integer;
begin
   if gDefiniens = nil then
   begin
      \nwlinkedidentc{Existence}{NW4fRSrE-4TUJX-1} := NewInCorFrm; exit;
   end;
   with gDefiniens^ do
   begin
      if nOtherwise <> nil then lOth := NewVerum;
      cFrm := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            if gDefiniens^.nOtherwise <> nil then
               lOth := NewConj(lOth,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
            cFrm := NewConj(cFrm,NewImpl(FrmPtr(nGuard)^.CopyFormula,
                                         PartExCond(FrmPtr(nPartDefiniens))));
         end;
      if nOtherwise <> nil then
         cFrm := NewConj(cFrm,NewImpl(lOth,PartExCond(FrmPtr(nOtherwise))));
      \nwlinkedidentc{Existence}{NW4fRSrE-4TUJX-1} := cFrm;
   end;
end;
\nwindexdefn{\nwixident{Existence}}{Existence}{NW4fRSrE-4TUJX-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{Existence}}{Existence}}}\nwidentuses{\\{{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}}}\nwindexuse{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}{NW4fRSrE-4TUJX-1}\nwendcode{}\nwbegindocs{84}\nwdocspar
\nwenddocs{}\nwbegincode{85}\sublabel{NW4fRSrE-3pxze-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3pxze-1}}}\moddef{Parse coherence in equals definition~{\nwtagstyle{}\subpageref{NW4fRSrE-3pxze-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{CoherenceEq}{NW4fRSrE-3pxze-1}: FrmPtr;
var
   lOth,cFrm: FrmPtr;
   z: integer;
begin
   if gDefiniens = nil then
   begin \nwlinkedidentc{CoherenceEq}{NW4fRSrE-3pxze-1} := NewInCorFrm; exit end;
   with gDefiniens^ do
   begin
      mizassert(2598,DefSort = 'e');
      if nOtherwise <> nil then lOth := NewVerum;
      cFrm := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            if gDefiniens^.nOtherwise <> nil then
               lOth := NewConj(lOth,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
            cFrm := NewConj(cFrm,NewImpl(FrmPtr(nGuard)^.CopyFormula,
                                         NewQualFrm(CopyTerm(TrmPtr(nPartDefiniens)),ItTyp^.CopyType)));
         end;
      if nOtherwise <> nil then
      begin
         cFrm := NewConj(cFrm,NewImpl(lOth,
                                      NewQualFrm(CopyTerm(TrmPtr(nOtherwise)),ItTyp^.CopyType)));
      end;
      \nwlinkedidentc{CoherenceEq}{NW4fRSrE-3pxze-1} := cFrm;
  end;
end;
\nwindexdefn{\nwixident{CoherenceEq}}{CoherenceEq}{NW4fRSrE-3pxze-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{CoherenceEq}}{CoherenceEq}}}\nwendcode{}\nwbegindocs{86}\nwdocspar
\nwenddocs{}\nwbegincode{87}\sublabel{NW4fRSrE-1XvsOm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1XvsOm-1}}}\moddef{Change bound variables and iterate (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-1XvsOm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeBoundAndIt1}{NW4fRSrE-1XvsOm-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
  with VarTrmPtr(fTrm)^ do
     case TrmSort of
        ikTrmIt:
           begin
              lTrm := fTrm;
              fTrm := NewVarTrm(ikTrmBound,1);
              dispose(lTrm,Done);
           end;
        ikTrmBound:
           inc(VarNr,2);
     end;
end;
\nwindexdefn{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}{NW4fRSrE-1XvsOm-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}}}\nwendcode{}\nwbegindocs{88}\nwdocspar
\nwenddocs{}\nwbegincode{89}\sublabel{NW4fRSrE-1DN1eC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1DN1eC-1}}}\moddef{Copy formula with fresh bound variables~{\nwtagstyle{}\subpageref{NW4fRSrE-1DN1eC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{NewGuard}{NW4fRSrE-1DN1eC-1}(fFrm: FrmPtr): FrmPtr;
begin
   if fFrm^.FrmSort <> ikError then
   begin
      fFrm := fFrm^.CopyFormula;
      WithInFormula(fFrm,\nwlinkedidentc{ChangeBoundAndIt1}{NW4fRSrE-1XvsOm-1});
   end;
   \nwlinkedidentc{NewGuard}{NW4fRSrE-1DN1eC-1} := fFrm;
end;
\nwindexdefn{\nwixident{NewGuard}}{NewGuard}{NW4fRSrE-1DN1eC-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{NewGuard}}{NewGuard}}}\nwidentuses{\\{{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}}}\nwindexuse{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}{NW4fRSrE-1DN1eC-1}\nwendcode{}\nwbegindocs{90}\nwdocspar
The only difference with {\Tt{}\nwlinkedidentq{ChangeBoundAndIt1}{NW4fRSrE-1XvsOm-1}\nwendquote} and this procedure is the
{\Tt{}ikTrmIt\nwendquote} case will call {\Tt{}NewVarTrm(ikTrmBound,2)\nwendquote} instead of 
{\Tt{}NewVarTrm(ikTrmBound,1)\nwendquote}. Its significance eludes me at the moment.

\nwenddocs{}\nwbegincode{91}\sublabel{NW4fRSrE-1k6dgM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1k6dgM-1}}}\moddef{Change bound variables and iterate (two)~{\nwtagstyle{}\subpageref{NW4fRSrE-1k6dgM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeBoundAndIt2}{NW4fRSrE-1k6dgM-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmIt:
            begin
               lTrm := fTrm;
               fTrm := NewVarTrm(ikTrmBound,2);
               dispose(lTrm,Done);
            end;
         ikTrmBound: inc(VarNr,2);
      end;
end;
\nwindexdefn{\nwixident{ChangeBoundAndIt2}}{ChangeBoundAndIt2}{NW4fRSrE-1k6dgM-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{ChangeBoundAndIt2}}{ChangeBoundAndIt2}}}\nwendcode{}\nwbegindocs{92}\nwdocspar
\nwenddocs{}\nwbegincode{93}\sublabel{NW4fRSrE-1ZhYjH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1ZhYjH-1}}}\moddef{Partial uniqueness condition~{\nwtagstyle{}\subpageref{NW4fRSrE-1ZhYjH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{PartUniCond}{NW4fRSrE-1ZhYjH-1}(fFrm: FrmPtr): FrmPtr;
var
   cFrm1,cFrm2: FrmPtr;
begin
   if fFrm^.FrmSort <> ikError then
   begin
      cFrm1 := fFrm^.CopyFormula;
      cFrm2 := fFrm^.CopyFormula;
      WithInFormula(cFrm1,\nwlinkedidentc{ChangeBoundAndIt1}{NW4fRSrE-1XvsOm-1});
      WithInFormula(cFrm2,\nwlinkedidentc{ChangeBoundAndIt2}{NW4fRSrE-1k6dgM-1});
      fFrm := NewImpl(NewConj(cFrm1,cFrm2),
                      NewEqFrm(NewVarTrm(ikTrmBound,1),NewVarTrm(ikTrmBound,2)));
   end;
   \nwlinkedidentc{PartUniCond}{NW4fRSrE-1ZhYjH-1} := fFrm;
end;
\nwindexdefn{\nwixident{PartUniCond}}{PartUniCond}{NW4fRSrE-1ZhYjH-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{PartUniCond}}{PartUniCond}}}\nwidentuses{\\{{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}}\\{{\nwixident{ChangeBoundAndIt2}}{ChangeBoundAndIt2}}}\nwindexuse{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}{NW4fRSrE-1ZhYjH-1}\nwindexuse{\nwixident{ChangeBoundAndIt2}}{ChangeBoundAndIt2}{NW4fRSrE-1ZhYjH-1}\nwendcode{}\nwbegindocs{94}\nwdocspar
\nwenddocs{}\nwbegincode{95}\sublabel{NW4fRSrE-3FE2SD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3FE2SD-1}}}\moddef{Parse uniqueness condition~{\nwtagstyle{}\subpageref{NW4fRSrE-3FE2SD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-26ZHbS-1}}\nwenddeflinemarkup
function \nwlinkedidentc{Uniqueness}{NW4fRSrE-3FE2SD-1}: FrmPtr;
var
   cFrm,lOth: FrmPtr;
   lTyp: TypPtr;
   z: integer;
begin
   if gDefiniens = nil then begin \nwlinkedidentc{Uniqueness}{NW4fRSrE-3FE2SD-1} := NewInCorFrm; exit end;
   with gDefiniens^ do
   begin
      if nOtherwise <> nil then lOth := NewVerum;
      cFrm := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do 
            with PartDefPtr(Items^[z])^ do
         begin
            if gDefiniens^.nOtherwise <> nil then
               lOth := NewConj(lOth,NewNegDis(\nwlinkedidentc{NewGuard}{NW4fRSrE-1DN1eC-1}(FrmPtr(nGuard))));
            cFrm := NewConj(cFrm,NewImpl(\nwlinkedidentc{NewGuard}{NW4fRSrE-1DN1eC-1}(FrmPtr(nGuard)),
                                         \nwlinkedidentc{PartUniCond}{NW4fRSrE-1ZhYjH-1}(FrmPtr(nPartDefiniens))));
         end;
      if nOtherwise <> nil then
         cFrm := NewConj(cFrm,NewImpl(lOth,\nwlinkedidentc{PartUniCond}{NW4fRSrE-1ZhYjH-1}(FrmPtr(nOtherwise))));
   end;
   lTyp := ItTyp^.CopyType;
   \nwlinkedidentc{Uniqueness}{NW4fRSrE-3FE2SD-1} := NewUniv(lTyp^.CopyType,NewUniv(lTyp,cFrm));
end;
\nwindexdefn{\nwixident{Uniqueness}}{Uniqueness}{NW4fRSrE-3FE2SD-1}\eatline
\nwused{\\{NW4fRSrE-26ZHbS-1}}\nwidentdefs{\\{{\nwixident{Uniqueness}}{Uniqueness}}}\nwidentuses{\\{{\nwixident{NewGuard}}{NewGuard}}\\{{\nwixident{PartUniCond}}{PartUniCond}}}\nwindexuse{\nwixident{NewGuard}}{NewGuard}{NW4fRSrE-3FE2SD-1}\nwindexuse{\nwixident{PartUniCond}}{PartUniCond}{NW4fRSrE-3FE2SD-1}\nwendcode{}\nwbegindocs{96}\nwdocspar
We need to forward declare {\Tt{}\nwlinkedidentq{Justify}{NW4fRSrE-3T8oCT-1}\nwendquote} when parsing the correctness conditions.
\nwenddocs{}\nwbegincode{97}\sublabel{NW4fRSrE-11hqoE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-11hqoE-1}}}\moddef{Parse correctness conditions~{\nwtagstyle{}\subpageref{NW4fRSrE-11hqoE-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
procedure \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(ThesisId, fLabId: integer; fThesis: FrmPtr); forward;

procedure \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
var
   cFrm: FrmPtr;
   k,lCorrCondNr: integer;
begin
   while InFile.Current.Kind='Y' do
   begin
      lCorrCondNr := InFile.Current.Nr;
      InFile.InPos(CurPos);
      mizassert(2514,gCorrCond[lCorrCondNr]<>nil);
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart0(Nr2CorrEl[ lCorrCondNr]);
      \{$ENDIF\}
      \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,gCorrCond[lCorrCondNr]);
      if lCorrCondNr <> 0 then
      begin
         dispose(gCorrCond[lCorrCondNr],Done);
         gCorrCond[lCorrCondNr] := nil;
      end;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElEnd(Nr2CorrEl[ lCorrCondNr]);
      \{$ENDIF\}
   end;
   if InFile.Current.Kind= ikItmCorrectness then
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart0(elCorrectness);
      \{$ENDIF\}
      InFile.InPos(CurPos);
      cFrm := NewVerum;
      for k := 1 to CorrCondNbr do
         if gCorrCond[k] <> nil then
         begin
            cFrm := NewConj(cFrm,gCorrCond[k]);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart0(Nr2CorrEl[ k]);
            AReport.Out_Formula(gCorrCond[k]);
            AReport.Out_XElEnd(Nr2CorrEl[ k]);
            \{$ENDIF\}     
         end;
      \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,cFrm);
      dispose(cFrm,Done);
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElEnd(elCorrectness);
      \{$ENDIF\}
   end;
end;
\nwindexdefn{\nwixident{Correctness}}{Correctness}{NW4fRSrE-11hqoE-1}\eatline
\nwnotused{Parse correctness conditions}\nwidentdefs{\\{{\nwixident{Correctness}}{Correctness}}}\nwidentuses{\\{{\nwixident{Justify}}{Justify}}}\nwindexuse{\nwixident{Justify}}{Justify}{NW4fRSrE-11hqoE-1}\nwendcode{}\nwbegindocs{98}\nwdocspar
\section{Checking Loci}

Loci occur in definitions and registrations. We need to check they are
accessible and defined.

\nwenddocs{}\nwbegincode{99}\sublabel{NW4fRSrE-24b9uj-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-2}}}\moddef{Analyzer methods~{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwprevnextdefs{NW4fRSrE-24b9uj-1}{NW4fRSrE-24b9uj-3}\nwenddeflinemarkup
\LA{}Check Loci constants~{\nwtagstyle{}\subpageref{NW4fRSrE-1fVrrm-1}}\RA{}
\LA{}Check loci constants in definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-4KbSDF-1}}\RA{}
\LA{}Analyze sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-41aiR1-1}}\RA{}
\LA{}New in correlate definition~{\nwtagstyle{}\subpageref{NW4fRSrE-42RyEy-1}}\RA{}
\LA{}Read definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-2xdcsX-1}}\RA{}
\LA{}Constructor for \code{}DefNode\edoc{}~{\nwtagstyle{}\subpageref{NW4fRSrE-VhUFe-1}}\RA{}
\LA{}Write definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-4OXFUo-1}}\RA{}
\LA{}Read pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-2CtgW3-1}}\RA{}
\LA{}Determine abstract notation number~{\nwtagstyle{}\subpageref{NW4fRSrE-23RESF-1}}\RA{}
\LA{}Get pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-mDy4S-1}}\RA{}
\LA{}Initialize access~{\nwtagstyle{}\subpageref{NW4fRSrE-41gYk7-1}}\RA{}
\LA{}Check access~{\nwtagstyle{}\subpageref{NW4fRSrE-1YfrP8-1}}\RA{}
\LA{}Initialize loci for cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-1W2kMW-1}}\RA{}
\LA{}Check all loci are accessible in type~{\nwtagstyle{}\subpageref{NW4fRSrE-3K8iTi-1}}\RA{}
\LA{}Check all loci are accessible in term~{\nwtagstyle{}\subpageref{NW4fRSrE-38WzsA-1}}\RA{}
\LA{}Definition predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-36ZjPM-1}}\RA{}
\LA{}Create list of constant terms~{\nwtagstyle{}\subpageref{NW4fRSrE-a1Spe-1}}\RA{}
\LA{}Create a list of terms~{\nwtagstyle{}\subpageref{NW4fRSrE-2ffINP-1}}\RA{}
\LA{}Redefine predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-3QTOh1-1}}\RA{}
\LA{}Notation predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-ZDOZa-1}}\RA{}
\LA{}Insert predicate~{\nwtagstyle{}\subpageref{NW4fRSrE-1Nd4jW-1}}\RA{}
\LA{}Parse definition of predicate --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-2uTf5M-1}}\RA{}
\LA{}Parse definition of attribute --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-mZ8N3-1}}\RA{}
\LA{}Parse specification~{\nwtagstyle{}\subpageref{NW4fRSrE-2NGLeB-1}}\RA{}
\LA{}Parse functor definition pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-138Ush-1}}\RA{}
\LA{}Parse redefinition specification~{\nwtagstyle{}\subpageref{NW4fRSrE-ti2Op-1}}\RA{}
\LA{}Parse pattern in functor redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-3o0u5v-1}}\RA{}
\LA{}Parse notation in functor pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-49kkDZ-1}}\RA{}
\LA{}Insert functor~{\nwtagstyle{}\subpageref{NW4fRSrE-1nPKhC-1}}\RA{}
\LA{}Parse definition of functor --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-2BYsiX-1}}\RA{}
\LA{}Create list of loci~{\nwtagstyle{}\subpageref{NW4fRSrE-11oteT-1}}\RA{}
\LA{}Parse mode pattern in definition~{\nwtagstyle{}\subpageref{NW4fRSrE-24hAJs-1}}\RA{}
\LA{}Parse mode pattern in redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-2hqWv9-1}}\RA{}
\LA{}Parse mode pattern for notation~{\nwtagstyle{}\subpageref{NW4fRSrE-3lavOg-1}}\RA{}
\LA{}Insert a mode~{\nwtagstyle{}\subpageref{NW4fRSrE-jEwY5-1}}\RA{}
\LA{}Parse definition of an expandable mode~{\nwtagstyle{}\subpageref{NW4fRSrE-1u93O4-1}}\RA{}
\LA{}Parse predicate or attribute pattern in definition~{\nwtagstyle{}\subpageref{NW4fRSrE-45Cbij-1}}\RA{}
\LA{}Parse pattern for predicate or attribute redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-2VOwe7-1}}\RA{}
\LA{}Parse notation in a predicate or attribute pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-3AWSsC-1}}\RA{}
\LA{}Insert predicate or attribute~{\nwtagstyle{}\subpageref{NW4fRSrE-1gwegT-1}}\RA{}
\LA{}Analyze cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-3mJ75Q-1}}\RA{}
\LA{}Add items to a cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-3yW3eS-1}}\RA{}
\LA{}Define existential cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-sMl51-1}}\RA{}
\LA{}Define conditional cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-1gUvy2-1}}\RA{}
\LA{}Define functorial cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-mgVCP-1}}\RA{}
\LA{}Collect loci~{\nwtagstyle{}\subpageref{NW4fRSrE-1MmOtr-1}}\RA{}
\LA{}Find pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-1yastl-1}}\RA{}
\LA{}Define reduction~{\nwtagstyle{}\subpageref{NW4fRSrE-4eg3tM-1}}\RA{}
\LA{}Define identify~{\nwtagstyle{}\subpageref{NW4fRSrE-2RxeIl-1}}\RA{}
\LA{}Define property~{\nwtagstyle{}\subpageref{NW4fRSrE-2NEGZf-1}}\RA{}
\LA{}Parse definition of mode --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-3xpn6K-1}}\RA{}
\LA{}Set structure~{\nwtagstyle{}\subpageref{NW4fRSrE-vj17M-1}}\RA{}
\LA{}Analyze selector~{\nwtagstyle{}\subpageref{NW4fRSrE-CKGCk-1}}\RA{}
\LA{}Define a structure~{\nwtagstyle{}\subpageref{NW4fRSrE-XUFqn-1}}\RA{}
\LA{}Parse a reservation~{\nwtagstyle{}\subpageref{NW4fRSrE-4G4xQr-1}}\RA{}
\LA{}Spread local predicates~{\nwtagstyle{}\subpageref{NW4fRSrE-35R9Kt-1}}\RA{}
\LA{}Decompose formula~{\nwtagstyle{}\subpageref{NW4fRSrE-omUgm-1}}\RA{}
\LA{}Spread atomic formula~{\nwtagstyle{}\subpageref{NW4fRSrE-1O513Y-1}}\RA{}
\LA{}Chopping definientia(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-1YXN9Y-1}}\RA{}
\LA{}Change bound variable to declaration(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-41YgVE-1}}\RA{}
\LA{}Mark term as taken~{\nwtagstyle{}\subpageref{NW4fRSrE-3IjlED-1}}\RA{}
\LA{}Chop variables~{\nwtagstyle{}\subpageref{NW4fRSrE-4LBoA7-1}}\RA{}
\LA{}Is \code{}Position\edoc{} in the collection?~{\nwtagstyle{}\subpageref{NW4fRSrE-3MC2qH-1}}\RA{}
\LA{}Chop conclusion~{\nwtagstyle{}\subpageref{NW4fRSrE-1vzwMI-1}}\RA{}
\LA{}Dispose level~{\nwtagstyle{}\subpageref{NW4fRSrE-14nyvU-1}}\RA{}
\LA{}Reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-1ByLHM-1}}\RA{}
\LA{}Per cases reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-2IcayZ-1}}\RA{}
\LA{}Demonstration~{\nwtagstyle{}\subpageref{NW4fRSrE-2oe4Xh-1}}\RA{}
\LA{}Change declared constant to bound variable~{\nwtagstyle{}\subpageref{NW4fRSrE-4XBdxo-1}}\RA{}
\LA{}Skeletonize list~{\nwtagstyle{}\subpageref{NW4fRSrE-3KnOnX-1}}\RA{}
\LA{}Skeletonize sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-4QAXkH-1}}\RA{}
\LA{}Diffuse Reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-3ug0j6-1}}\RA{}
\LA{}New list of universally quantified variables~{\nwtagstyle{}\subpageref{NW4fRSrE-3S612w-1}}\RA{}
\LA{}Change skeletonized fixed variable to bound variable~{\nwtagstyle{}\subpageref{NW4fRSrE-2UbSlH-1}}\RA{}
\LA{}New universal list (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-aOrsk-1}}\RA{}
\LA{}Reasoning result~{\nwtagstyle{}\subpageref{NW4fRSrE-1FcRyw-1}}\RA{}
\LA{}Diffuse per cases reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-1g3pia-1}}\RA{}
\LA{}Diffuse statement~{\nwtagstyle{}\subpageref{NW4fRSrE-8Der7-1}}\RA{}
\LA{}Hereby~{\nwtagstyle{}\subpageref{NW4fRSrE-4BQSHp-1}}\RA{}
\LA{}Justify~{\nwtagstyle{}\subpageref{NW4fRSrE-3T8oCT-1}}\RA{}
\LA{}Regular statement~{\nwtagstyle{}\subpageref{NW4fRSrE-4VrAtu-1}}\RA{}
\LA{}Parse a statement~{\nwtagstyle{}\subpageref{NW4fRSrE-4XKGIt-1}}\RA{}
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{100}\nwdocspar

\nwenddocs{}\nwbegincode{101}\sublabel{NW4fRSrE-1fVrrm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1fVrrm-1}}}\moddef{Check Loci constants~{\nwtagstyle{}\subpageref{NW4fRSrE-1fVrrm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure CheckLocConst(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      if TrmSort=ikTrmConstant then
         if (FixedVar[VarNr].nSkelConstNr=0) and (VarNr>g.DemBase) then
            \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} := true;
end;
\nwindexdefn{\nwixident{CheckLocConts}}{CheckLocConts}{NW4fRSrE-1fVrrm-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CheckLocConts}}{CheckLocConts}}}\nwidentuses{\\{{\nwixident{gConstErr}}{gConstErr}}}\nwindexuse{\nwixident{gConstErr}}{gConstErr}{NW4fRSrE-1fVrrm-1}\nwendcode{}\nwbegindocs{102}\nwdocspar
\nwenddocs{}\nwbegincode{103}\sublabel{NW4fRSrE-4KbSDF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4KbSDF-1}}}\moddef{Check loci constants in definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-4KbSDF-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{CheckLocConstInDefiniens}{NW4fRSrE-4KbSDF-1}(fDef: DefPtr);
var
   z: integer;
begin
   with fDef^ do
   begin
      with nPartialDefinientia do
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            case DefSort of
               'm': WithInFormula(FrmPtr(nPartDefiniens),CheckLocConst);
               'e': WithInTerm(TrmPtr(nPartDefiniens),CheckLocConst);
               else RunTimeError(2506);
            end;
            WithInFormula(FrmPtr(nGuard),CheckLocConst);
         end;
      if nOtherWise<>nil then
         case DefSort of
            'm': WithInFormula(FrmPtr(nOtherWise),CheckLocConst);
            'e': WithInTerm(TrmPtr(nOtherWise),CheckLocConst);
            else RunTimeError(2507);
         end;
   end;
end;
\nwindexdefn{\nwixident{CheckLocConstInDefiniens}}{CheckLocConstInDefiniens}{NW4fRSrE-4KbSDF-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CheckLocConstInDefiniens}}{CheckLocConstInDefiniens}}}\nwendcode{}\nwbegindocs{104}\nwdocspar
\nwenddocs{}\nwbegincode{105}\sublabel{NW4fRSrE-41aiR1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-41aiR1-1}}}\moddef{Analyze sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-41aiR1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
\{ Uzyc w \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1} !!!\} \{ Used in \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1} !!!\}
function \nwlinkedidentc{AnalyzeSnt}{NW4fRSrE-41aiR1-1}(fSnt: ExpPtr; fNeg: boolean): FrmPtr;
var
   lFrm: FrmPtr;
begin
   BoundVarNbr := 0;
   lFrm := fSnt^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   dispose(fSnt,Done);
   if fNeg then lFrm := NewNegDis(lFrm);
   \nwlinkedidentc{AnalyzeSnt}{NW4fRSrE-41aiR1-1} := lFrm;
end;
\nwindexdefn{\nwixident{AnalyzeSnt}}{AnalyzeSnt}{NW4fRSrE-41aiR1-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AnalyzeSnt}}{AnalyzeSnt}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{ReadSentence}}{ReadSentence}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-41aiR1-1}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-41aiR1-1}\nwendcode{}\nwbegindocs{106}\nwdocspar
\nwenddocs{}\nwbegincode{107}\sublabel{NW4fRSrE-42RyEy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-42RyEy-1}}}\moddef{New in correlate definition~{\nwtagstyle{}\subpageref{NW4fRSrE-42RyEy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{NewInCorDef}{NW4fRSrE-42RyEy-1}: DefPtr;
var
   lColl: MCollection;
begin
   lColl.Init(0,0);
   \nwlinkedidentc{NewInCorDef}{NW4fRSrE-42RyEy-1} := new(DefPtr,Init(ikError,lColl,NewInCorFrm));
end;
\nwindexdefn{\nwixident{NewInCorDef}}{NewInCorDef}{NW4fRSrE-42RyEy-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NewInCorDef}}{NewInCorDef}}}\nwendcode{}\nwbegindocs{108}\nwdocspar
\nwenddocs{}\nwbegincode{109}\sublabel{NW4fRSrE-2xdcsX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2xdcsX-1}}}\moddef{Read definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-2xdcsX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(Negate: boolean; const aPrim: MList; fType: TypPtr);
var
   k,lLabId: integer;
   lPartDef: PObject;
   lGuard: FrmPtr;
   lPartialPart: MCollection;
   lOtherwise: PObject;
   pDefiniens: DefObj;
   lPartDefPtr: PartDefPtr;
   lPartDefiniens,llGuard: ExpPtr;
   z: integer;
begin
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs := ' ';
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Specified := false;
   gDefiniens := nil;
   if InFile.Current.Kind in ['m','e'] then
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs := InFile.Current.Kind;
      InFile.InWord;
      InFile.InInt(lLabId);
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Pos1 := CurPos;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries.Init(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length,1);
      for k := 1 to \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length do
      begin
         \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries.Insert(TypPtr(aPrim.Items^[k-1])^.CopyType);
      end;
      if fType <> nil then
      begin
         \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Specified := true;
         fType := AdjustedType(fType);
         fType^.WithinType(ChangeToLoci);
         \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries.Insert(fType);
         \{ Ten typ nalezy dysponowac !
           This type is a must-have! \}
      end;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabNr := InFile.Current.Nr;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabId :=  lLabId;
      InFile.InPos(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Pos2);
      with pDefiniens do
      begin
         InFile.InWord; DefSort := InFile.Current.Kind;
         nPartialDefinientia.Init(2,2);
         InFile.InWord;
         while InFile.Current.Kind <> ';' do
         begin
            case DefSort of
               'm': lPartDefiniens := LoadFormula;
               'e': lPartDefiniens := LoadTerm;
               else RunTimeError(2508);
            end;
            llGuard := LoadFormula;
            lPartDefPtr := new(PartDefPtr,Init(lPartDefiniens,llGuard));
            nPartialDefinientia.Insert(lPartDefPtr);
            InFile.InWord;
         end;
         InFile.InWord;
         case InFile.Current.Kind of
            'n': nOtherwise := nil;
            'o':
               case DefSort of
                  'm': nOtherwise := LoadFormula;
                  'e': nOtherwise := LoadTerm;
                  else RunTimeError(2509);
               end;
            else RunTimeError(2520);
         end;
      end;
      lPartialPart.Init(0,4);
      with pDefiniens,nPartialDefinientia do
      begin
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            case DefSort of
               'm': lPartDef := \nwlinkedidentc{AnalyzeSnt}{NW4fRSrE-41aiR1-1}(ExpPtr(nPartDefiniens),Negate);
               'e': lPartDef := \nwlinkedidentc{AnalyzeTerm}{NW4fRSrE-31Gox1-1}(ExpPtr(nPartDefiniens));
               else RunTimeError(2519);
            end;
            lGuard := \nwlinkedidentc{AnalyzeSnt}{NW4fRSrE-41aiR1-1}(ExpPtr(nGuard),false);
            lPartialPart.Insert(new(PartDefPtr,Init(lPartDef,lGuard)));
         end;
         lOtherwise := nil;
         if nOtherwise <> nil then
            case DefSort of
               'm': lOtherwise := \nwlinkedidentc{AnalyzeSnt}{NW4fRSrE-41aiR1-1}(ExpPtr(nOtherWise),Negate);
               'e': lOtherwise := \nwlinkedidentc{AnalyzeTerm}{NW4fRSrE-31Gox1-1}(ExpPtr(nOtherWise));
               else RunTimeError(2510);
            end;
      end;
      gDefiniens := new(DefPtr,Init(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs,lPartialPart,lOtherwise));
      \{ kontrola stalych lokalnych \}
      \{ local constant control \}
      \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} := false;
      \nwlinkedidentc{CheckLocConstInDefiniens}{NW4fRSrE-4KbSDF-1}(gDefiniens);
      if \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} then
      begin ErrImm(69); gDefiniens := \nwlinkedidentc{NewInCorDef}{NW4fRSrE-42RyEy-1} end;
      if gDefiniens^.nPartialDefinientia.Count <> 0 then
         gCorrCond[ord(syConsistency)] := \nwlinkedidentc{Consistency}{NW4fRSrE-40T82k-1}(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind);
      if gRedef then gCorrCond[ord(syCompatibility)] := \nwlinkedidentc{Compatibility}{NW4fRSrE-sLbTR-1}(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind);
      InFile.InWord;
   end;
end;
\nwindexdefn{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-2xdcsX-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwidentuses{\\{{\nwixident{AnalyzeSnt}}{AnalyzeSnt}}\\{{\nwixident{AnalyzeTerm}}{AnalyzeTerm}}\\{{\nwixident{CheckLocConstInDefiniens}}{CheckLocConstInDefiniens}}\\{{\nwixident{Compatibility}}{Compatibility}}\\{{\nwixident{Consistency}}{Consistency}}\\{{\nwixident{gConstErr}}{gConstErr}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{NewInCorDef}}{NewInCorDef}}}\nwindexuse{\nwixident{AnalyzeSnt}}{AnalyzeSnt}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{AnalyzeTerm}}{AnalyzeTerm}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{CheckLocConstInDefiniens}}{CheckLocConstInDefiniens}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{Compatibility}}{Compatibility}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{Consistency}}{Consistency}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{gConstErr}}{gConstErr}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-2xdcsX-1}\nwindexuse{\nwixident{NewInCorDef}}{NewInCorDef}{NW4fRSrE-2xdcsX-1}\nwendcode{}\nwbegindocs{110}\nwdocspar
\nwenddocs{}\nwbegincode{111}\sublabel{NW4fRSrE-VhUFe-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-VhUFe-1}}}\moddef{Constructor for \code{}DefNode\edoc{}~{\nwtagstyle{}\subpageref{NW4fRSrE-VhUFe-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}: MCollection;
    \nwlinkedidentc{gEssentials}{NW4fRSrE-VhUFe-1}: IntSequence;

constructor \nwlinkedidentc{DefNode}{NW4fRSrE-4Jho5-1}\nwlinkedidentc{.Init}{NW4fRSrE-VhUFe-1}(fMeansOccurs,fKind: char; fLab,fLabId: integer;
                         fDef: DefPtr;
                         fEntry: RSNENTRY);
begin
   nMeansOccurs := fMeansOccurs;
   nConstructor.Kind := \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind; nConstructor.Nr := gWhichOne;
   SkId := fLab; SkLabId :=  fLabId; DDef := fDef;
   SkVarNbr := g.VarNbr;
   SkIt := g.GenCount;
   case fKind of
      'R','V':;
      else inc(SkIt)
   end;
   nPrefix := fEntry;
   nEssentials.CopySequence(\nwlinkedidentc{gEssentials}{NW4fRSrE-VhUFe-1});
   move(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries,nPrimaryList,SizeOf(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries));
end;
\nwindexdefn{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-VhUFe-1}\nwindexdefn{\nwixident{gEssentials}}{gEssentials}{NW4fRSrE-VhUFe-1}\nwindexdefn{\nwixident{DefNode.Init}}{DefNode.Init}{NW4fRSrE-VhUFe-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefNode.Init}}{DefNode.Init}}\\{{\nwixident{gEssentials}}{gEssentials}}}\nwidentuses{\\{{\nwixident{DefNode}}{DefNode}}\\{{\nwixident{gDefNode}}{gDefNode}}}\nwindexuse{\nwixident{DefNode}}{DefNode}{NW4fRSrE-VhUFe-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-VhUFe-1}\nwendcode{}\nwbegindocs{112}\nwdocspar
\nwenddocs{}\nwbegincode{113}\sublabel{NW4fRSrE-4OXFUo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4OXFUo-1}}}\moddef{Write definiens~{\nwtagstyle{}\subpageref{NW4fRSrE-4OXFUo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
var
   k,r: integer;
begin
   if \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs <> ' ' then
   begin
      \nwlinkedidentc{gEssentials}{NW4fRSrE-VhUFe-1}.Init(0);
      for k := gSuperfluous+1 to \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length do
         r := \nwlinkedidentc{gEssentials}{NW4fRSrE-VhUFe-1}.Insert(k);
      if \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Specified then
         r := \nwlinkedidentc{gEssentials}{NW4fRSrE-VhUFe-1}.Insert(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length+1);
      \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Insert(new(\nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1},
                                Init(\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs,\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind,\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabNr,\nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.LabId,gDefiniens,g.LastEntry)));
   end;
end;
\nwindexdefn{\nwixident{WriteDefiniens}}{WriteDefiniens}{NW4fRSrE-4OXFUo-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{WriteDefiniens}}{WriteDefiniens}}}\nwidentuses{\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefNodePtr}}{DefNodePtr}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{gEssentials}}{gEssentials}}}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-4OXFUo-1}\nwindexuse{\nwixident{DefNodePtr}}{DefNodePtr}{NW4fRSrE-4OXFUo-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-4OXFUo-1}\nwindexuse{\nwixident{gEssentials}}{gEssentials}{NW4fRSrE-4OXFUo-1}\nwendcode{}\nwbegindocs{114}\nwdocspar
\nwenddocs{}\nwbegincode{115}\sublabel{NW4fRSrE-3Z12i6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3Z12i6-1}}}\moddef{Read visible~{\nwtagstyle{}\subpageref{NW4fRSrE-3Z12i6-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
var \nwlinkedidentc{ConstrError}{NW4fRSrE-3Z12i6-1}: boolean;
function \nwlinkedidentc{ReadVisible}{NW4fRSrE-3Z12i6-1}: integer;
var
   lInt: integer;
begin
   if InFile.Current.Kind = ';' then
   begin
      \nwlinkedidentc{ReadVisible}{NW4fRSrE-3Z12i6-1} := -1;
      exit;
   end;
   if InFile.Current.Nr<>0 then
   begin
      lInt := FixedVar[InFile.Current.Nr].nSkelConstNr;
      LociOcc[lInt] := true
   end
   else begin
      lInt := 0;
      \nwlinkedidentc{ConstrError}{NW4fRSrE-3Z12i6-1} := true
   end;
   \nwlinkedidentc{ReadVisible}{NW4fRSrE-3Z12i6-1} := lInt;
   InFile.InWord;
end;
\nwindexdefn{\nwixident{ReadVisible}}{ReadVisible}{NW4fRSrE-3Z12i6-1}\nwindexdefn{\nwixident{ConstrError}}{ConstrError}{NW4fRSrE-3Z12i6-1}\eatline
\nwnotused{Read visible}\nwidentdefs{\\{{\nwixident{ConstrError}}{ConstrError}}\\{{\nwixident{ReadVisible}}{ReadVisible}}}\nwendcode{}\nwbegindocs{116}\nwdocspar
\nwenddocs{}\nwbegincode{117}\sublabel{NW4fRSrE-2CtgW3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2CtgW3-1}}}\moddef{Read pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-2CtgW3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ReadPattern}{NW4fRSrE-2CtgW3-1}(var aFormNr: integer; var aVisible: IntSequence);
var
   r: integer;
begin
   \{ Przewiniecie formatu konstruktora \}
   \{ Scroll the constructor format \}
   aFormNr := InFile.Current.Nr;
   InFile.InPos(CurPos);
   aVisible.Init(0);
   InFile.InWord;
   while InFile.Current.Kind <> ';' do
   begin
      r := aVisible.Insert(InFile.Current.Nr);
      InFile.InWord;
   end;
end;
\nwindexdefn{\nwixident{ReadPattern}}{ReadPattern}{NW4fRSrE-2CtgW3-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ReadPattern}}{ReadPattern}}}\nwendcode{}\nwbegindocs{118}\nwdocspar
\nwenddocs{}\nwbegincode{119}\sublabel{NW4fRSrE-23RESF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-23RESF-1}}}\moddef{Determine abstract notation number~{\nwtagstyle{}\subpageref{NW4fRSrE-23RESF-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1}(nk: NotationKind): integer;
begin
  \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1} :=  1 + Notat[nk].Count +  Notat[nk].fExtCount - NotatBase[nk];
end;
\nwindexdefn{\nwixident{AbsNotatNr}}{AbsNotatNr}{NW4fRSrE-23RESF-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AbsNotatNr}}{AbsNotatNr}}}\nwendcode{}\nwbegindocs{120}\nwdocspar
\nwenddocs{}\nwbegincode{121}\sublabel{NW4fRSrE-mDy4S-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-mDy4S-1}}}\moddef{Get pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-mDy4S-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(aKind: NotationKind; var aPattern: PatternPtr);
var
   k: integer;
begin
   aPattern := new(PatternPtr,Init(aKind, \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1}(aKind), ArticleID));
   with aPattern^ do
   begin
      \nwlinkedidentc{ReadPattern}{NW4fRSrE-2CtgW3-1}(fFormNr,Visible);
      \{ Inicjalizacja \} \{ Initialization \}
      fPrimTypes.Init(dPrimLength);
      for k := 1 to dPrimLength do
         fPrimTypes.Insert(gPrimaries[k]^.CopyType);
      \{ Wyliczenie i zamarkowanie listy visible \}
      \{ Enumerate and mark the visible list \}
      for k := 0 to Visible.fCount-1 do
         if Visible.fList^[k] <> 0 then
            Visible.fList^[k] := FixedVar[Visible.fList^[k]].nSkelConstNr
         else begin
            Visible.fList^[k] := 0;
            fFormNr := 0
         end;
   end;
end;
\nwindexdefn{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-mDy4S-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{GetPattern}}{GetPattern}}}\nwidentuses{\\{{\nwixident{AbsNotatNr}}{AbsNotatNr}}\\{{\nwixident{ReadPattern}}{ReadPattern}}}\nwindexuse{\nwixident{AbsNotatNr}}{AbsNotatNr}{NW4fRSrE-mDy4S-1}\nwindexuse{\nwixident{ReadPattern}}{ReadPattern}{NW4fRSrE-mDy4S-1}\nwendcode{}\nwbegindocs{122}\nwdocspar
\nwenddocs{}\nwbegincode{123}\sublabel{NW4fRSrE-41gYk7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-41gYk7-1}}}\moddef{Initialize access~{\nwtagstyle{}\subpageref{NW4fRSrE-41gYk7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
begin
   FillChar(LociOcc,SizeOf(LociOcc),0);
end;
\nwindexdefn{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-41gYk7-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InitAccess}}{InitAccess}}}\nwendcode{}\nwbegindocs{124}\nwdocspar
The loci variables need to be accessible in the pattern of a definition.

\nwenddocs{}\nwbegincode{125}\sublabel{NW4fRSrE-1YfrP8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1YfrP8-1}}}\moddef{Check access~{\nwtagstyle{}\subpageref{NW4fRSrE-1YfrP8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(aPattern: PatternPtr);
var
   i,k: integer;
begin
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   with aPattern^ do
   begin
      \{ Kontrola poprawnosci konstruktora :
        - czy ma poprawny typ
        - czy kazdy lokus jest dostepny
      Constructor validation:
        - whether it has the correct type
        - whether each locus is available \}
      if fFormNr<>0 then
      begin
         \{ Zamarkowanie listy visible \} \{ Mark the visible list \}
         for k := 0 to Visible.fCount-1 do
            if Visible.fList^[k] <> 0 then
               LociOcc[ord(Visible.fList^[k])] := true;
         for i := fPrimTypes.Count-1 downto 0 do
         begin
            if TypPtr(fPrimTypes.Items^[i])^.TypSort=ikError
            then begin fFormNr := 0; exit end;
            if not LociOcc[i+1] then
            begin fFormNr := 0; ErrImm(100); exit end;
            TypPtr(fPrimTypes.Items^[i])^.WithinType(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
         end;
      end;
   end;
end;
\nwindexdefn{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-1YfrP8-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CheckAccess}}{CheckAccess}}}\nwidentuses{\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-1YfrP8-1}\nwindexuse{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-1YfrP8-1}\nwendcode{}\nwbegindocs{126}\nwdocspar
\nwenddocs{}\nwbegincode{127}\sublabel{NW4fRSrE-1W2kMW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1W2kMW-1}}}\moddef{Initialize loci for cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-1W2kMW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{InitLociForCluster}{NW4fRSrE-1W2kMW-1}(aClusterPtr: AttrCollectionPtr);
begin
   aClusterPtr := CopyCluster(aClusterPtr);
   aClusterPtr^.WithinAttrCollection(ChangeToLoci);
   aClusterPtr^.WithinAttrCollection(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   dispose(aClusterPtr,Done);
end;
\nwindexdefn{\nwixident{InitLociForCluster}}{InitLociForCluster}{NW4fRSrE-1W2kMW-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InitLociForCluster}}{InitLociForCluster}}}\nwidentuses{\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwindexuse{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-1W2kMW-1}\nwendcode{}\nwbegindocs{128}\nwdocspar
\nwenddocs{}\nwbegincode{129}\sublabel{NW4fRSrE-3K8iTi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3K8iTi-1}}}\moddef{Check all loci are accessible in type~{\nwtagstyle{}\subpageref{NW4fRSrE-3K8iTi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1}(const aTypList: MCollection; aTyp:TypPtr): boolean;
var
   i: integer;
begin
   \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1} := false;
   aTyp := aTyp^.CopyType;
   aTyp^.WithinType(ChangeToLoci);
   aTyp^.WithinType(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   for i := aTypList.Count-1 downto 0 do
   begin
      if TypPtr(aTypList.Items^[i])^.TypSort=ikError  then
      begin Dispose(aTyp,Done); exit end;
      if not LociOcc[i+1] then
      begin Dispose(aTyp,Done); exit end;
      TypPtr(aTypList.Items^[i])^.WithinType(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   end;
   \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1} := true;
   Dispose(aTyp,Done);
end;
\nwindexdefn{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}}}\nwidentuses{\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwindexuse{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-3K8iTi-1}\nwendcode{}\nwbegindocs{130}\nwdocspar
\nwenddocs{}\nwbegincode{131}\sublabel{NW4fRSrE-38WzsA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-38WzsA-1}}}\moddef{Check all loci are accessible in term~{\nwtagstyle{}\subpageref{NW4fRSrE-38WzsA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1}(const aTypList: MCollection; aTrm:TrmPtr): boolean;
var
   i: integer;
begin
   \nwlinkedidentc{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1} := false;
   aTrm := CopyTerm(aTrm);
   WithinTerm(aTrm,ChangeToLoci);
   WithinTerm(aTrm,\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   for i := aTypList.Count-1 downto 0 do
   begin
      if TypPtr(aTypList.Items^[i])^.TypSort=ikError then
      begin
         Dispose(aTrm,Done);
         exit;
      end;
      if not LociOcc[i+1] then
      begin
         Dispose(aTrm,Done);
         exit;
      end;
      TypPtr(aTypList.Items^[i])^.WithinType(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   end;
   \nwlinkedidentc{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1} := true;
   DisposeTrm(aTrm);
end;
\nwindexdefn{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}}}\nwidentuses{\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwindexuse{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-38WzsA-1}\nwendcode{}\nwbegindocs{132}\nwdocspar
\nwenddocs{}\nwbegincode{133}\sublabel{NW4fRSrE-36ZjPM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-36ZjPM-1}}}\moddef{Definition predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-36ZjPM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefPredPattern}{NW4fRSrE-36ZjPM-1};
var
   lPattern: PatternPtr;
begin
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noPredicate,lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noPredicate].InsertExt(lPattern);
   InFile.InWord;
   with Notat[noPredicate] do
      PatternPtr(Items^[Count+fExtCount-1])^.rConstr.Kind := ikFrmPred;
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   RedefAntonym := false;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'R';
   with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{DefPredPattern}}{DefPredPattern}{NW4fRSrE-36ZjPM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefPredPattern}}{DefPredPattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-36ZjPM-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-36ZjPM-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-36ZjPM-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-36ZjPM-1}\nwendcode{}\nwbegindocs{134}\nwdocspar
\nwenddocs{}\nwbegincode{135}\sublabel{NW4fRSrE-a1Spe-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-a1Spe-1}}}\moddef{Create list of constant terms~{\nwtagstyle{}\subpageref{NW4fRSrE-a1Spe-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(const aList: IntSequence): TrmList;
var
   lTrmList: TrmList;
   k: integer;
begin
   lTrmList := nil;
   for k := aList.fCount-1 downto 0 do
      lTrmList := NewTrmList(NewVarTrm(ikTrmConstant,ConstNr[aList.fList^[k]]),lTrmList);
   \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1} := lTrmList;
end;
\nwindexdefn{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-a1Spe-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CreateConstList}}{CreateConstList}}}\nwendcode{}\nwbegindocs{136}\nwdocspar
\nwenddocs{}\nwbegincode{137}\sublabel{NW4fRSrE-2ffINP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2ffINP-1}}}\moddef{Create a list of terms~{\nwtagstyle{}\subpageref{NW4fRSrE-2ffINP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{CreateTrmList}{NW4fRSrE-2ffINP-1}(const aList: IntSequence): TrmList;
var
   lTrmList: TrmList;
   k: integer;
begin
   lTrmList := nil;
   for k := aList.fCount-1 downto 0 do
   begin
      if aList.fList^[k]=0 then
      begin
         lTrmList := InCorrTrmList;
         break;
      end;
      lTrmList := NewTrmList(NewVarTrm(ikTrmConstant,aList.fList^[k]),lTrmList);
   end;
   \nwlinkedidentc{CreateTrmList}{NW4fRSrE-2ffINP-1} := lTrmList;
end;
\nwindexdefn{\nwixident{CreateTrmList}}{CreateTrmList}{NW4fRSrE-2ffINP-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CreateTrmList}}{CreateTrmList}}}\nwendcode{}\nwbegindocs{138}\nwdocspar
\nwenddocs{}\nwbegincode{139}\sublabel{NW4fRSrE-3QTOh1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3QTOh1-1}}}\moddef{Redefine predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-3QTOh1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RedefPredPattern}{NW4fRSrE-3QTOh1-1};
var
   K:integer;
   lArgs: TrmList;
   lPattern: PatternPtr;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noPredicate, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noPredicate].InsertExt(lPattern);
   InFile.InWord;
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   RedefAntonym := false;
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Kind := ikFrmPred;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coPredicate,PatternPtr(Items^[k])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[k])^.fFormNr = fFormNr) and
                  CheckTypes(Items^[k], lArgs)
            then
            begin
               if PatternPtr(Items^[k])^.fAntonymic then RedefAntonym := true;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[k])^.fPrimTypes.Count) then
               begin
                  gWhichOne := PatternPtr(Items^[k])^.rConstr.Nr;
                  with ConstrPtr(Constr[coPredicate].Items^[ gWhichOne])^ do
                  begin
                     gSuperfluous := dPrimLength- nPrimaries.Count;
                     GetProperties(gProperties);
                  end;
                  with gProperties do
                  begin
                     inc(nFirstArg,gSuperfluous);
                     inc(nSecondArg,gSuperfluous);
                  end;
               end;
               goto Found;
            end;
         ErrImm(112);
         Found:
            DisposeListOfTerms(lArgs);
      end;
   end;
   DisposeSubstTrm;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'R';
   with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(RedefAntonym,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{RedefPredPattern}}{RedefPredPattern}{NW4fRSrE-3QTOh1-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{RedefPredPattern}}{RedefPredPattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-3QTOh1-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-3QTOh1-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-3QTOh1-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-3QTOh1-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-3QTOh1-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-3QTOh1-1}\nwendcode{}\nwbegindocs{140}\nwdocspar
\nwenddocs{}\nwbegincode{141}\sublabel{NW4fRSrE-ZDOZa-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-ZDOZa-1}}}\moddef{Notation predicate pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-ZDOZa-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ###TODO: potential BUG here - take care of setting fKind of Patterns
//          properly - it is not clear here
procedure \nwlinkedidentc{NotatPredPattern}{NW4fRSrE-ZDOZa-1};
var
   K:integer;
   lArgs: TrmList;
   lPattern, origin: PatternPtr;
   lSynonym: boolean;
label Found1,Found2;
begin
   gRedef := true;
   InFile.InPos(CurPos); InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noPredicate, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noPredicate].InsertExt(lPattern);
   InFile.InWord;
   lSynonym := InFile.Current.Kind=ikMscSynonym;
   InFile.InPos(CurPos); InFile.InWord;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noPredicate, origin);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(origin);
   InFile.InWord;
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   RedefAntonym := false;
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   with Notat[noPredicate], origin^ do
   begin
      rConstr.Kind := ikFrmPred;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coPredicate,PatternPtr(Items^[k])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[k])^.fFormNr=fFormNr) and
                  CheckTypes(Items^[k],lArgs)
            then
            begin
               if PatternPtr(Items^[k])^.fAntonymic then RedefAntonym := true;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[k])^.fPrimTypes.Count) then
               begin
                  gWhichOne := OriginalNr(coPredicate,PatternPtr(Items^[k])^.rConstr.Nr);
                  if gWhichOne = 0 then
                     gWhichOne := PatternPtr(Items^[k])^.rConstr.Nr;
                  with ConstrPtr(Constr[coPredicate].Items^[ gWhichOne])^ do
                  begin
                     gSuperfluous := dPrimLength- nPrimaries.Count;
                     GetProperties(gProperties);
                  end;
                  with gProperties do
                  begin
                     inc(nFirstArg,gSuperfluous);
                     inc(nSecondArg,gSuperfluous);
                  end;
               end;
               goto Found2;
            end;
         ErrImm(112);
         Found2:
            DisposeListOfTerms(lArgs);
      end;
   end;
   with lPattern^, rConstr do
   begin
      Kind := ikFrmPred;
      Nr := gWhichOne;
      fAntonymic := lSynonym = RedefAntonym;
      fRedefNr :=  K+1;
   end;
   DisposeSubstTrm;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'R';
   // with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
   //  GB: To ponizej jest chyba zbyteczne bo origin nie jest teraz dopisywany do Notat[noPredicate]
   \{GB: This below is probably redundant because origin is now not added to Notat[noPredicate]\} 
   with origin^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(RedefAntonym,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{NotatPredPattern}}{NotatPredPattern}{NW4fRSrE-ZDOZa-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NotatPredPattern}}{NotatPredPattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-ZDOZa-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-ZDOZa-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-ZDOZa-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-ZDOZa-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-ZDOZa-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-ZDOZa-1}\nwendcode{}\nwbegindocs{142}\nwdocspar
\nwenddocs{}\nwbegincode{143}\sublabel{NW4fRSrE-1Nd4jW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1Nd4jW-1}}}\moddef{Insert predicate~{\nwtagstyle{}\subpageref{NW4fRSrE-1Nd4jW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertPredicate}{NW4fRSrE-1Nd4jW-1};
var
   lConstr: ConstrPtr;
   lAbsNr: integer;
begin
   lAbsNr :=  1 + Constr[coPredicate].Count - ConstrBase[coPredicate];
   with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
      lConstr := new(ConstrPtr,
                     InitForPattern(coPredicate,lAbsNr,ArticleID,fPrimTypes)); 
   lConstr^.SetProperties(gProperties);
   lConstr^.SetRedef(gWhichOne, gSuperfluous);
   gWhichOne :=  Constr[coPredicate].Count;
   Constr[coPredicate].Insert(lConstr);
   \{$IFDEF ANALYZER_REPORT\} 
   AReport.Out_Constructor(lConstr, gWhichOne);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{InsertPredicate}}{InsertPredicate}{NW4fRSrE-1Nd4jW-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InsertPredicate}}{InsertPredicate}}}\nwendcode{}\nwbegindocs{144}\nwdocspar
\nwenddocs{}\nwbegincode{145}\sublabel{NW4fRSrE-2uTf5M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2uTf5M-1}}}\moddef{Parse definition of predicate --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-2uTf5M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefPredTail}{NW4fRSrE-2uTf5M-1};
begin
   with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Nr := gWhichOne;
      fAntonymic := RedefAntonym;
   end;
end;
\nwindexdefn{\nwixident{DefPredTail}}{DefPredTail}{NW4fRSrE-2uTf5M-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefPredTail}}{DefPredTail}}}\nwendcode{}\nwbegindocs{146}\nwdocspar
\nwenddocs{}\nwbegincode{147}\sublabel{NW4fRSrE-mZ8N3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-mZ8N3-1}}}\moddef{Parse definition of attribute --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-mZ8N3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefAttrTail}{NW4fRSrE-mZ8N3-1};
begin
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Nr := gWhichOne;
      fAntonymic := RedefAntonym;
   end;
end;
\nwindexdefn{\nwixident{DefAttrTail}}{DefAttrTail}{NW4fRSrE-mZ8N3-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefAttrTail}}{DefAttrTail}}}\nwendcode{}\nwbegindocs{148}\nwdocspar
\nwenddocs{}\nwbegincode{149}\sublabel{NW4fRSrE-2NGLeB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2NGLeB-1}}}\moddef{Parse specification~{\nwtagstyle{}\subpageref{NW4fRSrE-2NGLeB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Specification}{NW4fRSrE-2NGLeB-1};
begin
   gSpecified := InFile.Current.Kind=ikMscSpecification;
   if InFile.Current.Kind = ikMscSpecification then
   begin
      gFraenkelTermAllowed := false;
      ItTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      gFraenkelTermAllowed := true;
      Infile.InWord
   end
   else ItTyp := AnyTyp^.CopyType;
end;
\nwindexdefn{\nwixident{Specification}}{Specification}{NW4fRSrE-2NGLeB-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Specification}}{Specification}}}\nwidentuses{\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-2NGLeB-1}\nwendcode{}\nwbegindocs{150}\nwdocspar
\nwenddocs{}\nwbegincode{151}\sublabel{NW4fRSrE-138Ush-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-138Ush-1}}}\moddef{Parse functor definition pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-138Ush-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefFuncPattern}{NW4fRSrE-138Ush-1};
var
   lPattern: PatternPtr;
begin
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noFunctor, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noFunctor].InsertExt(lPattern);
   InFile.InWord;
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                             rConstr.Kind := ikTrmFunctor;
   \nwlinkedidentc{Specification}{NW4fRSrE-2NGLeB-1};
   \{ InitForPattern tworzy kopie typu. \}
   \{ InitForPattern creates copies of the type.\}
   \{ Definiens tworzy kopie typu (AdjustedType), po wyrzuceniu optymalizacji
     na "Any".
   \}
   \{ Definiens creates copies of the type (AdjustedType) after rolling  
     the optimization to "Any". \}
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'K';
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
   if \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs = 'e' then
      gCorrCond[ord(syCoherence)] := \nwlinkedidentc{CoherenceEq}{NW4fRSrE-3pxze-1}
   else
   begin
      gCorrCond[ord(syExistence)] := \nwlinkedidentc{Existence}{NW4fRSrE-4TUJX-1}('K');
      gCorrCond[ord(syUniqueness)] := \nwlinkedidentc{Uniqueness}{NW4fRSrE-3FE2SD-1};
   end;
end;
\nwindexdefn{\nwixident{DefFuncPattern}}{DefFuncPattern}{NW4fRSrE-138Ush-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefFuncPattern}}{DefFuncPattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CoherenceEq}}{CoherenceEq}}\\{{\nwixident{Existence}}{Existence}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}\\{{\nwixident{Specification}}{Specification}}\\{{\nwixident{Uniqueness}}{Uniqueness}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{CoherenceEq}}{CoherenceEq}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{Existence}}{Existence}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{Specification}}{Specification}{NW4fRSrE-138Ush-1}\nwindexuse{\nwixident{Uniqueness}}{Uniqueness}{NW4fRSrE-138Ush-1}\nwendcode{}\nwbegindocs{152}\nwdocspar
\nwenddocs{}\nwbegincode{153}\sublabel{NW4fRSrE-ti2Op-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-ti2Op-1}}}\moddef{Parse redefinition specification~{\nwtagstyle{}\subpageref{NW4fRSrE-ti2Op-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure RedefSpecification(fTyp: TypPtr; Err: integer);
var
   lTyp: TypPtr;
begin
   if gWhichOne = 0 then
   begin
      \nwlinkedidentc{Specification}{NW4fRSrE-2NGLeB-1};
      exit;
   end;
   \{ Jezeli nie udalo sie zidentyfikowac redefiniowany fuktor,
     to traktujemy to jako definicje nowego funktora
   \}
   \{ If we failed to identify the redefined functor,
     we treat it as the definition of a new functor \}
   gSpecified := InFile.Current.Kind=ikMscSpecification;
   if InFile.Current.Kind=ikMscSpecification then
   begin
      ItTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      Infile.InWord;
      \{ co sie dzieje jezeli fTyp jest niepoprawny ? \}
      \{ Nic sie nie rozszerza do niepoprawnego.\}
      \{ what happens if fType is incorrect? \}
      \{Nothing expands to invalid.\}
      if ItTyp^.TypSort<>ikError then
      begin
         lTyp := fTyp^.CopyType;
         lTyp^.WithinType(\nwlinkedidentc{ChangeToConst}{NW4fRSrE-1IRHWc-1});
         if not lTyp^.IsWiderThan(ItTyp^.CopyType) then ErrImm(Err);
         dispose(lTyp,Done);
      end;
      exit;
   end;
   \{ Jezeli specyfikacja jest opuszczona to jest to typ oryginalu. \}
   \{ If the specification is omitted, this is the original type. \}
   ItTyp := fTyp^.CopyType;
   ItTyp^.WithinType(\nwlinkedidentc{ChangeToConst}{NW4fRSrE-1IRHWc-1});
end;
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentuses{\\{{\nwixident{ChangeToConst}}{ChangeToConst}}\\{{\nwixident{ReadType}}{ReadType}}\\{{\nwixident{Specification}}{Specification}}}\nwindexuse{\nwixident{ChangeToConst}}{ChangeToConst}{NW4fRSrE-ti2Op-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-ti2Op-1}\nwindexuse{\nwixident{Specification}}{Specification}{NW4fRSrE-ti2Op-1}\nwendcode{}\nwbegindocs{154}%RedefSpecification

\nwenddocs{}\nwbegincode{155}\sublabel{NW4fRSrE-3o0u5v-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3o0u5v-1}}}\moddef{Parse pattern in functor redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-3o0u5v-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RedefFuncPattern}{NW4fRSrE-3o0u5v-1};
var
   K: integer;
   lArgs: TrmList;
   lPattern: PatternPtr;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos); InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noFunctor, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noFunctor].InsertExt(lPattern);
   InFile.InWord;
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Kind := ikTrmFunctor;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coFunctor,PatternPtr(Items^[K])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[K])^.fFormNr=fFormNr) and
                  CheckTypes(Items^[K],lArgs) then
            begin
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[k])^.fPrimTypes.Count) then
               begin
                  gSuperfluous := dPrimLength-ConstrTypPtr(
                     Constr[coFunctor].Items^[PatternPtr(Items^[K])^.rConstr.Nr]
                                                          )^.nPrimaries.Count;
                  gWhichOne := PatternPtr(Items^[K])^.rConstr.Nr;
                  with ConstrTypPtr(Constr[coFunctor].Items^[gWhichOne])^ do
                     GetProperties(gProperties);
                  with gProperties do
                  begin
                     inc(nFirstArg,gSuperfluous);
                     inc(nSecondArg,gSuperfluous);
                  end;
               end;
               goto Found;
            end;
         ErrImm(113);
         Found:
            DisposeListOfTerms(lArgs);
      end;
   end;
   DisposeSubstTrm;
   RedefSpecification(ConstrTypPtr(Constr[coFunctor].Items^[gWhichOne])^.fConstrTyp,117\{,ikTrmFunctor\});
   if gWhichOne <> 0 then
   begin
      \{ Robota ponizej jest bledna. Jezeli zaokraglimy typ jako
        typ redefiniowanego funkctora, to:
        - twierdzenie definicyjne moze byc bledne (w twierdzeniu
        definicyjnym wystepuje tylko dolny klaster, wiec wlasciwie
        dowodzimy, ze jezeli cos ma (niektore) wlasnosci wyniku
        funktora (i spelnia definiens) to jest wynkiem funktora,
        a do bazy danych przekazujemy twierdzenie z opuszczeniem
        zalozenia, ze ma te wlasnosci
        - podobnie jest przy dowodzeniu wlasnosci "compatibility":
        dowodzimy rownowaznosc definiensow, przy zalozeniu, ze
        nowy definiens wyznacza funktor, pod warunkiem, ze
        redefiniowany obiekt ma pewne wlasnosci tego funktora
        - wyglada, ze podobnie jest w innych przypadkach
      
        Chyba tylko przy dowodzeniu "commutativity", mozna skorzystac,
        ze idzie o ten wlasnie funktor !!!!!!!!!!!!
      
        Dyskusja z Czeskiem, 98.03.12
      \}
      \{ The job below is wrong. If we rounded the type as
        the type of the redefined functor, then:
        - the definition theorem may be incorrect (in the definition
        theorem there is only the lower cluster, so we are actually
        proving that if something has (some) properties
        of the result of the functor (and satisfies the definiens),
        then it is the result of the functor,
        and we pass the theorem to the database leaving the
        assumption that has these properties
        - it is similar when proving the "compatibility" property:
        we prove the equivalence of definiens, assuming that
        the new definiens is determined by a functor, provided that
        the redefined object has certain properties of this functor
         - it seems to be similar in other cases
      
        I guess only when proving "commutativity" you can take advantage of the fact
        that this is the functor in question !!!!!!!!!!!!
      
         Discussion with Czech, 98/03/12\}
      
      (***   lTrm := NewFuncTrm(gWhichOne,\nwlinkedidentc{C_FormalArgs}{NW4fRSrE-qSnfu-1}(dPrimLength));
        lTypPtr := GetTrmType(lTrm);
        lClusterNr := lTypPtr^.UpperCluster;
        dispose(lTypPtr,Done); DisposeTrm(lTrm);
        lCluster.CopyAll(gClusterColl.fItems^[lClusterNr]);
        lCluster.EnlargeBy(gClusterColl.fItems^[ItTyp^.UpperCluster]);
        lCluster.RoundUpWith(ItTyp);
        ItTyp^.UpperCluster := lCluster.CollectCluster;***)
   end;
   if gSpecified then gCorrCond[ord(syCoherence)] := \nwlinkedidentc{Coherence}{NW4fRSrE-1tzT4S-1}('K');
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'K';
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
end;
\nwindexdefn{\nwixident{RedefFuncPattern}}{RedefFuncPattern}{NW4fRSrE-3o0u5v-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{RedefFuncPattern}}{RedefFuncPattern}}}\nwidentuses{\\{{\nwixident{C{\_}FormalArgs}}{C:unFormalArgs}}\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{Coherence}}{Coherence}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{C{\_}FormalArgs}}{C:unFormalArgs}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{Coherence}}{Coherence}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-3o0u5v-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-3o0u5v-1}\nwendcode{}\nwbegindocs{156}\nwdocspar
\nwenddocs{}\nwbegincode{157}\sublabel{NW4fRSrE-49kkDZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-49kkDZ-1}}}\moddef{Parse notation in functor pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-49kkDZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{NotatFuncPattern}{NW4fRSrE-49kkDZ-1};
var
   i,K: integer;
   lArgs: TrmList;
   SynonymPattern, OriginPattern: PatternPtr;
   b: integer;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noFunctor, SynonymPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(SynonymPattern);
   Notat[noFunctor].InsertExt(SynonymPattern);
   InFile.InWord;
   
   InFile.InPos(CurPos);
   InFile.InWord;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noFunctor, OriginPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(OriginPattern);
   InFile.InWord;
   
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   with OriginPattern^, Notat[noFunctor] do
   begin
      rConstr.Kind := ikTrmFunctor;
      if fFormNr <> 0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coFunctor,PatternPtr(Items^[K])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[K])^.fFormNr=fFormNr) and
                  CheckTypes(Items^[K],lArgs) then
            begin
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[K])^.fPrimTypes.Count) then
               begin
                  gSuperfluous := dPrimLength-ConstrTypPtr(
                     Constr[coFunctor].Items^[PatternPtr(Items^[K])^.rConstr.Nr]
                                                          )^.nPrimaries.Count;
                  gWhichOne := OriginalNr(coFunctor,PatternPtr(Items^[K])^.rConstr.Nr);
                  if gWhichOne = 0 then
                     gWhichOne := PatternPtr(Items^[K])^.rConstr.Nr;
                  with ConstrTypPtr(Constr[coFunctor].Items^[gWhichOne])^ do
                     GetProperties(gProperties);
                  with gProperties do
                  begin
                     inc(nFirstArg,gSuperfluous);
                     inc(nSecondArg,gSuperfluous);
                  end;
               end;
               goto Found;
            end;
         ErrImm(113);
         Found:
            DisposeListOfTerms(lArgs);
      end;
   end;
   DisposeSubstTrm;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'K';
   
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^,rConstr do
   begin
      Kind := ikTrmFunctor;
      Nr := gWhichOne;
      fRedefNr :=  K+1;
   end;
   
   // with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   with OriginPattern^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \{!GB: nie ma definiensu, ale chyba potrzebne sa pewne inicjalizacje!\}
      \{!GB: no definiens, but I guess some initializations are needed!\}
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
end;
\nwindexdefn{\nwixident{NotatFuncPattern}}{NotatFuncPattern}{NW4fRSrE-49kkDZ-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NotatFuncPattern}}{NotatFuncPattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-49kkDZ-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-49kkDZ-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-49kkDZ-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-49kkDZ-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-49kkDZ-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-49kkDZ-1}\nwendcode{}\nwbegindocs{158}\nwdocspar
\nwenddocs{}\nwbegincode{159}\sublabel{NW4fRSrE-1nPKhC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1nPKhC-1}}}\moddef{Insert functor~{\nwtagstyle{}\subpageref{NW4fRSrE-1nPKhC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertFunctor}{NW4fRSrE-1nPKhC-1};
var
   lConstr: ConstrTypPtr;
   lAbsNr: integer;
begin
   lAbsNr :=  1 + Constr[coFunctor].Count - ConstrBase[coFunctor];
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   lConstr  :=  new(ConstrTypPtr,
                    InitForPattern(coFunctor,lAbsNr,ArticleID,
                                   fPrimTypes,ItTyp));
   lConstr^.SetProperties(gProperties);
   lConstr^.SetRedef(gWhichOne, gSuperfluous);
   gWhichOne :=  Constr[coFunctor].Count;
   Constr[coFunctor].Insert(lConstr);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Constructor(lConstr, gWhichOne);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{InsertFunctor}}{InsertFunctor}{NW4fRSrE-1nPKhC-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InsertFunctor}}{InsertFunctor}}}\nwendcode{}\nwbegindocs{160}\nwdocspar
\nwenddocs{}\nwbegincode{161}\sublabel{NW4fRSrE-2BYsiX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2BYsiX-1}}}\moddef{Parse definition of functor --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-2BYsiX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefFuncTail}{NW4fRSrE-2BYsiX-1};
var
   lPattern: PatternPtr;
begin
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                             rConstr.Nr := gWhichOne;
end;
\nwindexdefn{\nwixident{DefFuncTail}}{DefFuncTail}{NW4fRSrE-2BYsiX-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefFuncTail}}{DefFuncTail}}}\nwendcode{}\nwbegindocs{162}\nwdocspar
\nwenddocs{}\nwbegincode{163}\sublabel{NW4fRSrE-11oteT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-11oteT-1}}}\moddef{Create list of loci~{\nwtagstyle{}\subpageref{NW4fRSrE-11oteT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(fLowInd,fUpInd: integer; var fTypColl: MCollection);
var
   k: integer;
begin
   fTypColl.Init(fUpInd-fLowInd+1,2);
   for k := fLowInd to fUpInd do
      fTypColl.Insert(gPrimaries[k]^.CopyType);
end;
\nwindexdefn{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-11oteT-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CreateLociList}}{CreateLociList}}}\nwendcode{}\nwbegindocs{164}\nwdocspar
\nwenddocs{}\nwbegincode{165}\sublabel{NW4fRSrE-24hAJs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-24hAJs-1}}}\moddef{Parse mode pattern in definition~{\nwtagstyle{}\subpageref{NW4fRSrE-24hAJs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefModePattern}{NW4fRSrE-24hAJs-1};
var
   lPattern: PatternPtr;
begin
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noMode, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noMode].InsertExt(lPattern);
   InFile.InWord;
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Kind := ikTypMode;
      Expansion := nil;
   end;
   \nwlinkedidentc{Specification}{NW4fRSrE-2NGLeB-1};
   \{ Po co to ??? \} \{What's this for??? \}
   if ItTyp^.TypSort=ikError then ItTyp := AnyTyp^.CopyType;
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'M';
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
   gCorrCond[ord(syExistence)] := \nwlinkedidentc{Existence}{NW4fRSrE-4TUJX-1}('M');
end;
\nwindexdefn{\nwixident{DefModePattern}}{DefModePattern}{NW4fRSrE-24hAJs-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefModePattern}}{DefModePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{Existence}}{Existence}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}\\{{\nwixident{Specification}}{Specification}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-24hAJs-1}\nwindexuse{\nwixident{Existence}}{Existence}{NW4fRSrE-24hAJs-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-24hAJs-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-24hAJs-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-24hAJs-1}\nwindexuse{\nwixident{Specification}}{Specification}{NW4fRSrE-24hAJs-1}\nwendcode{}\nwbegindocs{166}\nwdocspar
\nwenddocs{}\nwbegincode{167}\sublabel{NW4fRSrE-2hqWv9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2hqWv9-1}}}\moddef{Parse mode pattern in redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-2hqWv9-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RedefModePattern}{NW4fRSrE-2hqWv9-1};
var
   k,i: integer;
   lArgs: TrmList;
   lPattern: PatternPtr;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noMode, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noMode].InsertExt(lPattern);
   InFile.InWord;
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   gProperties.Properties := [];
   gProperties.nFirstArg := 0;
   gProperties.nSecondArg := 0;
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      Expansion := nil;
      rConstr.Kind := ikTypMode;
      if fFormNr <> 0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for k := Count-1 downto 0 do
            if (PatternPtr(Items^[k])^.fFormNr=fFormNr) and
                  (OriginalNr(coMode,PatternPtr(Items^[k])^.rConstr.Nr)=0) and
                  CheckTypes(Items^[k],lArgs) then
            begin
               if PatternPtr(Items^[k])^.Expansion <> nil then
               begin
                  ErrImm(134);
                  goto Found;
               end;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[k])^.fPrimTypes.Count) then
               begin
                  gWhichOne := PatternPtr(Items^[k])^.rConstr.Nr;
                  with ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^ do
                     gSuperfluous := dPrimLength-nPrimaries.Count;
               end;
               goto Found;
            end;
         ErrImm(114);
         Found:
            DisposeListOfTerms(lArgs);
      end;
      DisposeSubstTrm;
   end;
   RedefSpecification(ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^.fConstrTyp,118);
   \{ jaki to ma sens ????????? \} \{what does that mean????????? \}
   if ItTyp^.TypSort=ikError then
   begin
      ItTyp := AnyTyp^.CopyType;
      gWhichOne := 0;
   end;
   if gSpecified then gCorrCond[ord(syCoherence)] := \nwlinkedidentc{Coherence}{NW4fRSrE-1tzT4S-1}('M');
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'M';
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
end;
\nwindexdefn{\nwixident{RedefModePattern}}{RedefModePattern}{NW4fRSrE-2hqWv9-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{RedefModePattern}}{RedefModePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{Coherence}}{Coherence}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{Coherence}}{Coherence}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-2hqWv9-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-2hqWv9-1}\nwendcode{}\nwbegindocs{168}\nwdocspar
\nwenddocs{}\nwbegincode{169}\sublabel{NW4fRSrE-3lavOg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3lavOg-1}}}\moddef{Parse mode pattern for notation~{\nwtagstyle{}\subpageref{NW4fRSrE-3lavOg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{NotatModePattern}{NW4fRSrE-3lavOg-1};
var
   k,i: integer;
   lArgs: TrmList;
   lPattern, origin: PatternPtr;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noMode, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   InFile.InWord;
   InFile.InPos(CurPos);
   InFile.InWord;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noMode, origin);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(origin);
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   with Notat[noMode], origin^ do
   begin
      Expansion := nil;
      rConstr.Kind := ikTypMode;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for k := Count-1 downto 0 do
            if (PatternPtr(Items^[k])^.fFormNr=fFormNr) and
                  (OriginalNr(coMode,PatternPtr(Items^[k])^.rConstr.Nr)=0) and
                  CheckTypes(Items^[k],lArgs) then
            begin
               if PatternPtr(Items^[k])^.Expansion <> nil then
               begin
                  ErrImm(134);
                  goto Found;
               end;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[k])^.fPrimTypes.Count) then
               begin
                  gWhichOne := OriginalNr(coMode,PatternPtr(Items^[k])^.rConstr.Nr);
                  if gWhichOne = 0 then
                     gWhichOne := PatternPtr(Items^[k])^.rConstr.Nr;
                  with ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^ do
                     gSuperfluous := dPrimLength- nPrimaries.Count;
               end;
               goto Found;
            end;
         ErrImm(114);
         Found:
            DisposeListOfTerms(lArgs);
      end;
      DisposeSubstTrm;
   end;
   \{GB: Nie ma specyfikacji, ale moze sie przydac jakas inicjalizacja\}
   \{GB: No specification, but some initialization might be useful\}
   RedefSpecification(ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^.fConstrTyp,118);
   \{ jaki to ma sens ????????? \} \{what does that mean????????? \}
   if ItTyp^.TypSort=ikError then
   begin
      ItTyp := AnyTyp^.CopyType;
      gWhichOne := 0;
   end;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'M';
   with origin^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,ItTyp);
   end;
   Notat[noMode].InsertExt(lPattern);
   InFile.InWord;
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^, rConstr do
   begin
      Expansion := nil;
      Kind := ikTypMode;
      Nr := gWhichOne;
      fRedefNr :=  K+1;
   end;
end;
\nwindexdefn{\nwixident{NotatModePattern}}{NotatModePattern}{NW4fRSrE-3lavOg-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NotatModePattern}}{NotatModePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-3lavOg-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-3lavOg-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-3lavOg-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-3lavOg-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-3lavOg-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-3lavOg-1}\nwendcode{}\nwbegindocs{170}\nwdocspar
\nwenddocs{}\nwbegincode{171}\sublabel{NW4fRSrE-jEwY5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-jEwY5-1}}}\moddef{Insert a mode~{\nwtagstyle{}\subpageref{NW4fRSrE-jEwY5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{InsertMode}{NW4fRSrE-jEwY5-1};
var
   lConstr: ConstrTypPtr;
   lAbsNr: integer;
begin
   lAbsNr :=  1 + Constr[coMode].Count - ConstrBase[coMode];
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   lConstr := new(ConstrTypPtr,
                  InitForPattern(coMode,lAbsNr,ArticleID,fPrimTypes,ItTyp));
   lConstr^.SetProperties(gProperties);
   
   if Constr[coMode].Count>1 then \{Checking if we are not processing HIDDEN accommodated with the -h flag\}
      if (ItTyp^.TypSort = ikTypMode) and
            (sySethood in ConstrTypPtr(Constr[coMode].Items^[ItTyp^.ModNr])^.fProperties) then
         lConstr^.fProperties := lConstr^.fProperties+[sySethood]
      else if (gWhichOne <> 0) and
                 (sySethood in ConstrTypPtr(Constr[coMode].Items^[gWhichOne])^.fProperties) then
         lConstr^.fProperties := lConstr^.fProperties+[sySethood];
   lConstr^.SetRedef(gWhichOne, gSuperfluous);
   gWhichOne :=  Constr[ coMode].Count;
   Constr[ coMode].Insert(lConstr);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Constructor(lConstr, gWhichOne);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{InsertMode}}{InsertMode}{NW4fRSrE-jEwY5-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InsertMode}}{InsertMode}}}\nwendcode{}\nwbegindocs{172}\nwdocspar
\nwenddocs{}\nwbegincode{173}\sublabel{NW4fRSrE-1u93O4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1u93O4-1}}}\moddef{Parse definition of an expandable mode~{\nwtagstyle{}\subpageref{NW4fRSrE-1u93O4-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefExpandableMode}{NW4fRSrE-1u93O4-1};
var
   lPattern: PatternPtr;
begin
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noMode, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noMode].InsertExt(lPattern);
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^, rConstr do
   begin
      Kind := ikTypMode;
      Nr := 0;
      Expansion := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      if Expansion^.TypSort=ikError then Expansion := AnyTyp^.CopyType;
      Infile.InWord;
      Expansion^.WithinType(ChangeToLoci);
   end;
end;
\nwindexdefn{\nwixident{DefExpandableMode}}{DefExpandableMode}{NW4fRSrE-1u93O4-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefExpandableMode}}{DefExpandableMode}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-1u93O4-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-1u93O4-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-1u93O4-1}\nwendcode{}\nwbegindocs{174}\nwdocspar
\nwenddocs{}\nwbegincode{175}\sublabel{NW4fRSrE-45Cbij-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-45Cbij-1}}}\moddef{Parse predicate or attribute pattern in definition~{\nwtagstyle{}\subpageref{NW4fRSrE-45Cbij-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefPredAttributePattern}{NW4fRSrE-45Cbij-1};
var
   lPattern: PatternPtr;
begin
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noAttribute, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noAttribute].InsertExt(lPattern);
   InFile.InWord;
   RedefAntonym := false;
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Kind := ikFrmAttr;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'V';
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(false,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{DefPredAttributePattern}}{DefPredAttributePattern}{NW4fRSrE-45Cbij-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefPredAttributePattern}}{DefPredAttributePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-45Cbij-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-45Cbij-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-45Cbij-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-45Cbij-1}\nwendcode{}\nwbegindocs{176}\nwdocspar
\nwenddocs{}\nwbegincode{177}\sublabel{NW4fRSrE-2VOwe7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2VOwe7-1}}}\moddef{Parse pattern for predicate or attribute redefinition~{\nwtagstyle{}\subpageref{NW4fRSrE-2VOwe7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RedefPredAttributePattern}{NW4fRSrE-2VOwe7-1};
var
   k,i: integer;
   lArgs: TrmList;
   lPattern: PatternPtr;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos); InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noAttribute, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noAttribute].InsertExt(lPattern);
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   InFile.InWord;
   RedefAntonym := false;
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      rConstr.Kind := ikFrmAttr;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Positive := true;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coAttribute,PatternPtr(Items^[K])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[K])^.fFormNr=fFormNr) and
                  CheckTypes(Items^[k],lArgs) then
            begin
               if PatternPtr(Items^[K])^.fAntonymic then RedefAntonym := true;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[K])^.fPrimTypes.Count) then
               begin
                  gSuperfluous := dPrimLength-ConstrTypPtr(
                     Constr[ coAttribute].Items^[PatternPtr(Items^[K])^.rConstr.Nr]
                                                          )^.nPrimaries.Count;
                  gWhichOne := PatternPtr(Items^[K])^.rConstr.Nr;
                  \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Positive := not PatternPtr(Items^[K])^.fAntonymic;
               end;
               goto Found
            end;
         ErrImm(115);
         Found:
            DisposeListOfTerms(lArgs);
      end;
   end;
   DisposeSubstTrm;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'V';
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(RedefAntonym,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{RedefPredAttributePattern}}{RedefPredAttributePattern}{NW4fRSrE-2VOwe7-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{RedefPredAttributePattern}}{RedefPredAttributePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-2VOwe7-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-2VOwe7-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-2VOwe7-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-2VOwe7-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-2VOwe7-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-2VOwe7-1}\nwendcode{}\nwbegindocs{178}\nwdocspar
\nwenddocs{}\nwbegincode{179}\sublabel{NW4fRSrE-3AWSsC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3AWSsC-1}}}\moddef{Parse notation in a predicate or attribute pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-3AWSsC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{NotatPredAttributePattern}{NW4fRSrE-3AWSsC-1};
var
   k,i: integer;
   lArgs: TrmList;
   SynonymPattern, OriginPattern: PatternPtr;
   Antonymic, lSynonym: boolean;
label Found;
begin
   gRedef := true;
   InFile.InPos(CurPos);
   InFile.InWord;
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noAttribute, SynonymPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(SynonymPattern);
   Notat[noAttribute].InsertExt(SynonymPattern);

   InFile.InWord;
   lSynonym := InFile.Current.Kind = ikMscSynonym;
   InFile.InWord;
   InFile.InPos(CurPos); InFile.InWord;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noAttribute, OriginPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(OriginPattern);
   
   fillchar(gSubstTrm,sizeof(gSubstTrm),0);
   InFile.InWord;
   RedefAntonym := false;
   with Notat[noAttribute], OriginPattern^ do
   begin
      rConstr.Kind := ikFrmAttr;
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Positive := true;
      if fFormNr<>0 then
      begin
         lArgs := \nwlinkedidentc{CreateConstList}{NW4fRSrE-a1Spe-1}(Visible);
         for K := Count-1 downto 0 do
            if (OriginalNr(coAttribute,PatternPtr(Items^[K])^.rConstr.Nr)=0) and
                  (PatternPtr(Items^[K])^.fFormNr=fFormNr) and
                  CheckTypes(Items^[k],lArgs) then
            begin
               if PatternPtr(Items^[K])^.fAntonymic then RedefAntonym := true;
               if \nwlinkedidentc{CompatibleArgs}{NW4fRSrE-4KFoj-1}(PatternPtr(Items^[K])^.fPrimTypes.Count) then
               begin
                  gSuperfluous := dPrimLength-ConstrTypPtr(
                     Constr[ coAttribute].Items^[PatternPtr(Items^[K])^.rConstr.Nr]
                                                          )^.nPrimaries.Count;
                  gWhichOne := OriginalNr(coAttribute,PatternPtr(Items^[K])^.rConstr.Nr);
                  if gWhichOne = 0 then
                     gWhichOne := PatternPtr(Items^[K])^.rConstr.Nr;
                  \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Positive :=  not PatternPtr(Items^[K])^.fAntonymic;
               end;
               goto Found
            end;
         ErrImm(115);
         Found:
            DisposeListOfTerms(lArgs);
      end;
   end;
   DisposeSubstTrm;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := 'V';
   with SynonymPattern^, rConstr do
   begin
      Kind := ikFrmAttr;
      Nr := gWhichOne;
      fRedefNr :=  K+1;
      fAntonymic := lSynonym = RedefAntonym;
  end;
   with OriginPattern^ do
   begin
      \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Length := fPrimTypes.Count;
      \nwlinkedidentc{ReadDefiniens}{NW4fRSrE-2xdcsX-1}(RedefAntonym,fPrimTypes,nil);
   end;
end;
\nwindexdefn{\nwixident{NotatPredAttributePattern}}{NotatPredAttributePattern}{NW4fRSrE-3AWSsC-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NotatPredAttributePattern}}{NotatPredAttributePattern}}}\nwidentuses{\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CompatibleArgs}}{CompatibleArgs}}\\{{\nwixident{CreateConstList}}{CreateConstList}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{ReadDefiniens}}{ReadDefiniens}}}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-3AWSsC-1}\nwindexuse{\nwixident{CompatibleArgs}}{CompatibleArgs}{NW4fRSrE-3AWSsC-1}\nwindexuse{\nwixident{CreateConstList}}{CreateConstList}{NW4fRSrE-3AWSsC-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-3AWSsC-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-3AWSsC-1}\nwindexuse{\nwixident{ReadDefiniens}}{ReadDefiniens}{NW4fRSrE-3AWSsC-1}\nwendcode{}\nwbegindocs{180}\nwdocspar
\nwenddocs{}\nwbegincode{181}\sublabel{NW4fRSrE-1gwegT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1gwegT-1}}}\moddef{Insert predicate or attribute~{\nwtagstyle{}\subpageref{NW4fRSrE-1gwegT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ##NOTE: the Abstract property is by default false
procedure \nwlinkedidentc{InsertPredAttribute}{NW4fRSrE-1gwegT-1};
var
   lTypPtr: TypPtr;
   lConstr: ConstrTypPtr;
   lAbsNr: integer;
begin
   lAbsNr :=  1 + Constr[coAttribute].Count - ConstrBase[coAttribute];
   if gPrimNbr > 0 then lTypPtr := gPrimaries[gPrimNbr]^.CopyType
   else lTypPtr := NewIncorTyp;
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   lConstr :=  new(ConstrTypPtr,
                   InitForPattern(coAttribute,lAbsNr,ArticleID,
                                  fPrimTypes,lTypPtr));
   lConstr^.SetRedef(gWhichOne, gSuperfluous);
   gWhichOne :=  Constr[coAttribute].Count;
   Constr[coAttribute].Insert(lConstr);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Constructor(lConstr, gWhichOne);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{InsertPredAttribute}}{InsertPredAttribute}{NW4fRSrE-1gwegT-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{InsertPredAttribute}}{InsertPredAttribute}}}\nwendcode{}\nwbegindocs{182}\nwdocspar
\nwenddocs{}\nwbegincode{183}\sublabel{NW4fRSrE-3mJ75Q-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3mJ75Q-1}}}\moddef{Analyze cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-3mJ75Q-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}(const fList: MCollection;
                         var fAttrs: MCollection;
                         fTyp:TypPtr);
var
   lAttr: AttrPtr;
   lTyp: TypPtr;
   z: integer;
begin
   lTyp := fTyp^.CopyType;
   fAttrs.Init(0,10);
   with fList do
      for z := Count-1 downto 0 do
      begin
         lAttr := AnalyzeAttribute(AttrNodePtr(Items^[z]),lTyp);
         if lAttr = nil then
         begin
            if (lTyp^.TypSort<>ikTypError) and (AttrNodePtr(Items^[z])^.nInt<>0) then
               Error(AttrNodePtr(Items^[z])^.nPos,115);
            exit;
         end;
         if AttrNodePtr(Items^[z])^.nNeg then
            if lAttr^.fNeg = 0 then
               lAttr^.fNeg := 0
            else lAttr^.fNeg := 1
            else if lAttr^.fNeg = 0 then
               lAttr^.fNeg := 1
            else lAttr^.fNeg := 0;
         //  lTyp^.LowerCluster^.Insert(lAttr^.CopyAttribute);
         if not lTyp^.LowerCluster^.fConsistent then
         begin
            Error(AttrNodePtr(Items^[z])^.nPos,95);
            lTyp^.TypSort := ikError;
            dispose(lTyp,Done);
            dispose(lAttr,Done); //!!
            exit
         end;
         //  lTyp^.UpperCluster^.Insert(lAttr^.CopyAttribute);
         //  lTyp^.RoundUp;
         //  fAttrs.Insert(lAttr);
         fAttrs.AtInsert(0,lAttr);
      end;
   dispose(lTyp,Done);
end;
\nwindexdefn{\nwixident{AnalyzeCluster}}{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AnalyzeCluster}}{AnalyzeCluster}}}\nwendcode{}\nwbegindocs{184}\nwdocspar
\nwenddocs{}\nwbegincode{185}\sublabel{NW4fRSrE-3yW3eS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3yW3eS-1}}}\moddef{Add items to a cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-3yW3eS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AddToCluster}{NW4fRSrE-3yW3eS-1}(var fList: MList; fCluster: AttrCollectionPtr);
var
   lAttr: AttrPtr;
   z: integer;
begin
   with fList do
      for z := 0 to Count-1 do
         fCluster^.Insert(Items^[z]);
   if not fCluster^.fConsistent then ErrImm(95);
   fList.DeleteAll;
   fList.Done;
end;
\nwindexdefn{\nwixident{AddToCluster}}{AddToCluster}{NW4fRSrE-3yW3eS-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AddToCluster}}{AddToCluster}}}\nwendcode{}\nwbegindocs{186}\nwdocspar
\nwenddocs{}\nwbegincode{187}\sublabel{NW4fRSrE-sMl51-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-sMl51-1}}}\moddef{Define existential cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-sMl51-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefExistentialCluster}{NW4fRSrE-sMl51-1};
var
   lTyp,llTyp: TypPtr;
   lList: MCollection;
   lClusterPtr: AttrCollectionPtr;
   lAttrFrm: AttributiveFormula;
   lFrm: FrmPtr;
   lTypList,lAttrs: MCollection;
   lAbsNr: integer;
   lErrorOcc: boolean;
begin
   lErrorOcc := false;
   InFile.InPos(CurPos);
   LoadIPNColl(lList);
   lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
   Infile.InWord;
   llTyp := AdjustedType(lTyp);
   BoundVarNbr := 1;
   BoundVar[1] := lTyp;
   lAttrFrm.Init(ikFrmAttr,new(SimpleTermPtr, Init('B',1)),CurPos,lList);
   lFrm := lAttrFrm.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   lClusterPtr := CopyCluster(llTyp^.LowerCluster);
   \nwlinkedidentc{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}(lList,lAttrs,lTyp);
   \nwlinkedidentc{AddToCluster}{NW4fRSrE-3yW3eS-1}(lAttrs,lClusterPtr);
   gCorrCond[ord(syExistence)] := NewNegDis(NewUniv(lTyp,NewNegDis(lFrm)));
   lAttrFrm.Done;
   \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   \nwlinkedidentc{InitLociForCluster}{NW4fRSrE-1W2kMW-1}(lClusterPtr);
   if not \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1}(lTypList,llTyp) then
   begin
      dispose(lClusterPtr,Done);
      lTypList.Done;
      BoundVarNbr := 0;
      lErrorOcc := true;
      ErrImm(100);
   end;
   if (llTyp^.TypSort = ikError) or gConstInExportableItemOcc then lErrorOcc := true;
   if not lErrorOcc then
   begin
      lAbsNr :=  1 + RegisteredCluster.Count +  RegisteredCluster.fExtCount - RegClusterBase;
      RegisteredCluster.InsertExt(new(RClusterPtr,
                                      RegisterCluster(lAbsNr,ArticleID,lClusterPtr,lTypList,llTyp)));
      \{$IFDEF ANALYZER_REPORT\}
      with RegisteredCluster do
         AReport.Out_RCluster(Items^[Count+fExtCount-1]);
      \{$ENDIF\}
   end
   else
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_ErrCluster(elRCluster);
      \{$ENDIF\}
   end;
   dispose(llTyp,Done);
   \{ implementacje nalezy poprawic, typ jest dwukrotnie
     adjustowany
   \}
   \{ implementations need to be improved, type is twice
      adjusted
    \}
   BoundVarNbr := 0;
end;
\nwindexdefn{\nwixident{DefExistentialCluster}}{DefExistentialCluster}{NW4fRSrE-sMl51-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefExistentialCluster}}{DefExistentialCluster}}}\nwidentuses{\\{{\nwixident{AddToCluster}}{AddToCluster}}\\{{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}}\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{AnalyzeCluster}}{AnalyzeCluster}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{InitLociForCluster}}{InitLociForCluster}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{AddToCluster}}{AddToCluster}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{AnalyzeCluster}}{AnalyzeCluster}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{InitLociForCluster}}{InitLociForCluster}{NW4fRSrE-sMl51-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-sMl51-1}\nwendcode{}\nwbegindocs{188}\nwdocspar
\nwenddocs{}\nwbegincode{189}\sublabel{NW4fRSrE-1gUvy2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1gUvy2-1}}}\moddef{Define conditional cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-1gUvy2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefConditionalCluster}{NW4fRSrE-1gUvy2-1};
var
   lTyp,llTyp: TypPtr;
   lList,lList1: MCollection;
   lClusterPtr,lClusterPtr1: AttrCollectionPtr;
   lAttrFrm1,lAttrFrm: AttributiveFormula;
   lFrm,lFrm1: FrmPtr;
   lTypList,lAttrs1,lAttrs2: MCollection;
   lAbsNr: integer;
   lErrorOcc: boolean;
begin
   lErrorOcc := false;
   InFile.InPos(CurPos);
   LoadIPNColl(lList);
   LoadIPNColl(lList1);
   lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
   llTyp := AdjustedType(lTyp);
   lClusterPtr := CopyCluster(llTyp^.LowerCluster);
   \nwlinkedidentc{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}(lList,lAttrs1,lTyp);
   \nwlinkedidentc{AddToCluster}{NW4fRSrE-3yW3eS-1}(lAttrs1,lClusterPtr);
   lClusterPtr1 := CopyCluster(llTyp^.LowerCluster);
   \nwlinkedidentc{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}(lList1,lAttrs2,lTyp);
   \nwlinkedidentc{AddToCluster}{NW4fRSrE-3yW3eS-1}(lAttrs2,lClusterPtr1);
   BoundVarNbr := 1;
   BoundVar[1] := lTyp;
   lAttrFrm.Init(ikFrmAttr,new(SimpleTermPtr, Init('B',1)),CurPos,lList);
   lFrm := lAttrFrm.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   lAttrFrm.Done;
   lAttrFrm1.Init(ikFrmAttr,new(SimpleTermPtr, Init('B',1)),CurPos,lList1);
   lFrm1 := lAttrFrm1.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   lAttrFrm1.Done;
   gCorrCond[ord(syCoherence)] := NewUniv(lTyp,NewImpl(lFrm,lFrm1));
   dispose(llTyp^.LowerCluster,Done);
   llTyp^.LowerCluster := NewEmptyCluster;
   dispose(llTyp^.UpperCluster,Done);
   llTyp^.UpperCluster := NewEmptyCluster;
   \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   \nwlinkedidentc{InitLociForCluster}{NW4fRSrE-1W2kMW-1}(lClusterPtr);
   if not \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1}(lTypList,llTyp) then
   begin
      dispose(lClusterPtr,Done);
      dispose(lClusterPtr1,Done);
      lTypList.Done;
      lErrorOcc := true;
      ErrImm(100);
   end;
   if (llTyp^.TypSort = ikError) or gConstInExportableItemOcc then lErrorOcc := true;
   if not lErrorOcc then
   begin
      lAbsNr :=  1 + ConditionalCluster.Count + ConditionalCluster.fExtCount - CondClusterBase;
      ConditionalCluster.InsertExt(new(CClusterPtr,
                                       RegisterCluster(lAbsNr,ArticleID,lClusterPtr,lClusterPtr1,lTypList,llTyp)));
      \{$IFDEF ANALYZER_REPORT\}
      with ConditionalCluster do
         AReport.Out_CCluster(ConditionalCluster.Items^[Count+fExtCount-1]);
      \{$ENDIF\}
   end
   else
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_ErrCluster(elCCluster);
      \{$ENDIF\}
   end;
   Infile.InWord;
   dispose(llTyp,Done);
   BoundVarNbr := 0;
end;
\nwindexdefn{\nwixident{DefConditionalCluster}}{DefConditionalCluster}{NW4fRSrE-1gUvy2-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefConditionalCluster}}{DefConditionalCluster}}}\nwidentuses{\\{{\nwixident{AddToCluster}}{AddToCluster}}\\{{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}}\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{AnalyzeCluster}}{AnalyzeCluster}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{InitLociForCluster}}{InitLociForCluster}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{AddToCluster}}{AddToCluster}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{AnalyzeCluster}}{AnalyzeCluster}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{InitLociForCluster}}{InitLociForCluster}{NW4fRSrE-1gUvy2-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-1gUvy2-1}\nwendcode{}\nwbegindocs{190}\nwdocspar
\nwenddocs{}\nwbegincode{191}\sublabel{NW4fRSrE-mgVCP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-mgVCP-1}}}\moddef{Define functorial cluster~{\nwtagstyle{}\subpageref{NW4fRSrE-mgVCP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefFunctorCluster}{NW4fRSrE-mgVCP-1};
var
   lTerm: ExpPtr;
   lAttrFrm: AttributiveFormula;
   lFrm,lFrm1: FrmPtr;
   lClusterPtr: AttrCollectionPtr;
   lTrm,llTrm:TrmPtr;
   lTyp,llTyp: TypPtr;
   lList,lAttrs,lConjuncts,lTypList: MCollection;
   A: TrmList;
   lFuncNr,lAbsNr,zz,z,i: integer;
   lErrorOcc: boolean;
begin
   lErrorOcc := false;
   InFile.InPos(CurPos); BoundVarNbr := 0;
   lTerm := LoadTerm;
   lTrm := lTerm^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   dispose(lTerm,Done);
   if not (lTrm^.TrmSort in [ikTrmFunctor,ikTrmSelector,ikTrmAggreg,ikTrmError]) then
   begin
      ErrImm(96);
      lErrorOcc := true;
      dispose(lTrm,Done);
      lTrm := NewInCorTrm;
   end;
   if lTrm^.TrmSort = ikTrmFunctor then
   begin
      AdjustTrm(lTrm,lFuncNr,A);
      llTrm := NewFuncTrm(lFuncNr,CopyTermList(A));
      //   llTrm^.nPattNr := lTrm^.nPattNr;
   end
   else llTrm := CopyTerm(lTrm);
   LoadIPNColl(lList);
   InFile.InWord;
   llTyp := nil;
   if InFile.Current.Kind = '.' then
   begin
      llTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      if llTyp^.TypSort = ikError then
      begin
         llTyp := nil;
         lTyp := GetTrmType(llTrm);
      end
      else lTyp := llTyp^.CopyType;
      InFile.InWord;
   end
   else lTyp := GetTrmType(llTrm);
   lClusterPtr := CopyCluster(lTyp^.LowerCluster);
   \nwlinkedidentc{AnalyzeCluster}{NW4fRSrE-3mJ75Q-1}(lList,lAttrs,lTyp);
   if llTyp <> nil then
   begin
\{-----\\/----- EXCLUDED -----\\/----- EnlargeBy does not seem to work properly!!!
   lTyp.LowerCluster.EnlargeBy(@lAttrs);
   lTyp.UpperCluster.EnlargeBy(lTyp.LowerCluster);
 -----/\\----- EXCLUDED -----/\\-----\}
\{    for zz := 0 to lAttrs.Count-1 do
       begin
          lTyp.LowerCluster.Insert(AttrPtr(lAttrs.Items^[zz])^.CopyAttribute);
          lTyp.UpperCluster.Insert(AttrPtr(lAttrs.Items^[zz])^.CopyAttribute);
       end;
   gCorrCond[ord(syCoherence)] := NewQualFrm(lTrm,lTyp);\}
      BoundVarNbr := 1;
      BoundVar[1] := lTyp;
      lFrm := NewEqFrm(NewVarTrm(ikTrmBound,1),CopyTerm(lTrm));
      lConjuncts.Init(lAttrs.Count,2);
      with lAttrs do
         for z := 0 to Count-1 do
            with AttrPtr(Items^[z])^ do
         begin
            lFrm1 := NewPredFrm(ikFrmAttr,fAttrNr,
                                AddToTrmList(CopyTermList(fAttrArgs),
                                             NewVarTrm(ikTrmBound,1)),0);
            if fNeg = 0 then
               lFrm1 := NewNeg(lFrm1);
            lConjuncts.Insert(lFrm1);
         end;
      gCorrCond[ord(syCoherence)] := NewUniv(lTyp^.CopyType,
                                             NewImpl(lFrm,NewConjFrm(lConjuncts)));
      BoundVarNbr := 0;
   end
   else
   begin
      dispose(lTyp,Done);
      lConjuncts.Init(lAttrs.Count,2);
      with lAttrs do
         for z := 0 to Count-1 do
            with AttrPtr(Items^[z])^ do
         begin
            lFrm := NewPredFrm(ikFrmAttr,fAttrNr,
                               AddToTrmList(CopyTermList(fAttrArgs),CopyTerm(lTrm)),0);
            if fNeg = 0 then
               lFrm := NewNeg(lFrm);
            lConjuncts.Insert(lFrm);
         end;
      DisposeTrm(lTrm);
      gCorrCond[ord(syCoherence)] := NewConjFrm(lConjuncts);
   end;
   \nwlinkedidentc{AddToCluster}{NW4fRSrE-3yW3eS-1}(lAttrs,lClusterPtr);
   \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   if not \nwlinkedidentc{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1}(lTypList,llTrm) then
   begin
      dispose(lClusterPtr,Done);
      lTypList.Done;
      lErrorOcc := true;
      ErrImm(100);
   end;
   if (llTrm^.TrmSort = ikError) or gConstInExportableItemOcc then lErrorOcc := true;
   if not lErrorOcc then
   begin
      lAbsNr :=  1 + FunctorCluster.Count +  FunctorCluster.fExtCount - FuncClusterBase;
      // ##TODO: since Preparator makes use of the cluster immediately,
      //         this should rather be normal Insert. Any problem with that?
      FunctorCluster.InsertExt(new(FClusterPtr,
                                   RegisterCluster(lAbsNr,ArticleID,lClusterPtr,lTypList,llTrm,llTyp)));
      \{$IFDEF ANALYZER_REPORT\}
      with FunctorCluster do
         AReport.Out_FCluster(FunctorCluster.Items^[Count+fExtCount-1]);
      \{$ENDIF\}
   end
   else
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_ErrCluster(elFCluster);
      \{$ENDIF\}
   end;
   DisposeTrm(llTrm);
   if llTyp<> nil
   then dispose(llTyp,Done);
end;
\nwindexdefn{\nwixident{DefFunctorCluster}}{DefFunctorCluster}{NW4fRSrE-mgVCP-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefFunctorCluster}}{DefFunctorCluster}}}\nwidentuses{\\{{\nwixident{AddToCluster}}{AddToCluster}}\\{{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}}\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{AnalyzeCluster}}{AnalyzeCluster}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{AddToCluster}}{AddToCluster}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{AnalyzeCluster}}{AnalyzeCluster}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-mgVCP-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-mgVCP-1}\nwendcode{}\nwbegindocs{192}\nwdocspar
\nwenddocs{}\nwbegincode{193}\sublabel{NW4fRSrE-1MmOtr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1MmOtr-1}}}\moddef{Collect loci~{\nwtagstyle{}\subpageref{NW4fRSrE-1MmOtr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{gLociSet}{NW4fRSrE-1MmOtr-1}: NatSet;
procedure \nwlinkedidentc{CollectLoci}{NW4fRSrE-1MmOtr-1}(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      if TrmSort = ikTrmLocus then \nwlinkedidentc{gLociSet}{NW4fRSrE-1MmOtr-1}.InsertElem(VarNr);
end;
\nwindexdefn{\nwixident{gLociSet}}{gLociSet}{NW4fRSrE-1MmOtr-1}\nwindexdefn{\nwixident{CollectLoci}}{CollectLoci}{NW4fRSrE-1MmOtr-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{CollectLoci}}{CollectLoci}}\\{{\nwixident{gLociSet}}{gLociSet}}}\nwendcode{}\nwbegindocs{194}\nwdocspar
\nwenddocs{}\nwbegincode{195}\sublabel{NW4fRSrE-1yastl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1yastl-1}}}\moddef{Find pattern~{\nwtagstyle{}\subpageref{NW4fRSrE-1yastl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{FindPattern}{NW4fRSrE-1yastl-1}(aKind: char; var aIdData: \nwlinkedidentc{_IdentifyData}{NW4fRSrE-1yastl-1});
var
   i,k,lFormNr,lConstrNr,lPattNr: integer;
   lAntonymic: boolean;
   lArgs, lTrmList: TrmList;
   lTyp: TypPtr;
   lVisible: IntSequence;
label Found;
begin
   with aIdData do
   begin
      Err := false;
      \nwlinkedidentc{ReadPattern}{NW4fRSrE-2CtgW3-1}(lFormNr,lVisible);
      VisibleCnt := lVisible.fCount;
      if lFormNr = 0 then Err := true;
      for k := 0 to lVisible.fCount-1 do
         if lVisible.fList^[k] = 0 then Err := true;
      InFile.InWord;
      with Notat[NotatKind(aKind)]  do
      begin
         lConstrNr := 0;
         fillchar(gSubstTrm,sizeof(gSubstTrm),0);
         lAntonymic := false;
         if lFormNr <> 0 then
         begin
            lArgs := \nwlinkedidentc{CreateTrmList}{NW4fRSrE-2ffINP-1}(lVisible);
            if lArgs <> InCorrTrmList then
            begin
               for k := Count-1 downto 0 do
                  if (PatternPtr(Items^[k])^.fFormNr = lFormNr) and
                        CheckTypes(Items^[k],lArgs) then
                  begin
                     lConstrNr := PatternPtr(Items^[k])^.rConstr.Nr;
                     lAntonymic := PatternPtr(Items^[k])^.fAntonymic;
                     lPattNr := k;
                     goto Found;
                  end;
               ErrImm(113);
            end;
            Err := true;
            Found:
               DisposeListOfTerms(lArgs);
         end;
         /// the set all loci accessible from visible arguments
         \nwlinkedidentc{gLociSet}{NW4fRSrE-1MmOtr-1}.Init(0,MaxArgNbr);
         for k := 0 to lVisible.fCount-1 do
            if lVisible.fList^[k] <> 0 then
            begin
               \nwlinkedidentc{gLociSet}{NW4fRSrE-1MmOtr-1}.InsertElem(lVisible.fList^[k]);
               gPrimaries[lVisible.fList^[k]-gDefBase]^.WithinType(\nwlinkedidentc{CollectLoci}{NW4fRSrE-1MmOtr-1});
            end;
         ArgsSet.MoveNatSet(\nwlinkedidentc{gLociSet}{NW4fRSrE-1MmOtr-1});
         lVisible.Done;
         // the Pattern
         lTrmList := CreateArgList1;
         case aKind of
            ikTrmFunctor: Pattern := NewFuncTrm(lConstrNr,lTrmList);
            ikFrmPred:
               begin
                  Pattern := NewPredFrm(ikFrmPred,lConstrNr,lTrmList,1+lPattNr);
                  if lAntonymic then Pattern := NewNeg(FrmPtr(Pattern));
               end;
            ikFrmAttr:
               begin
                  Pattern := NewPredFrm(ikFrmAttr,lConstrNr,lTrmList,1+lPattNr);
                  if lAntonymic then Pattern := NewNeg(FrmPtr(Pattern));
               end;
         end;
      end;
   end;
end;
\nwindexdefn{\nwixident{{\_}IdentifyData}}{:unIdentifyData}{NW4fRSrE-1yastl-1}\nwindexdefn{\nwixident{FindPattern}}{FindPattern}{NW4fRSrE-1yastl-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{{\_}IdentifyData}}{:unIdentifyData}}\\{{\nwixident{FindPattern}}{FindPattern}}}\nwidentuses{\\{{\nwixident{CollectLoci}}{CollectLoci}}\\{{\nwixident{CreateTrmList}}{CreateTrmList}}\\{{\nwixident{gLociSet}}{gLociSet}}\\{{\nwixident{ReadPattern}}{ReadPattern}}}\nwindexuse{\nwixident{CollectLoci}}{CollectLoci}{NW4fRSrE-1yastl-1}\nwindexuse{\nwixident{CreateTrmList}}{CreateTrmList}{NW4fRSrE-1yastl-1}\nwindexuse{\nwixident{gLociSet}}{gLociSet}{NW4fRSrE-1yastl-1}\nwindexuse{\nwixident{ReadPattern}}{ReadPattern}{NW4fRSrE-1yastl-1}\nwendcode{}\nwbegindocs{196}\nwdocspar
\nwenddocs{}\nwbegincode{197}\sublabel{NW4fRSrE-4eg3tM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4eg3tM-1}}}\moddef{Define reduction~{\nwtagstyle{}\subpageref{NW4fRSrE-4eg3tM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefReduction}{NW4fRSrE-4eg3tM-1};
var
   lTerm1,lTerm2: ExpPtr;
   lTrm1,lTrm2: TrmPtr;
   lTypList: MCollection;
   lAbsNr: integer;
   lErrorOcc: boolean;
   lPos,lTermPos: Position;
   lReduction: ReductionPtr;
begin
   lErrorOcc := false;
   InFile.InPos(CurPos);
   BoundVarNbr := 0; // po co?
   lTerm1 := LoadTerm;
   lTerm2 := LoadTerm;
   lTrm1 := lTerm1^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   lTrm2 := lTerm2^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   lTermPos := CurPos;
   \{$IFDEF MDEBUG\}
   InfoString('Reduction Start'); InfoNewLine;
   InfoTerm(lTrm1); InfoNewLine;
   InfoTerm(lTrm2); InfoNewLine;
   InfoString('Reduction End'); InfoNewLine;
   \{$ENDIF\}
   dispose(lTerm1,Done);
   dispose(lTerm2,Done);
   if not ReductionAllowed(lTrm1,lTrm2) then
   begin
      ErrImm(257);
      lErrorOcc := true;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elReduction); 
      AReport.Out_XAttr(atAid, ArticleID);
      AReport.Out_XIntAttr(atNr, 0);
      AReport.Out_XAttrEnd; 
      AReport.Out_XEl1(elErrorReduction);
      AReport.Out_XElEnd(elReduction);
      \{$ENDIF\}
   end;  
   InFile.InWord; InFile.InPos(lPos);
   gCorrCond[ord(syReducibility)] := NewIncorFrm;
   if lErrorOcc then exit;
   \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   if not \nwlinkedidentc{AllLociAccessibleInTrm}{NW4fRSrE-38WzsA-1}(lTypList,lTrm1) then Error(lTermPos,100);
   gCorrCond[ord(syReducibility)] := NewEqFrm(CopyTerm(lTrm1),CopyTerm(lTrm2));
   WithinTerm(lTrm1,ChangeToLoci);
   WithinTerm(lTrm2,ChangeToLoci);
   lReduction := new(ReductionPtr,
                             Init(1+gReductions.Count, ArticleID,
                                  lTypList,lTrm1,lTrm2));
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Reduction(lReduction);
   \{$ENDIF\}
   gReductions.Insert(lReduction);
end;
\nwindexdefn{\nwixident{DefReduction}}{DefReduction}{NW4fRSrE-4eg3tM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefReduction}}{DefReduction}}}\nwidentuses{\\{{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}}\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{InitAccess}}{InitAccess}}}\nwindexuse{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}{NW4fRSrE-4eg3tM-1}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-4eg3tM-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-4eg3tM-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-4eg3tM-1}\nwendcode{}\nwbegindocs{198}\nwdocspar
\nwenddocs{}\nwbegincode{199}\sublabel{NW4fRSrE-2RxeIl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2RxeIl-1}}}\moddef{Define identify~{\nwtagstyle{}\subpageref{NW4fRSrE-2RxeIl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefIdentify}{NW4fRSrE-2RxeIl-1}(aKind: char);
var
   k,lNr,rNr: integer;
   lId, rId: \nwlinkedidentc{_IdentifyData}{NW4fRSrE-1yastl-1};
   lEqArgs: IntRel;
   lConjuncts: MCollection;
   lFrm: FrmPtr;
   lAllArgsSet,ldSet,rdSet,lCommonArgs,lArgs: NatSet;
   lIdentify: IdentifyPtr;
   lErrIdentify: boolean;
   lTypList: MCollection;
   lIdPattern,rIdPattern:ExprPtr;
begin
   lErrIdentify := false;
   InFile.InPos(CurPos); InFile.InWord;
   \nwlinkedidentc{FindPattern}{NW4fRSrE-1yastl-1}(aKind,lId);
   if lId.Err then lErrIdentify := true;
   \nwlinkedidentc{FindPattern}{NW4fRSrE-1yastl-1}(aKind,rId);
   if rId.Err then lErrIdentify := true;
   lAllArgsSet.CopyNatSet(lId.ArgsSet);
   lAllArgsSet.EnlargeBy(rId.ArgsSet);
   for k := dPrimLength-lAllArgsSet.Count downto 1 do
   begin ErrImm(100); lErrIdentify := true end;
   lAllArgsSet.Done;
   lCommonArgs.CopyNatSet(lId.ArgsSet);
   lCommonArgs.IntersectWith(rId.ArgsSet);
   //  Left pattern and right pattern arguments
   ldSet.CopyNatSet(lId.ArgsSet); ldSet.ComplementOf(rId.ArgsSet);
   rdSet.CopyNatSet(rId.ArgsSet); rdSet.ComplementOf(lId.ArgsSet);
   // "when"
   lEqArgs.Init(0);
   while InFile.Current.Kind <> ';' do
   begin
      lNr := InFile.Current.Nr; InFile.InPos(CurPos); InFile.InWord;
      rNr := InFile.Current.Nr; InFile.InPos(CurPos); InFile.InWord;
      if (lNr = 0) or (rNr = 0) then
         lErrIdentify := true;
      if ldSet.ElemNr(lNr) >= 0 then
      begin
         lEqArgs.AssignPair(lNr,rNr);
         if ldSet.ElemNr(rNr) >= 0 then
         begin ErrImm(98); lErrIdentify := true end
         else if not rdSet.ElemNr(rNr) >=0 then
         begin ErrImm(99); lErrIdentify := true end;
         // checking arguments type
         if not lErrIdentify and
               not FixedVar[rNr].nTyp^.IsWiderThan(FixedVar[lNr].nTyp^.CopyType) then
         begin ErrImm(139); lErrIdentify := true end;
      end
      else if rdSet.ElemNr(lNr) >= 0 then
      begin
         lEqArgs.AssignPair(rNr,lNr);
         if rdSet.ElemNr(rNr) >= 0 then
         begin ErrImm(98); lErrIdentify := true end
         else if not ldSet.ElemNr(rNr) >=0 then
         begin ErrImm(99); lErrIdentify := true end;
         // checking arguments type
         if not lErrIdentify and
               not FixedVar[lNr].nTyp^.IsWiderThan(FixedVar[rNr].nTyp^.CopyType) then
         begin ErrImm(139); lErrIdentify := true end;
      end
      else
      begin ErrImm(99); lErrIdentify := true end;
   end;
   InFile.InWord;
   // checking (visible) arguments correcnesss
   for k  :=  0 to lEqArgs.Count - 1 do
      lCommonArgs.InsertElem(lEqArgs.Items^[k].X);
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   for k  :=  0 to lCommonArgs.Count - 1 do
      LociOcc[lCommonArgs.Items^[k].X] := true;
   for k := 1 to dPrimLength do
      if LociOcc[k] then
         gPrimaries[k]^.WithinType(\nwlinkedidentc{SetLociOcc}{NW4fRSrE-c8C2Z-1});
   lArgs.CopyNatSet(lCommonArgs);
   for k := 1 to dPrimLength do
      if LociOcc[k] then
         lArgs.InsertElem(k);
   if not lArgs.IsEqualTo(lId.ArgsSet) then
   begin ErrImm(189); lErrIdentify := true end;
   // \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1} condition: compatibility
   if lErrIdentify then
      gCorrCond[ord(syCompatibility)] := NewIncorFrm
   else if lEqArgs.Count = 0 then
      case aKind of
         ikTrmFunctor:
            gCorrCond[ord(syCompatibility)] := NewEqFrm(TrmPtr(lId.Pattern),TrmPtr(rId.Pattern));
         ikFrmPred,ikFrmAttr:
            gCorrCond[ord(syCompatibility)] := NewBicond(FrmPtr(lId.Pattern),FrmPtr(rId.Pattern));
      end
   else
   begin
      lConjuncts.Init(lEqArgs.Count,2);
      for k := 0 to lEqArgs .Count-1 do
         with lEqArgs .Items^[k] do
            lConjuncts.Insert(NewEqFrm(NewVarTrm(ikTrmConstant,X),NewVarTrm(ikTrmConstant,Y)));
      if lConjuncts.Count = 1 then
      begin
         lFrm := FrmPtr(lConjuncts.Items^[0]);
         lConjuncts.DeleteAll; lConjuncts.Done;
      end
      else lFrm := NewConjFrm(lConjuncts);
   case aKind of
      ikTrmFunctor:
         gCorrCond[ord(syCompatibility)] := 
         NewImpl(lFrm,NewEqFrm(TrmPtr(lId.Pattern),TrmPtr(rId.Pattern)));
      ikFrmPred,ikFrmAttr:
         gCorrCond[ord(syCompatibility)] := 
                   NewImpl(lFrm,NewBicond(FrmPtr(lId.Pattern),FrmPtr(rId.Pattern)));
   end;
   end;
   if not lErrIdentify then
   begin
      \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
      case aKind of
         ikTrmFunctor:
            begin
               lIdPattern := CopyTerm(TrmPtr(lId.Pattern));
               WithinTerm(TrmPtr(lIdPattern),ChangeToLoci);
               rIdPattern := CopyTerm(TrmPtr(rId.Pattern));
               WithinTerm(TRmPtr(rIdPattern),ChangeToLoci);
            end;
         ikFrmPred,ikFrmAttr:
            begin
               lIdPattern := FrmPtr(lId.Pattern)^.CopyFormula;
               WithinFormula(FrmPtr(lIdPattern),ChangeToLoci);
               rIdPattern := FrmPtr(rId.Pattern)^.CopyFormula;
               WithinFormula(FrmPtr(rIdPattern),ChangeToLoci);
            end;
      end;
      for k := 0 to lEqArgs .Count-1 do  with lEqArgs .Items^[k] do
      begin X := FixedVar[X].nSkelConstNr; Y := FixedVar[Y].nSkelConstNr end;
      lIdentify := new(IdentifyPtr,
                       Init(1+gIdentifications.Count, ArticleID,
                        aKind,lTypList,lIdPattern,rIdPattern,lEqArgs));
//writeln(infofile,'**************************************: ', lIdentify^.nConstrKind,CurPos.Line);
//writeln(infofile,'PrimaryList.Count=',lIdentify^.nPrimaryList.Count);
//infotypelist(lIdentify^.nPrimaryList); infonewline;
//infoterm(TrmPtr(lIdentify^.nPattern[0])); infonewline;
//infoterm(TrmPtr(lIdentify^.nPattern[1])); infonewline;
//with lEqArgs do
//for k := 0 to Count-1 do
//writeln(infofile,items^[k].X,'=',items^[k].y);
//infonewline;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_Identify(lIdentify);
      \{$ENDIF\}
      gIdentifications.Insert(lIdentify);
   end
   else
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elIdentify);
      AReport.Out_XAttr(atAid, ArticleID);
      AReport.Out_XIntAttr(atNr, 0);
      AReport.Out_XAttr(atConstrKind, aKind);
      AReport.Out_XAttrEnd;
      AReport.Out_XEl1(elErrorIdentify);
      AReport.Out_XElEnd(elIdentify);
      \{$ENDIF\}
   end;
   lId.ArgsSet.Done; rId.ArgsSet.Done;
   ldSet.Done; rdSet.Done;
   lEqArgs.Done;
end;
\nwindexdefn{\nwixident{DefIdentify}}{DefIdentify}{NW4fRSrE-2RxeIl-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefIdentify}}{DefIdentify}}}\nwidentuses{\\{{\nwixident{{\_}IdentifyData}}{:unIdentifyData}}\\{{\nwixident{Correctness}}{Correctness}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{FindPattern}}{FindPattern}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{SetLociOcc}}{SetLociOcc}}}\nwindexuse{\nwixident{{\_}IdentifyData}}{:unIdentifyData}{NW4fRSrE-2RxeIl-1}\nwindexuse{\nwixident{Correctness}}{Correctness}{NW4fRSrE-2RxeIl-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-2RxeIl-1}\nwindexuse{\nwixident{FindPattern}}{FindPattern}{NW4fRSrE-2RxeIl-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-2RxeIl-1}\nwindexuse{\nwixident{SetLociOcc}}{SetLociOcc}{NW4fRSrE-2RxeIl-1}\nwendcode{}\nwbegindocs{200}\nwdocspar
\nwenddocs{}\nwbegincode{201}\sublabel{NW4fRSrE-2NEGZf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2NEGZf-1}}}\moddef{Define property~{\nwtagstyle{}\subpageref{NW4fRSrE-2NEGZf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{gPropertyCond}{NW4fRSrE-2NEGZf-1}: FrmPtr;

procedure \nwlinkedidentc{DefProperty}{NW4fRSrE-2NEGZf-1};
var
   lPropertyNr: integer;
   lType: TypPtr;
   lPos: Position;
   lTypList: MCollection;
   lProperty: PropertyPtr;
begin
   lPropertyNr := InFile.Current.Nr;
   InFile.InPos(CurPos); InFile.InWord;
   lPos := CurPos;
   case PropertyKind(lPropertyNr) of
      sySethood:
         begin
            lType := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
            \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength,lTypList);
            \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
            if not \nwlinkedidentc{AllLociAccessibleInTyp}{NW4fRSrE-3K8iTi-1}(lTypList,lType) then
            begin
               Error(lPos,100);
            end;
            \nwlinkedidentc{gPropertyCond}{NW4fRSrE-2NEGZf-1} := NewExis(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                                    gBuiltIn[rqSetMode],nil),
                                     NewUniv(lType^.CopyType,
                                             NewPredFrm(ikFrmPred,
                                                        gBuiltIn[rqBelongsTo],
                                                        NewTrmList(NewVarTrm(ikTrmBound,2),
                                                                   NewTrmList(NewVarTrm(ikTrmBound,1),
                                                                              nil)),
                                                        0)));
            lType^.WithinType(ChangeToLoci);
            lProperty := new(PropertyPtr,Init(1+gPropertiesList.Count-RegPropertiesBase, ArticleID,
                                              lTypList,lPropertyNr,lType));
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_PropertyReg(lProperty);
            \{$ENDIF\}
            gPropertiesList.Insert(lProperty);
         end;
   else
      //   ErrImm(77);
   end;
end;
\nwindexdefn{\nwixident{DefProperty}}{DefProperty}{NW4fRSrE-2NEGZf-1}\nwindexdefn{\nwixident{gPropertyCond}}{gPropertyCond}{NW4fRSrE-2NEGZf-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefProperty}}{DefProperty}}\\{{\nwixident{gPropertyCond}}{gPropertyCond}}}\nwidentuses{\\{{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{ReadType}}{ReadType}}}\nwindexuse{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}{NW4fRSrE-2NEGZf-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-2NEGZf-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-2NEGZf-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-2NEGZf-1}\nwendcode{}\nwbegindocs{202}\nwdocspar
\nwenddocs{}\nwbegincode{203}\sublabel{NW4fRSrE-3xpn6K-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3xpn6K-1}}}\moddef{Parse definition of mode --- tail~{\nwtagstyle{}\subpageref{NW4fRSrE-3xpn6K-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ##TODO: pass patterns too
procedure \nwlinkedidentc{DefModeTail}{NW4fRSrE-3xpn6K-1};
var
   lPattern: PatternPtr;
begin
   with Notat[noMode], PatternPtr(Items^[Count+fExtCount-1])^ do
                          rConstr.Nr := gWhichOne;
end;
\nwindexdefn{\nwixident{DefModeTail}}{DefModeTail}{NW4fRSrE-3xpn6K-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefModeTail}}{DefModeTail}}}\nwendcode{}\nwbegindocs{204}\nwdocspar
\nwenddocs{}\nwbegincode{205}\sublabel{NW4fRSrE-vj17M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-vj17M-1}}}\moddef{Set structure~{\nwtagstyle{}\subpageref{NW4fRSrE-vj17M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}: array[1..MaxArgNbr] of FuncTrmPtr;
    \nwlinkedidentc{gSelectorNr}{NW4fRSrE-vj17M-1}: array[1..MaxArgNbr] of integer;
    \nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}: integer;

procedure \nwlinkedidentc{SetStruct}{NW4fRSrE-vj17M-1}(var fTrm: TrmPtr);
var
   lFuncNr: integer;
   lTrmList: TrmList;
begin
   if fTrm^.TrmSort=ikTrmLocus then
      with VarTrmPtr(fTrm)^ do
         if VarNr > \nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1} then
            if \nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}[VarNr-\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}] = nil then
            begin
               lFuncNr := \nwlinkedidentc{gSelectorNr}{NW4fRSrE-vj17M-1}[VarNr-\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}];
               dispose(fTrm,Done);
               fTrm := NewLocFuncTrm(ikTrmSelector,lFuncNr,\nwlinkedidentc{FormalArgs}{NW4fRSrE-Eqhkd-1}(\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}+1))
            end
            else
            begin
               with \nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}[VarNr-\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}]^ do
               begin lFuncNr := FuncNr; lTrmList := CopyTermList(FuncArgs) end;
               dispose(fTrm,Done);
               fTrm := NewLocFuncTrm(ikTrmSelector,lFuncNr,lTrmList);
            end;
end;
\nwindexdefn{\nwixident{SetStruct}}{SetStruct}{NW4fRSrE-vj17M-1}\nwindexdefn{\nwixident{gSelectRepresentation}}{gSelectRepresentation}{NW4fRSrE-vj17M-1}\nwindexdefn{\nwixident{gSelectorNr}}{gSelectorNr}{NW4fRSrE-vj17M-1}\nwindexdefn{\nwixident{gPrimLength}}{gPrimLength}{NW4fRSrE-vj17M-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{gPrimLength}}{gPrimLength}}\\{{\nwixident{gSelectorNr}}{gSelectorNr}}\\{{\nwixident{gSelectRepresentation}}{gSelectRepresentation}}\\{{\nwixident{SetStruct}}{SetStruct}}}\nwidentuses{\\{{\nwixident{FormalArgs}}{FormalArgs}}}\nwindexuse{\nwixident{FormalArgs}}{FormalArgs}{NW4fRSrE-vj17M-1}\nwendcode{}\nwbegindocs{206}\nwdocspar
\nwenddocs{}\nwbegincode{207}\sublabel{NW4fRSrE-CKGCk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-CKGCk-1}}}\moddef{Analyze selector~{\nwtagstyle{}\subpageref{NW4fRSrE-CKGCk-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{AnalyzeSelector}{NW4fRSrE-CKGCk-1}(var fConstrNr: integer;
                          var fArgList: TrmList;
                          fSelect: integer);
var
   k: integer;
   lTrmList: TrmList;
begin
   lTrmList := fArgList;
   for k := Notat[noSelector].Count-1 downto 0 do
      with PatternPtr(Notat[noSelector].Items^[K])^ do
         if fFormNr=fSelect then
            if CheckTypes(Notat[noSelector].Items^[K],lTrmList) then
            begin
               fArgList := CreateArgList(fPrimTypes.Count);
               RemoveQua(fArgList);
               fConstrNr := rConstr.Nr;
               DisposeListOfTerms(lTrmList);
               exit;
            end;
   DisposeTrmList(lTrmList);
   fConstrNr := 0;
end;
\nwindexdefn{\nwixident{AnalyzeSelector}}{AnalyzeSelector}{NW4fRSrE-CKGCk-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{AnalyzeSelector}}{AnalyzeSelector}}}\nwendcode{}\nwbegindocs{208}\nwdocspar
\nwenddocs{}\nwbegincode{209}\sublabel{NW4fRSrE-XUFqn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-XUFqn-1}}}\moddef{Define a structure~{\nwtagstyle{}\subpageref{NW4fRSrE-XUFqn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ##TODO: this is impossibly long, try some modularisation or clean-up
// ###TODO: BUG POSSIBLE: I have replaced Prefixes by lPrefixes, it is
//          theoretically possible that somewhere in this mess WidenningPath
//          is triggered before the coStructMode is created - check it if problems
procedure \nwlinkedidentc{DefStruct}{NW4fRSrE-XUFqn-1};
var
   j,k,lVarBase,lGenBase,lFieldBase,
   lSelectorNr,llSelectorNr,llPrefNr,lPrefNr,lAbsNr,
   lSelFuncNr,lOldSelNbr,lModeNr: integer;
   lPrefColl: array[1..MaxArgNbr] of NatSet;
   lClusterPtr: AttrCollectionPtr;
   lSelectFuncTyp: array[1..MaxArgNbr] of TypPtr;
   lSelectorTyp,lStructTyp,lTyp,lTyp1:TypPtr;
   lPattern: PatternPtr;
   lStructColl: NatSetPtr;
   lStructSelectors: NatSet;
   lAggrColl: PCollection;
   \{ -- identyfikacja selektorow -- \} \{ -- selector identification -- \}
   lSelectorTerm: SelectorTerm;
   lSelectTyp,llSelectTyp: TypPtr;
   lFuncArgs: TrmList;
   lStructPos: Position;
   lTypList: MCollection;
   lTypPtr: TypPtr;
   r: Integer;
   lPrefixes: MCollection;
   lConstr: ConstrPtr;
   lAbsRegNr: integer;
label OldSelector;
begin
   InFile.InPos(CurPos); InFile.InWord;
   \{ ---- Przeczytanie deklaracji prefiksow ---- \}
   \{ ---- Read prefix declaration ---- \}
   gDefPos := CurPos;
   lStructPos := CurPos;
   lOldSelNbr :=  Constr[ coSelector].Count;
   lPrefixes.Init(0,5);
   while InFile.Current.Kind = ikMscPrefix do
   begin
      lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1}; Infile.InWord;
      if lTyp^.TypSort = ikTypStruct then
      begin
         if lTyp^.LowerCluster^.Count <> 0 then
            ErrImm(90);
         lPrefixes.Insert(lTyp);
      end
      else ErrImm(errNonStructPrefix);
   end;
   \{ ========================================= \}
   \{ ---- Wprowadzenie modu strukturowego ---- \}
   \{ ---- Introduction of structural mode ---- \}
   gDefPos := CurPos;
   \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noStructMode, lPattern);
   \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
   Notat[noStructMode].InsertExt(lPattern);
   with Notat[noStructMode], PatternPtr(Items^[Count+fExtCount-1])^.rConstr do
   begin Kind := 'L'; Nr :=  Constr[ coStructMode].Count; end;
   \{ Na zakonczenie typ lokusa odpowiadajacego jedynemu widocznemu
     argumentowi funkcji selektorowych. Jego kopie zostaja zuzyte
     jako
     - typ wynikowy funktora agregujacego, po wstawieniu na pole
     TypeAttributes klastra "abstract",
     - typ podmiotu atrybutu "abstract"
   \}
   \{ Finally, the type of locus corresponding to the only visible
     argument of the selector functions. Its copies are consumed as
     - result type of the aggregation functor, after inserting the
       "abstract" cluster into the TypeAttributes field,
     - entity type of the "abstract" attribute
   \}
   lStructTyp := NewStandardTyp(ikTrmAggreg,NewEmptyCluster,NewEmptyCluster,
                                Constr[ coStructMode].Count,\nwlinkedidentc{FormalArgs}{NW4fRSrE-Eqhkd-1}(dPrimLength));

   \{ Zapamietanie sytuacji po deklaracji modu strukturowego \}
   \{ Remembering the situation after the declaration of the structural mode \}
   \nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1} := dPrimLength;
   lVarBase := g.VarNbr;
   lGenBase := g.GenCount;
   lFieldBase := gPrimNbr;
   
   \{ ---- Przeczytanie lokusow odpowiadajcych polom ---- \}
   \{ ---- Reading locuses corresponding to fields ---- \}
   \nwlinkedidentc{GetConstQualifiedList}{NW4fRSrE-4MdvhM-1};
   
   \{ ---- Wprowadzenie typow funkcji selektorowych ---- \}
   \{ ---- Introduction of selector function types ---- \}
   for j := 1 to g.VarNbr-lVarBase do
   begin
      lSelectFuncTyp[j] := FixedVar[lVarBase+j].nTyp^.CopyType;
      inc(g.GenCount);
      FixedVar[lVarBase+j].nSkelConstNr := g.GenCount;
      LocusAsConst[g.GenCount] := lVarBase+j;
      lSelectFuncTyp[j]^.WithinType(ChangeToLoci);
   end;
   \{ Tutaj jest chyba wykonywana podwojna robota \}
   \{I guess there's double work being done here\}
   dec(g.GenCount,g.VarNbr-lVarBase);
   \nwlinkedidentc{ParamDecl}{NW4fRSrE-29B9Op-1}(lVarBase);
   
   \{ ---- Wprowadzenie funktora agregujacego ---- \}
   \{ ---- Introduction of the aggregation functor ---- \}
   gDefPos := CurPos;
   lPattern := new(PatternPtr,Init(noAggregate, \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1}(noAggregate),
                                   ArticleID));
   Notat[noAggregate].InsertExt(lPattern);
   
   \nwlinkedidentc{InitAccess}{NW4fRSrE-41gYk7-1};
   \{ Specjalna realizacja GetFormat \}
   \{ Special implementation of GetFormat \}
   for j := lFieldBase+1 to gPrimNbr do LociOcc[j] := true;
   with Notat[noAggregate], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      \{ Przewiniecie formatu konstruktora \}
      \{ Constructor Format Scroll \}
      fFormNr := InFile.Current.Nr; InFile.InPos(CurPos); InFile.InWord;
      \{ Inicjalizacja \} \{ Initialization \}
      fPrimTypes.Init(dPrimLength);
      for k := 1 to dPrimLength do
         fPrimTypes.Insert(gPrimaries[k]^.CopyType);
      Visible.Init(dPrimLength-\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1});
      for k := \nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1}+1 to dPrimLength do r := Visible.Insert(k);
      \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(Items^[Count+fExtCount-1]);
      if PatternPtr(Notat[noStructMode].Items^[Notat[noStructMode].Count+
                                                  Notat[noStructMode].fExtCount-1])^.fFormNr = 0 then
         fFormNr := 0;
      with rConstr do
      begin Kind := ikTrmAggreg; Nr :=  Constr[ coAggregate].Count; end;
      lTypPtr := lStructTyp^.CopyType;
      lAbsNr :=  1 + Constr[coAggregate].Count - ConstrBase[coAggregate];
      lConstr :=  new(AggrConstrPtr,
                      InitForPattern(lAbsNr,ArticleID,fPrimTypes,lTypPtr));
      AggrConstrPtr(lConstr)^.fAggregBase :=  \nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1};
      Constr[ coAggregate].Insert(lConstr);
      // ##NOTE: fAggrColl is done later
   end;
   
   \{ ========================================= \}
   \{ Przywrocenie sytuacji po deklaracji modu strukturowego \}
   \{ Restoring the situation after declaration of a structured module \}
   \nwlinkedidentc{RenewPrimaries}{NW4fRSrE-3PpPH3-1}(\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1});
   for j := lVarBase+1 to g.VarNbr do dispose(FixedVar[j].nTyp,Done);
   g.VarNbr := lVarBase; g.GenCount := lGenBase;
   
   \{ Wprowadzamy wspolny lokus dla atrybutu "abstract"
     i dla funkcji selektorowych \}
   \{ We introduce a common locus for the "abstract"
     attribute and for selector functions \}
   \nwlinkedidentc{AppendLocus}{NW4fRSrE-2jU5qo-1}(lStructTyp);
   
   \{ --- Inicjalizacja kolekcji selektorow ---- \}
   \{ --- Initialization of selector collection ---- \}
   lAggrColl := new(PCollection, Init(2,2));
   lStructColl := new(NatSetPtr, Init(2,2));
   
   \{ ---- Inicjalizacja prefiksow ---- \}
   \{ ---- Prefix initialization ---- \}
   for lPrefNr := 0 to lPrefixes.Count-1 do
   begin
      lModeNr :=  TypPtr(lPrefixes.Items^[lPrefNr])^.ModNr;
      with StructConstrPtr(Constr[ coStructMode].At(lModeNr))^ do
         lPrefColl[lPrefNr+1].CopyNatSet(fFields^);
   end;
   
   \{ ---- Wprowadzenie funktora zapominania ---- \}
   \{ ---- Introduction of the forgetting functor ---- \}
   gDefPos := CurPos;
   lPattern := new(PatternPtr,Init(noForgetFunctor, \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1}(noForgetFunctor),
                                   ArticleID));
   Notat[noForgetFunctor].InsertExt(lPattern);
   with Notat[noForgetFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      fFormNr := InFile.Current.Nr; InFile.InPos(CurPos); InFile.InWord;
      fPrimTypes.Init(dPrimLength);
      for k := 1 to dPrimLength do
         fPrimTypes.Insert(gPrimaries[k]^.CopyType);
      Visible.Init(1); r := Visible.Insert(dPrimLength);
      rConstr.Kind := ikTrmSubAgreg;
      rConstr.Nr :=  Constr[ coStructMode].Count;
   end;
   
   \{ ---- Wprowadzenie funktorow selektorowych ---- \}
   \{ ---- Introduction of selector functors ---- \}
   lSelFuncNr := 0;
   fillchar(\nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1},SizeOf(\nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}),0);
   lStructSelectors.Init(MaxArgNbr,MaxArgNbr);
   while InFile.Current.Kind=ikTrmSelector do
   begin
      \nwlinkedidentc{GetPattern}{NW4fRSrE-mDy4S-1}(noSelector, lPattern);
      if lStructSelectors.ElemNr(lPattern^.fFormNr) >= 0 then
         ErrImm(errFieldHomonimy);
      lStructSelectors.InsertElem(lPattern^.fFormNr);
      \nwlinkedidentc{CheckAccess}{NW4fRSrE-1YfrP8-1}(lPattern);
      InFile.InWord;
      inc(lSelFuncNr); lSelectorTyp := lSelectFuncTyp[lSelFuncNr];
      lSelectorTyp^.WithinType(\nwlinkedidentc{SetStruct}{NW4fRSrE-vj17M-1});
      for lPrefNr := 0 to lPrefixes.Count-1 do
      begin
         FixedVar[g.VarNbr].nTyp := TypPtr(lPrefixes.Items^[lPrefNr])^.CopyType;
         lSelectorTerm.Init(lPattern^.fFormNr,CurPos,nil);
         lFuncArgs := NewTrmList(NewVarTrm(ikTrmConstant,g.VarNbr),nil);
         \nwlinkedidentc{AnalyzeSelector}{NW4fRSrE-CKGCk-1}(lSelectorNr,lFuncArgs,lSelectorTerm.Select);
         dispose(FixedVar[g.VarNbr].nTyp,Done);
         if lSelectorNr <> 0 then
         begin
            \nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}[lSelFuncNr] := NewLocFuncTrm(ikTrmSelector,lSelectorNr,lFuncArgs);
            lSelectTyp := ConstrTypPtr(Constr[coSelector].Items^[lSelectorNr]
                                      )^.fConstrTyp^.InstTyp(lFuncArgs);
            gSuperfluous := 0;
            lSelectorTyp^.WithinType(\nwlinkedidentc{ChangeToConst}{NW4fRSrE-1IRHWc-1});
            if not EqTyp(lSelectorTyp,lSelectTyp) then
               ErrImm(errFieldTypeInconsistent);
            dispose(lSelectTyp,Done);
            for llPrefNr := lPrefNr+1 to lPrefixes.Count-1 do
            begin
               inc(g.VarNbr);
               FixedVar[g.VarNbr].nIdent := 0;
               FixedVar[g.VarNbr].nTyp := TypPtr(lPrefixes.Items^[llPrefNr])^.CopyType;
               lSelectorTerm.Init(lPattern^.fFormNr,CurPos,nil);
               lFuncArgs := NewTrmList(NewVarTrm(ikTrmConstant,g.VarNbr),nil);
               \nwlinkedidentc{AnalyzeSelector}{NW4fRSrE-CKGCk-1}(llSelectorNr,lFuncArgs,lSelectorTerm.Select);
               dispose(FixedVar[g.VarNbr].nTyp,Done);
               dec(g.VarNbr);
               if llSelectorNr <> 0 then
               begin
                  if lSelectorNr = llSelectorNr then
                  begin
                     llSelectTyp := ConstrTypPtr(Constr[coSelector].Items^[lSelectorNr]
                                                )^.fConstrTyp^.InstTyp(lFuncArgs);
                     llSelectTyp^.WithinType(\nwlinkedidentc{RenewConst}{NW4fRSrE-8NgkM-1});
                     if not EqTyp(lSelectorTyp,llSelectTyp) then
                        ErrImm(errFieldTypeInconsistent);
                     dispose(llSelectTyp,Done);
                     lPrefColl[llPrefNr+1].DeleteElem(llSelectorNr)
                  end
                  else ErrImm(errFieldHomonimy);
                  DisposeTrmList(lFuncArgs);
               end;
            end;
            lPrefColl[lPrefNr+1].DeleteElem(lSelectorNr);
            dispose(lSelectorTyp,Done);
            lPattern^.Visible.Done;
            goto OldSelector;
         end;
      end;
      \{ -- Jest to nowy selektor -- \}
      \{ -- This is a new selector -- \}
      with lPattern^.rConstr do
      begin Kind := ikTrmSelector; Nr :=  Constr[ coSelector].Count; end;
      Notat[noSelector].InsertExt(lPattern);
      lAbsNr :=  1 + Constr[coSelector].Count - ConstrBase[coSelector];
      with lPattern^ do
         lConstr :=  new(ConstrTypPtr,
                         InitForPattern(coSelector,lAbsNr,ArticleID,
                                        fPrimTypes,lSelectorTyp));
      Constr[ coSelector].Insert(lConstr);
      
      dispose(lSelectorTyp,Done);
      lSelectorNr :=  Constr[ coSelector].Count - 1;
      OldSelector:
         \{ -- Zapisanie przekodowania lokusa na selektor, dla \nwlinkedidentc{SetStruct}{NW4fRSrE-vj17M-1} -- \}
         \{ -- Saving the locus recoding to a selector, for \nwlinkedidentc{SetStruct}{NW4fRSrE-vj17M-1} -- \}
         \nwlinkedidentc{gSelectorNr}{NW4fRSrE-vj17M-1}[lSelFuncNr] := lSelectorNr;
      \{ -- Wstawienie selektora do kolekcji -- \}
      \{ -- Inserting a selector into the collection -- \}
      lStructColl^.InsertElem(lSelectorNr);
      lAggrColl^.Insert(new(PIntItem,Init(lSelectorNr)));
   end;
   lStructSelectors.Done;
   
   for j := 1 to lSelFuncNr do
      if \nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}[j] <> nil then
         DisposeTrm(\nwlinkedidentc{gSelectRepresentation}{NW4fRSrE-vj17M-1}[j]);
   
   \{ ---- Sprawdzamy czy prefiksy zostaly wyczerpane ---- \}
   \{ ---- We check whether the prefixes have been exhausted ---- \}
   for lPrefNr := 0 to lPrefixes.Count-1 do
   begin
      if lPrefColl[lPrefNr+1].Count <> 0 then ErrImm(errIncompletePrefix);
      TypPtr(lPrefixes.Items^[lPrefNr])^.WithinType(ChangeToLoci);
      lPrefColl[lPrefNr+1].Done;
   end;
   
   \{ ---- Wstawienie kolekcji selektorow ---- \}
   \{ ---- Inserting a collection of selectors ---- \}
   with AggrConstrPtr(Constr[coAggregate].Last)^ do
      fAggrColl :=  lAggrColl;
   lAbsNr :=  1 + Constr[coStructMode].Count - ConstrBase[coStructMode]; 
   with Notat[noStructMode], PatternPtr(Items^[Count+fExtCount-1])^ do
   lConstr := new(StructConstrPtr,
                  InitForPattern(lAbsNr,ArticleID,fPrimTypes));
   with StructConstrPtr(lConstr)^ do
   begin
      fFields := lStructColl;
      fStructModeAggrNr := Constr[coAggregate].Count - 1;
      fPrefixes.MoveCollection(lPrefixes);
   end;
   Constr[ coStructMode].Insert(lConstr);
   
   \{ ---- Wprowadzenie atrybutu "abstract" ---- \}
   \{ ---- Entering the "abstract" attribute ---- \}
   gDefPos := lStructPos;
   lPattern := new(PatternPtr,Init(noAttribute, \nwlinkedidentc{AbsNotatNr}{NW4fRSrE-23RESF-1}(noAttribute),
                                   ArticleID));
   Notat[noAttribute].InsertExt(lPattern);
   lTypPtr := lStructTyp^.CopyType;
   lAbsNr :=  1 + Constr[coAttribute].Count - ConstrBase[coAttribute]; 
   with Notat[noAttribute], PatternPtr(Items^[Count+fExtCount-1])^ do
   begin
      fFormNr := 1 \{ "abstract' \};
      fAntonymic := false;
      \{??\} \{Co to za numer formatu, czemu nie stala z BuitIn ?\}
      \{What format number is this, why wasn't it from BuitIn?\}
      fPrimTypes.Init(dPrimLength);
      for k := 1 to dPrimLength do
         fPrimTypes.Insert(gPrimaries[k]^.CopyType);
      Visible.Init(1);
      r := Visible.Insert(FixedVar[g.VarNbr].nSkelConstNr);
      rConstr.Kind := ikFrmAttr; rConstr.Nr := Constr[coAttribute].Count;
      lConstr :=  new(ConstrTypPtr, InitForPattern(coAttribute,lAbsNr,ArticleID,
                                                   fPrimTypes,lTypPtr));
      include(lConstr^.fProperties, syAbstractness);
      Constr[ coAttribute].Insert(lConstr);
   end;
   
   // Register the existential cluster
   lClusterPtr := new(AttrCollectionPtr,Init(2,4));
   \{??\} \{czemu tutaj wystepuje 1, czy nil jest poprawne?\}
   \{??\} \{why is there 1 here, is nil correct?\}
   lClusterPtr^.InsertAttr(Constr[coAttribute].Count-1, 1,
                           \nwlinkedidentc{FormalArgs}{NW4fRSrE-Eqhkd-1}(dPrimLength-1)\{###\});
   // lClusterPtr^.WithinAttrCollection(ChangeToLoci);
   \{ Nie potrzeba sprawdzac, bo jest jednoelementowy \}
   \{ No need to check because it is single-element \}
   \nwlinkedidentc{CreateLociList}{NW4fRSrE-11oteT-1}(1,dPrimLength-1,lTypList);
   lTyp1 := lTypPtr^.CopyType;
   lAbsRegNr :=  1 + RegisteredCluster.Count +  RegisteredCluster.fExtCount - RegClusterBase;
   RegisteredCluster.InsertExt(new(RClusterPtr,
                                   RegisterCluster(lAbsRegNr,ArticleID,lClusterPtr,lTypList,lTyp1)));
   dispose(lTyp1,Done);
   with  AggrConstrPtr(Constr[coAggregate].Last)^.fConstrTyp^ do
   begin
      dispose(LowerCluster,Done);
      LowerCluster := \{CopyCluster(\}lClusterPtr\{)\};
      dispose(UpperCluster,Done);
      UpperCluster := CopyCluster(LowerCluster);
   end;
   \{ Przywrocenie sytuacji po deklaracji modu strukturowego \}
   \{ Restoring the situation after declaration of a structured module \}
   \nwlinkedidentc{RenewPrimaries}{NW4fRSrE-3PpPH3-1}(\nwlinkedidentc{gPrimLength}{NW4fRSrE-vj17M-1});
   g.VarNbr := lVarBase;
   g.GenCount := lGenBase;
   dispose(lStructTyp,Done);
   
   // ##NOTE: the attribute has to go first, or probably at least
   //         before the coAggregate. It has to be know before any
   //         cluster containing it is read, otherwise the CompAttr
   //         comparison function used for clusters causes internal error.
   //         This is fairly fragile, if their were more such mutually
   //         defined constructors we could get into serious trouble.
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Constructor(Constr[ coAttribute].Last,
                           Constr[coAttribute].Count - 1);
   AReport.Out_Constructor(Constr[ coStructMode].Last,
                           Constr[coStructMode].Count - 1);
   AReport.Out_Constructor(Constr[ coAggregate].Last,
                           Constr[coAggregate].Count - 1);
   
   with Constr[ coSelector] do
      for k :=  lOldSelNbr to Count-1 do
         AReport.Out_Constructor(Items^[ k], k);
   
   AReport.Out_XElStart0(elRegistration);
   with RegisteredCluster do
      AReport.Out_RCluster(Items^[Count+fExtCount-1]);
   AReport.Out_XElEnd(elRegistration);
   \{$ENDIF\}   
end;
\nwindexdefn{\nwixident{DefStruct}}{DefStruct}{NW4fRSrE-XUFqn-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DefStruct}}{DefStruct}}}\nwidentuses{\\{{\nwixident{AbsNotatNr}}{AbsNotatNr}}\\{{\nwixident{AnalyzeSelector}}{AnalyzeSelector}}\\{{\nwixident{AppendLocus}}{AppendLocus}}\\{{\nwixident{ChangeToConst}}{ChangeToConst}}\\{{\nwixident{CheckAccess}}{CheckAccess}}\\{{\nwixident{CreateLociList}}{CreateLociList}}\\{{\nwixident{FormalArgs}}{FormalArgs}}\\{{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}}\\{{\nwixident{GetPattern}}{GetPattern}}\\{{\nwixident{gPrimLength}}{gPrimLength}}\\{{\nwixident{gSelectorNr}}{gSelectorNr}}\\{{\nwixident{gSelectRepresentation}}{gSelectRepresentation}}\\{{\nwixident{InitAccess}}{InitAccess}}\\{{\nwixident{ParamDecl}}{ParamDecl}}\\{{\nwixident{ReadType}}{ReadType}}\\{{\nwixident{RenewConst}}{RenewConst}}\\{{\nwixident{RenewPrimaries}}{RenewPrimaries}}\\{{\nwixident{SetStruct}}{SetStruct}}}\nwindexuse{\nwixident{AbsNotatNr}}{AbsNotatNr}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{AnalyzeSelector}}{AnalyzeSelector}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{AppendLocus}}{AppendLocus}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{ChangeToConst}}{ChangeToConst}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{CheckAccess}}{CheckAccess}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{CreateLociList}}{CreateLociList}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{FormalArgs}}{FormalArgs}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{GetPattern}}{GetPattern}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{gPrimLength}}{gPrimLength}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{gSelectorNr}}{gSelectorNr}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{gSelectRepresentation}}{gSelectRepresentation}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{InitAccess}}{InitAccess}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{ParamDecl}}{ParamDecl}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{RenewConst}}{RenewConst}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{RenewPrimaries}}{RenewPrimaries}{NW4fRSrE-XUFqn-1}\nwindexuse{\nwixident{SetStruct}}{SetStruct}{NW4fRSrE-XUFqn-1}\nwendcode{}\nwbegindocs{210}\nwdocspar
\nwenddocs{}\nwbegincode{211}\sublabel{NW4fRSrE-4G4xQr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4G4xQr-1}}}\moddef{Parse a reservation~{\nwtagstyle{}\subpageref{NW4fRSrE-4G4xQr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Reservation}{NW4fRSrE-4G4xQr-1};
var
   lExpPtr: ExpPtr;
   k: integer;
   lIdents: IntSequence;
begin
   BoundVarNbr := 0;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart0(elReservation);
   \{$ENDIF\}
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   \{ czytanie typow zmiennych wolnych w typie rezerwacji \}
   \{ reading the types of free variables in the reservation type \}
   gExportableItem := true;
   gConstInExportableItemOcc := false;
   lIdents.Init(0);
   InFile.InWord;
   while InFile.Current.Kind <> ';' do
   begin
      lIdents.Insert(InFile.Current.Nr);
      InFile.InWord;
   end;
   \{$IFDEF ANALYZER_REPORT\}
   for k  :=  0 to lIdents.fCount - 1 do
   begin
      AReport.Out_XElStart(elIdent);
      AReport.Out_XIntAttr(atVid, lIdents.fList^[k]);
      AReport.Out_XElEnd0;
   end;
   \{$ENDIF\}
   InFile.InWord;
   while InFile.Current.Kind <> ';' do
   begin
      lExpPtr := LoadType;
      inc(BoundVarNbr);
      BoundVar[BoundVarNbr] := lExpPtr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
      dispose(lExpPtr,Done);
      InFile.InWord;
   end;
   inc(ResNbr);
   mizassert(2524,ResNbr<=MaxResNbr);
   lExpPtr := LoadType;
   ReservedVar[ResNbr] := lExpPtr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_Type(ReservedVar[ResNbr]);
   \{$ENDIF\}
   dispose(lExpPtr,Done);
   \{----\}
   RemoveTermsFromTTColl;
   \{----\}
   for k := 1 to BoundVarNbr do dispose(BoundVar[k],Done);
   Infile.InWord;
   BoundVarNbr := 0;
   gExportableItem := false;
   gConstInExportableItemOcc := false;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElEnd(elReservation);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{Reservation}}{Reservation}{NW4fRSrE-4G4xQr-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Reservation}}{Reservation}}}\nwidentuses{\\{{\nwixident{Analyze}}{Analyze}}}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-4G4xQr-1}\nwendcode{}\nwbegindocs{212}\nwdocspar
\nwenddocs{}\nwbegincode{213}\sublabel{NW4fRSrE-35R9Kt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-35R9Kt-1}}}\moddef{Spread local predicates~{\nwtagstyle{}\subpageref{NW4fRSrE-35R9Kt-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1}(var fFrm: FrmPtr); FORWARD;

procedure \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(var aFrm: FrmPtr);
var
   lFrm,lFrm1,lFrm2: FrmPtr;
begin
   repeat
      while aFrm^.FrmSort=ikFrmPrivPred do
      begin
         lFrm := aFrm;
         aFrm := LocPredFrmPtr(aFrm)^.PredExp;
         DisposeTrmList(LocPredFrmPtr(lFrm)^.PredArgs);
         dispose(lFrm);
      end;
      if (aFrm^.FrmSort=ikFrmNeg) and (NegFrmPtr(aFrm)^.NegArg^.FrmSort = ikFrmPrivPred) then
      begin
         lFrm1 := LocPredFrmPtr(NegFrmPtr(aFrm)^.NegArg)^.PredExp;
         while lFrm1^.FrmSort=ikFrmPrivPred do
            lFrm1 := LocPredFrmPtr(lFrm1)^.PredExp;
         if lFrm1^.FrmSort = ikFrmNeg then
         begin
            lFrm2 := aFrm;
            aFrm := NegFrmPtr(lFrm1)^.NegArg;
            lFrm := NegFrmPtr(lFrm2)^.NegArg;
            dispose(lFrm2);
            while lFrm^.FrmSort=ikFrmPrivPred do
            begin
               lFrm2 := lFrm;
               lFrm := LocPredFrmPtr(lFrm)^.PredExp;
               DisposeTrmList(LocPredFrmPtr(lFrm2)^.PredArgs);
               dispose(lFrm2);
            end;
            dispose(lFrm1);
         end;
      end
   until aFrm^.FrmSort<>ikFrmPrivPred;
end;
\nwindexdefn{\nwixident{SpreadLocPred}}{SpreadLocPred}{NW4fRSrE-35R9Kt-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{SpreadLocPred}}{SpreadLocPred}}}\nwidentuses{\\{{\nwixident{RegularStatement}}{RegularStatement}}}\nwindexuse{\nwixident{RegularStatement}}{RegularStatement}{NW4fRSrE-35R9Kt-1}\nwendcode{}\nwbegindocs{214}\nwdocspar
\nwenddocs{}\nwbegincode{215}\sublabel{NW4fRSrE-omUgm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-omUgm-1}}}\moddef{Decompose formula~{\nwtagstyle{}\subpageref{NW4fRSrE-omUgm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// If conjunction head is the first conjunct, tail is the rest.
// Otherwise tail is verum and head is the whole fla.
procedure \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(fFrm: FrmPtr; var fFrm_head,fFrm_tail: FrmPtr);
\{ zakladamy, ze "decompose" dziala na kopii i moze ja niszczyc \}
\{ we assume that "decompose" works on the copy and may destroy it \}
begin
   if fFrm^.FrmSort = ikFrmConj then
      with ConjFrmPtr(fFrm)^ do
   begin
      fFrm_head := FrmPtr(Conjuncts.Items^[0]);
      Conjuncts.AtDelete(0);
      if Conjuncts.Count = 1 then
      begin fFrm_Tail := FrmPtr(Conjuncts.Items^[1]);
      Conjuncts.DeleteAll; dispose(fFrm,Done);
      end
      else fFrm_tail := fFrm;
   end
   else begin fFrm_head := fFrm; fFrm_tail := NewVerum end;
end;
\nwindexdefn{\nwixident{Decompose}}{Decompose}{NW4fRSrE-omUgm-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Decompose}}{Decompose}}}\nwendcode{}\nwbegindocs{216}\nwdocspar
\nwenddocs{}\nwbegincode{217}\sublabel{NW4fRSrE-1O513Y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1O513Y-1}}}\moddef{Spread atomic formula~{\nwtagstyle{}\subpageref{NW4fRSrE-1O513Y-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ##NOTE: destructive on fFrm, usually requires a copy
// Tries to replace atomic fFrm with its definitional expansion,
// starting from the most recent items in Definientia.
// If no success, replaces fFrm with NewInCorFrm.
// This now returns the number of the Definientia item, or -1 if none.
function \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}(var fFrm: FrmPtr; Conclusion: boolean): integer;
var
   lArgs,lElem: TrmList;
   lWord: Lexem;
   i,lResult: integer;
   Negated: boolean;
   lItem: DefiniensPtr;
   lFrm: FrmPtr;
begin
   lResult :=  -1;
   Negated := false;
   \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(fFrm);
   if fFrm^.FrmSort=ikFrmNeg then
   begin
      lFrm := fFrm;
      fFrm := NegFrmPtr(fFrm)^.NegArg;
      \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(fFrm);
      dispose(lFrm);
      Negated := true
   end;
   lWord.Kind := fFrm^.FrmSort;
   lItem := nil;
   case lWord.Kind of
      ikFrmPred: AdjustFrm(PredFrmPtr(fFrm),lWord.Nr,lArgs);
      ikFrmAttr: AdjustAttrFrm(PredFrmPtr(fFrm),lWord.Nr,lArgs);
      ikFrmQual:
         with QualFrmPtr(fFrm)^,QualTyp^ do
         if (TypSort = ikTypMode) and (LowerCluster^.Count = 0) then
         begin
            lWord.Kind := ikTypMode;
            QualTyp^.AdjustTyp(lWord.Nr,lArgs);
            lElem := nil;
            if lArgs=nil then lArgs := NewTrmList(QualTrm,nil)
            else
            begin
               lElem := LastElem(lArgs);
               lElem^.NextTrm := NewTrmList(QualTrm,nil);
            end;
         end;
   end;
   lItem := nil;
   for i := Definientia.Count-1 downto 0 do
      if Matches(lWord,lArgs,DefiniensPtr(Definientia.Items^[i])) then
      begin lItem := Definientia.Items^[i]; lResult :=  i + 1; break end;
   if lWord.Kind = ikTypMode then
      if lElem <> nil then
      begin
         dispose(lElem^.NextTrm); 
         lElem ^.NextTrm := nil;
      end
      else dispose(lArgs);
   dispose(fFrm,Done);
   \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1} :=  lResult;
   if lItem = nil then begin fFrm := NewInCorFrm; exit end;
   fFrm := lItem^.SpreadFrm(CreateArgList(lItem^.PrimaryList.Count),Negated,Conclusion);
end;
\nwindexdefn{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}}\nwidentuses{\\{{\nwixident{SpreadLocPred}}{SpreadLocPred}}}\nwindexuse{\nwixident{SpreadLocPred}}{SpreadLocPred}{NW4fRSrE-1O513Y-1}\nwendcode{}\nwbegindocs{218}\nwdocspar
\nwenddocs{}\nwbegincode{219}\sublabel{NW4fRSrE-1YXN9Y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1YXN9Y-1}}}\moddef{Chopping definientia(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-1YXN9Y-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
const \nwlinkedidentc{MaxExpansionNbr}{NW4fRSrE-1YXN9Y-1} = 20;

// ##NOTE: destructive on fForm, usually requires a copy
// ##NOTE: seems also destructive on g.Thesis, so failure
//         probably means that g.Thesis is messed up
// ##TODO: a version using a second formula rather than g.Thesis
//         would be much cleaner and safer
// In fDefs we pass the numbers of items in Definientia, that were
// succesfully used for chopping, together with their counts.
function \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1}(fForm: FrmPtr;
                 Conclusion: boolean;
                 var fDefs: NatFuncPtr): boolean;
var
   f_head,Thesis_head: FrmPtr;
   ii,lDefNr: integer;
label ToChop;
procedure DisposeInLoop;
begin
   dispose(Thesis_head, Done);
   dispose(f_head, Done);
   dispose(fForm, Done);
   fDefs^.DeleteAll;
end;
begin
   fDefs :=  new(NatFuncPtr, InitNatFunc(4,4));
   \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} := true; if g.Thesis^.FrmSort=ikError then exit;
   if fForm^.FrmSort=ikError then begin g.Thesis := NewInCorFrm; exit end;
   // This loop ends when there is no more conjunct in fForm
   while fForm^.FrmSort<>ikFrmVerum do
   begin
      \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(fForm,f_head,fForm);
      \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(g.Thesis,Thesis_head,g.Thesis);
      // Now we try to spread (apply definiens to) the Thesis_head
      // until it is equal to f_head. If no success, we exit with false.
      for ii := 1 to \nwlinkedidentc{MaxExpansionNbr}{NW4fRSrE-1YXN9Y-1} do
      begin
         if EqFrm(f_head,Thesis_head) then goto ToChop;
         repeat
            if (f_head^.FrmSort = ikFrmPrivPred) and (Thesis_head^.FrmSort = ikFrmPrivPred) then
            begin
               case CompareInt(LocPredFrmPtr(f_head)^.PredNr, LocPredFrmPtr(Thesis_head)^.PredNr) of
                  -1:
                     begin
                        \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(Thesis_head);
                        \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(Thesis_head,g.Thesis),Thesis_head,g.Thesis);
                     end;
                  0: begin DisposeInLoop; \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} := false; exit; end;
                  1:
                     begin
                        \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(f_head);
                        \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(f_head,fForm),f_head,fForm);
                     end;
               end;
            end;
            if EqFrm(f_head,Thesis_head) then goto ToChop;
            \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(f_head);
            \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(f_head,fForm),f_head,fForm);
            if EqFrm(f_head,Thesis_head) then goto ToChop;
            \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(Thesis_head);
            \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(Thesis_head,g.Thesis),Thesis_head,g.Thesis);
            if EqFrm(f_head,Thesis_head) then goto ToChop;
         until (f_head^.FrmSort <> ikFrmPrivPred) and (Thesis_head^.FrmSort <> ikFrmPrivPred);
         lDefNr :=  \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}(Thesis_head,Conclusion);
         if lDefNr >= 0 then fDefs^.Up(lDefNr);
         if Thesis_head^.FrmSort = ikError then
         begin DisposeInLoop; \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} := false; exit; end;
         \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(Thesis_head,g.Thesis),Thesis_head,g.Thesis);
      end; // of the for loop
      \{ Tutaj by tez trzeba dysponowac !\} \{You would also need to have it here!\}
      \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} := false; fDefs^.DeleteAll; exit;
      ToChop: // success for heads
         dispose(Thesis_head,Done);
      dispose(f_head,Done);
   end; // of the while loop
   dispose(fForm);
end;
\nwindexdefn{\nwixident{Chopped}}{Chopped}{NW4fRSrE-1YXN9Y-1}\nwindexdefn{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}{NW4fRSrE-1YXN9Y-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Chopped}}{Chopped}}\\{{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}}}\nwidentuses{\\{{\nwixident{Decompose}}{Decompose}}\\{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}\\{{\nwixident{SpreadLocPred}}{SpreadLocPred}}}\nwindexuse{\nwixident{Decompose}}{Decompose}{NW4fRSrE-1YXN9Y-1}\nwindexuse{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}{NW4fRSrE-1YXN9Y-1}\nwindexuse{\nwixident{SpreadLocPred}}{SpreadLocPred}{NW4fRSrE-1YXN9Y-1}\nwendcode{}\nwbegindocs{220}\nwdocspar
\nwenddocs{}\nwbegincode{221}\sublabel{NW4fRSrE-41YgVE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-41YgVE-1}}}\moddef{Change bound variable to declaration(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-41YgVE-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeBoundToDecl}{NW4fRSrE-41YgVE-1}(var fTrm: TrmPtr);
begin
  with VarTrmPtr(fTrm)^ do
     if TrmSort=ikTrmBound then
        if VarNr>1 then dec(VarNr)
        else begin TrmSort := ikTrmConstant; inc(VarNr,\nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}) end;
end;
\nwindexdefn{\nwixident{ChangeBoundToDecl}}{ChangeBoundToDecl}{NW4fRSrE-41YgVE-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ChangeBoundToDecl}}{ChangeBoundToDecl}}}\nwidentuses{\\{{\nwixident{gFixedBase}}{gFixedBase}}}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-41YgVE-1}\nwendcode{}\nwbegindocs{222}\nwdocspar
\nwenddocs{}\nwbegincode{223}\sublabel{NW4fRSrE-3IjlED-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3IjlED-1}}}\moddef{Mark term as taken~{\nwtagstyle{}\subpageref{NW4fRSrE-3IjlED-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SetTaken}{NW4fRSrE-3IjlED-1}(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      if (TrmSort=ikTrmConstant) and (VarNr=g.VarNbr) then
      begin TrmSort := ikTrmLocus; VarNr := 1 end;
end;
\nwindexdefn{\nwixident{SetTaken}}{SetTaken}{NW4fRSrE-3IjlED-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{SetTaken}}{SetTaken}}}\nwendcode{}\nwbegindocs{224}\nwdocspar
\nwenddocs{}\nwbegincode{225}\sublabel{NW4fRSrE-4LBoA7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4LBoA7-1}}}\moddef{Chop variables~{\nwtagstyle{}\subpageref{NW4fRSrE-4LBoA7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// ###TODO: the parts creating implications should be removed,
//          check how often it is used in MML, in case of multiple
//          variables it behaves very strangely
// ##NOTE: seems destructive on g.Thesis, so failure
//         probably means that g.Thesis is messed up
// ##TODO: a version using a second formula rather than g.Thesis
//         would be much cleaner and safer
// In the result we pass the numbers of items in Definientia, that were
// succesfully used for chopping, together with their counts.
function \nwlinkedidentc{ChopVars}{NW4fRSrE-4LBoA7-1}(fWidenable,Conclusion: boolean;
                  fPos: Position): NatFuncPtr;
var
   ii,kk,lDefNr: integer;
   lTh: FrmPtr;
   lTyp,lTyp1: TypPtr;
   lDefs: NatFuncPtr;
label ToChop;
begin
   lDefs := new(NatFuncPtr, InitNatFunc(4,4));
   \nwlinkedidentc{ChopVars}{NW4fRSrE-4LBoA7-1} := lDefs;
   if g.Thesis^.FrmSort=ikError then exit;
   for kk := \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}+1 to g.VarNbr do
   begin
      // expand definientia until the thesis is UnivFrm
      for ii := 1 to \nwlinkedidentc{MaxExpansionNbr}{NW4fRSrE-1YXN9Y-1} do
      begin
         \nwlinkedidentc{SpreadLocPred}{NW4fRSrE-35R9Kt-1}(g.Thesis);
         if g.Thesis^.FrmSort = ikFrmUniv then goto ToChop;
         lDefNr := \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}(g.Thesis,Conclusion);
         if lDefNr >= 0 then lDefs^.Up(lDefNr);
         if g.Thesis^.FrmSort = ikError then
         begin Error(fPos,55); lDefs^.DeleteAll; exit end;
      end;
      Error(fPos,55); g.Thesis := NewInCorFrm; lDefs^.DeleteAll; exit;
      ToChop:
         WithinFormula(g.Thesis,\nwlinkedidentc{ChangeBoundToDecl}{NW4fRSrE-41YgVE-1}); inc(\nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1});
         with g.Thesis^ do
      begin
         if FixedVar[kk].nTyp^.TypSort=ikError then
         begin g.Thesis := NewInCorFrm; lDefs^.DeleteAll; exit end;
         if fWidenable then
         begin lTyp := UnivFrmPtr(g.Thesis)^.Quantified^.CopyType;
         \{ Argument IsWiderThan jest rozdysponowywany. \}
         \{ The IsWiderThan argument is distributed. \}
         if not UnivFrmPtr(g.Thesis)^.Quantified^.IsWiderThan(FixedVar[kk].nTyp^.CopyType) then
         begin
            if not FixedVar[kk].nTyp^.IsWiderThan(lTyp^.CopyType)
               or not EqualClusters(FixedVar[kk].nTyp,lTyp,EqAttr) then
            begin Error(fPos,57); g.Thesis := NewInCorFrm; lDefs^.DeleteAll; exit end;
            lTh := UnivFrmPtr(g.Thesis)^.Scope^.CopyFormula;
            dispose(g.Thesis,Done);
            g.Thesis := lTh;
            repeat
               g.Thesis := 
                  NewImpl(NewQualFrm(NewVarTrm(ikTrmConstant,kk),lTyp^.CopyType),g.Thesis);
               lTyp1 := lTyp^.Widening;
               dispose(lTyp,Done);
               lTyp := lTyp1;
            until lTyp^.EqRadices(FixedVar[kk].nTyp);
            dispose(lTyp,Done); exit;
         end;
         dispose(lTyp,Done);
         end
         else if not EqTyp(UnivFrmPtr(g.Thesis)^.Quantified,FixedVar[kk].nTyp) then
         begin
            lTyp := UnivFrmPtr(g.Thesis)^.Quantified^.CopyType;
            if not FixedVar[kk].nTyp^.IsWiderThan(lTyp^.CopyType)
               or not EqualClusters(FixedVar[kk].nTyp,lTyp,EqAttr) then
            begin ErrImm(56); g.Thesis := NewInCorFrm; lDefs^.DeleteAll; exit end;
            lTh := UnivFrmPtr(g.Thesis)^.Scope^.CopyFormula;
            dispose(g.Thesis,Done);
            g.Thesis := lTh;
            repeat
               g.Thesis := 
                  NewImpl(NewQualFrm(NewVarTrm(ikTrmConstant,kk),lTyp^.CopyType),
                          g.Thesis);
               lTyp1 := lTyp^.Widening;
               dispose(lTyp,Done);
               lTyp := lTyp1;
               if lTyp = nil then exit;
            until lTyp^.EqRadices(FixedVar[kk].nTyp);
            dispose(lTyp,Done);
            exit;
         end;
         lTh := g.Thesis;
         g.Thesis := UnivFrmPtr(g.Thesis)^.Scope;
         UnivFrmPtr(lTh)^.Scope := NewVerum; dispose(lTh,Done);
      end;
   end;
end;
\nwindexdefn{\nwixident{ChopVars}}{ChopVars}{NW4fRSrE-4LBoA7-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ChopVars}}{ChopVars}}}\nwidentuses{\\{{\nwixident{ChangeBoundToDecl}}{ChangeBoundToDecl}}\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}}\\{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}\\{{\nwixident{SpreadLocPred}}{SpreadLocPred}}}\nwindexuse{\nwixident{ChangeBoundToDecl}}{ChangeBoundToDecl}{NW4fRSrE-4LBoA7-1}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-4LBoA7-1}\nwindexuse{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}{NW4fRSrE-4LBoA7-1}\nwindexuse{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}{NW4fRSrE-4LBoA7-1}\nwindexuse{\nwixident{SpreadLocPred}}{SpreadLocPred}{NW4fRSrE-4LBoA7-1}\nwendcode{}\nwbegindocs{226}\nwdocspar
\nwenddocs{}\nwbegincode{227}\sublabel{NW4fRSrE-3MC2qH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3MC2qH-1}}}\moddef{Is \code{}Position\edoc{} in the collection?~{\nwtagstyle{}\subpageref{NW4fRSrE-3MC2qH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
\{$IFDEF SKLTTEST\}
function \nwlinkedidentc{PosInCollection}{NW4fRSrE-3MC2qH-1}(fPos : Position): boolean;
var
   res  : boolean;
   i    : integer;
   lPos : PPosition;
begin
   res := false;
   with gThesisPosCollection do
      for i := Count-1 downto 0 do
      begin
             lPos := At(i);
             if (lPos^.Pos.Line = fPos.Line) and (lPos^.Pos.Col = fPos.Col) then
             begin
                res := true;
                break;
             end;
      end;
   \nwlinkedidentc{PosInCollection}{NW4fRSrE-3MC2qH-1} := res;
end;
\{$ENDIF\}
\nwindexdefn{\nwixident{PosInCollection}}{PosInCollection}{NW4fRSrE-3MC2qH-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{PosInCollection}}{PosInCollection}}}\nwendcode{}\nwbegindocs{228}\nwdocspar
\nwenddocs{}\nwbegincode{229}\sublabel{NW4fRSrE-1vzwMI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1vzwMI-1}}}\moddef{Chop conclusion~{\nwtagstyle{}\subpageref{NW4fRSrE-1vzwMI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{ChopConcl}{NW4fRSrE-1vzwMI-1}(fForm: FrmPtr; fPos: Position): NatFuncPtr;
var
   lDefs: NatFuncPtr;
begin
   \{$IFDEF SKLTTEST\}
   \{$IFDEF MDEBUG\}
   if fForm^.FrmSort in [ikFrmConj, ikFrmNeg, ikFrmPred] then
      writeln('w \nwlinkedidentc{ChopConcl}{NW4fRSrE-1vzwMI-1}=',fForm^.FrmSort);
   \{$ENDIF\}
   if not \nwlinkedidentc{PosInCollection}{NW4fRSrE-3MC2qH-1}(fPos) then
      if fForm^.FrmSort <> ikFrmPred then
             WrongSkeleton('Too complex conclusion',fPos);
   \{$ENDIF\}
   if not \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1}(fForm,true,lDefs) then
   begin g.Thesis := NewIncorFrm; Error(fPos,51) end;
   \nwlinkedidentc{ChopConcl}{NW4fRSrE-1vzwMI-1} := lDefs;
end;
\nwindexdefn{\nwixident{ChopConcl}}{ChopConcl}{NW4fRSrE-1vzwMI-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ChopConcl}}{ChopConcl}}}\nwidentuses{\\{{\nwixident{Chopped}}{Chopped}}\\{{\nwixident{PosInCollection}}{PosInCollection}}}\nwindexuse{\nwixident{Chopped}}{Chopped}{NW4fRSrE-1vzwMI-1}\nwindexuse{\nwixident{PosInCollection}}{PosInCollection}{NW4fRSrE-1vzwMI-1}\nwendcode{}\nwbegindocs{230}\nwdocspar
\nwenddocs{}\nwbegincode{231}\sublabel{NW4fRSrE-447LJp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-447LJp-1}}}\moddef{Chop assumption~{\nwtagstyle{}\subpageref{NW4fRSrE-447LJp-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
function \nwlinkedidentc{ChopAssum}{NW4fRSrE-447LJp-1}(fForm: FrmPtr; fPos: Position): NatFuncPtr;
var
   lDefs: NatFuncPtr;
begin
   \{$IFDEF SKLTTEST\}   
   \{$IFDEF MDEBUG\}
   if fForm^.FrmSort in [ikFrmConj, ikFrmNeg, ikFrmPred] then
      writeln('w ChopAssume=',fForm^.FrmSort);
   \{$ENDIF\}
   \{$ENDIF\}
   g.Thesis := NewNegDis(g.Thesis);
   if not \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1}(fForm,false,lDefs) then
   begin g.Thesis := NewIncorFrm; Error(fPos,52);
   end;
   g.Thesis := NewNegDis(g.Thesis);
   \nwlinkedidentc{ChopAssum}{NW4fRSrE-447LJp-1} := lDefs;
end;
\nwindexdefn{\nwixident{ChopAssum}}{ChopAssum}{NW4fRSrE-447LJp-1}\eatline
\nwnotused{Chop assumption}\nwidentdefs{\\{{\nwixident{ChopAssum}}{ChopAssum}}}\nwidentuses{\\{{\nwixident{Chopped}}{Chopped}}}\nwindexuse{\nwixident{Chopped}}{Chopped}{NW4fRSrE-447LJp-1}\nwendcode{}\nwbegindocs{232}\nwdocspar
\nwenddocs{}\nwbegincode{233}\sublabel{NW4fRSrE-14nyvU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-14nyvU-1}}}\moddef{Dispose level~{\nwtagstyle{}\subpageref{NW4fRSrE-14nyvU-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(const f: LevelRec);
var
   i: integer;
begin
   for i := f.VarNbr+1 to g.VarNbr do
   begin
      if FixedVar[i].nExp then DisposeTrm(FixedVar[i].nDef);
      dispose(FixedVar[i].nTyp,Done);
   end;
   LocPredDef.FreeItemsFrom(f.LocPredNbr);
   LocFuncDef.FreeItemsFrom(f.LocFuncNbr);
   g := f;
   \{----\}
   RemoveTermsFromTTColl;
   \{----\}
end;
\nwindexdefn{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-14nyvU-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DisposeLevel}}{DisposeLevel}}}\nwendcode{}\nwbegindocs{234}\nwdocspar
\nwenddocs{}\nwbegincode{235}\sublabel{NW4fRSrE-1ByLHM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1ByLHM-1}}}\moddef{Reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-1ByLHM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1}; forward;

procedure \nwlinkedidentc{HereBy}{NW4fRSrE-4BQSHp-1}(var fFrm: FrmPtr); forward;

// This is used when thesis is known
procedure \nwlinkedidentc{Reasoning}{NW4fRSrE-1ByLHM-1};
var
   lVarBase,i,lId: integer;
   lTrm: TrmPtr;
   lPos: Position;
   lConditions: MCollection;
   lFrm: FrmPtr;
   lTyp: TypPtr;
   lTrmList: TrmList;
   \{$IFDEF SKLTTEST\} ww: Integer; \{$ENDIF\}
   lDefs: NatFuncPtr;
procedure WriteThesis;
begin
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart0(elThesis);
   AReport.Out_Formula(g.Thesis);
   AReport.Out_NatFunc(elThesisExpansions, lDefs^);
   AReport.Out_XElEnd(elThesis);
   \{$ENDIF\}
   dispose(lDefs, Done); lDefs := nil;
end;
begin
   while InFile.Current.Kind <>ikMscEndBlock do
   begin
      case InFile.Current.Kind of
         ikItmGeneralization:
            begin
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elLet);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               if g.Thesis^.FrmSort = ikFrmFlexConj then
                  g.Thesis := FlexFrmPtr(g.Thesis)^.nExpansion;
               \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
               for i := \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}+1 to g.VarNbr do
               begin
                  inc(g.GenCount); \{ trzeba spradzic, czy to potrzebne \}
                  \{you need to check if it is necessary\}
                  FixedVar[i].nSkelConstNr := g.GenCount;
               end;
               \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elLet);
               \{$ENDIF\}
               lDefs := \nwlinkedidentc{ChopVars}{NW4fRSrE-4LBoA7-1}(false,false,lPos);
               WriteThesis;
            end;
         ikItmAssumption:
            begin
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elAssume);
               \{$ENDIF\}
               InFile.InWord;
               \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               \{$IFDEF SKLTTEST\} \{assumption\}
                   with lConditions do for ww := 0 to Count-1 do
                      if PropositionPtr(Items^[ww])^.nSentence^.FrmSort = ikFrmConj then
                             WrongSkeleton('Too complex assumption',lPos);
               \{$ENDIF\}
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elAssume);
               \{$ENDIF\}
               InFile.InWord;
               lFrm := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
               lDefs := \nwlinkedidentc{ChopAssum}{NW4fRSrE-447LJp-1}(lFrm,lPos);
               \{| odwrocona kolejnosc ze wzgledu na obliczanie "thesis" |\}
               lConditions.Done;
               WriteThesis;
            end;
         ikItmExAssumption:
            begin
               lVarBase := g.VarNbr;
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elGiven);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
               \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               InFile.InWord;
               lFrm := \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1}(\nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions));
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propos(0, 0, CurPos, lFrm);
               \{$ENDIF\}
               lDefs := \nwlinkedidentc{ChopAssum}{NW4fRSrE-447LJp-1}(lFrm,lPos);
               \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elGiven);
               \{$ENDIF\}
               lConditions.Done;
               for i := lVarBase+1 to g.VarNbr do FixedVar[i].nSkelConstNr := 0;
               WriteThesis;
            end;
         ikItmExemplifWithEq:
            begin
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elTakeAsVar);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               InFile.InWord; //'I'
               lId := InFile.Current.Nr;
               lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1};
               \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} := g.VarNbr;
               inc(g.VarNbr); mizassert(2521,g.VarNbr<=MaxVarNbr);
               FixedVar[g.VarNbr].nExp := false;
               FixedVar[g.VarNbr].nIdent := lId;
               FixedVar[g.VarNbr].nTyp := GetTrmType(lTrm);
               if g.Thesis^.FrmSort = ikFrmNeg then
                  if NegFrmPtr(g.Thesis)^.NegArg^.FrmSort = ikFrmFlexConj then
                     g.Thesis := NewNeg(FlexFrmPtr(NegFrmPtr(g.Thesis)^.NegArg)^.nExpansion);
               g.Thesis := NewNegDis(g.Thesis);
               lDefs := \nwlinkedidentc{ChopVars}{NW4fRSrE-4LBoA7-1}(true,true,lPos);
               g.Thesis := NewNegDis(g.Thesis);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_TypeWithId(FixedVar[g.VarNbr].nTyp,
                                      FixedVar[g.VarNbr].nIdent);
               AReport.Out_Term(lTrm);
               AReport.Out_XElEnd(elTakeAsVar);
               \{$ENDIF\}
               WriteThesis;
               DisposeTrm(lTrm); InFile.InWord;
            end;
         ikItmSimpleExemplif:
            begin
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elTake);
               \{$ENDIF\}
               lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Term(lTrm);
               AReport.Out_XElEnd(elTake);
               \{$ENDIF\}
               \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} := g.VarNbr; inc(g.VarNbr);
               lTyp := GetTrmType(lTrm);
               FixedVar[g.VarNbr].nIdent := 0;
               FixedVar[g.VarNbr].nTyp := lTyp;
               FixedVar[g.VarNbr].nExp := false;
               if g.Thesis^.FrmSort = ikFrmNeg then
                  if NegFrmPtr(g.Thesis)^.NegArg^.FrmSort = ikFrmFlexConj then
                     g.Thesis := NewNeg(FlexFrmPtr(NegFrmPtr(g.Thesis)^.NegArg)^.nExpansion);
               g.Thesis := NewNegDis(g.Thesis);
               lDefs := \nwlinkedidentc{ChopVars}{NW4fRSrE-4LBoA7-1}(true,true,lPos);
               g.Thesis := NewNegDis(g.Thesis);
               WithInFormula(g.Thesis,\nwlinkedidentc{SetTaken}{NW4fRSrE-3IjlED-1});
               lTrmList := NewTrmList(lTrm,nil);
               lFrm := g.Thesis;
               if lTrmList<>InCorrTrmList then
               begin
                  g.Thesis := InstFrm(g.Thesis,lTrmList);
                  DisposeTrmList(lTrmList);
               end
               else g.Thesis := NewInCorFrm;
               dispose(lFrm,Done);
               dispose(FixedVar[g.VarNbr].nTyp,Done);
               dec(g.VarNbr);
               InFile.InWord;
               WriteThesis;
            end;
         ikItmConclusion:
            begin
               \{$IFDEF FRM2THESIS\}
                   inConclusion := true;
               \{$ENDIF\}
                   InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elConclusion);
               \{$ENDIF\}
               InFile.InWord;
               if InFile.Current.Kind = ikBlcHereby then
                  \nwlinkedidentc{HereBy}{NW4fRSrE-4BQSHp-1}(lFrm)
               else \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1}(lFrm);
               lDefs := \nwlinkedidentc{ChopConcl}{NW4fRSrE-1vzwMI-1}(lFrm,lPos);      
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elConclusion);
               \{$ENDIF\}
               WriteThesis;
               \{$IFDEF FRM2THESIS\}
               inConclusion := false;
               \{$ENDIF\} 
            end;
         ikBlcPerCases: exit;
         ikBlcCase,ikBlcSuppose: exit;
         else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
      end;
      DisplayLine(CurPos.Line,ErrorNbr);
   end;
end;
\nwindexdefn{\nwixident{Reasoning}}{Reasoning}{NW4fRSrE-1ByLHM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Reasoning}}{Reasoning}}}\nwidentuses{\\{{\nwixident{ChopAssum}}{ChopAssum}}\\{{\nwixident{ChopConcl}}{ChopConcl}}\\{{\nwixident{ChopVars}}{ChopVars}}\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{GetQualifiedList}}{GetQualifiedList}}\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{HereBy}}{HereBy}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{ReadTerm}}{ReadTerm}}\\{{\nwixident{RegularStatement}}{RegularStatement}}\\{{\nwixident{SetTaken}}{SetTaken}}\\{{\nwixident{Statement}}{Statement}}\\{{\nwixident{WriteQualified}}{WriteQualified}}\\{{\nwixident{xFormula}}{xFormula}}}\nwindexuse{\nwixident{ChopAssum}}{ChopAssum}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{ChopConcl}}{ChopConcl}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{ChopVars}}{ChopVars}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{GetQualifiedList}}{GetQualifiedList}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{HereBy}}{HereBy}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{ReadTerm}}{ReadTerm}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{RegularStatement}}{RegularStatement}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{SetTaken}}{SetTaken}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-1ByLHM-1}\nwindexuse{\nwixident{xFormula}}{xFormula}{NW4fRSrE-1ByLHM-1}\nwendcode{}\nwbegindocs{236}\nwdocspar
\nwenddocs{}\nwbegincode{237}\sublabel{NW4fRSrE-2IcayZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2IcayZ-1}}}\moddef{Per cases reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-2IcayZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// this is used when thesis is known
procedure \nwlinkedidentc{PerCasesReasoning}{NW4fRSrE-2IcayZ-1};
var
   C: LevelRec;
   itisCase: boolean;
   PerCasesPos,CasePos: Position;
   lInference: InferenceObj;
   lConditions: MCollection;
   lFrm,lThesis,llThesis,PerCasesFrm,FirstDisjunct,Thesis_Tail: FrmPtr;
   lDefNr: integer;
   lPerCasesDefs, lDefs1: NatFuncPtr; // collect Definientia numbers
label 1;
begin
   InFile.InPos(CurPos);
   PerCasesPos := CurPos;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elPerCasesReasoning);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   AReport.Out_XElStart0(elBlockThesis);
   AReport.Out_Formula(g.Thesis);
   AReport.Out_XElEnd(elBlockThesis);
   \{$ENDIF\}
   InFile.InWord;
   LoadInferenceObj(lInference);
   InFile.InWord;
   PerCasesFrm := NewNeg(NewVerum);
   C := g; lThesis := g.Thesis^.CopyFormula;
   C.LocPredNbr := LocPredDef.Count;
   C.LocFuncNbr := LocFuncDef.Count;
   lPerCasesDefs         := new(NatFuncPtr, InitNatFunc(4,4));
   while InFile.Current.Kind <>ikMscEndBlock do
   begin
      case InFile.Current.Kind of
         ikBlcCase:
            begin
               itisCase := true;
               InFile.InPos(CurPos); CasePos := CurPos;
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elCaseBlock);
               AReport.Out_PosAsAttrs(CurPos);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               \{----\}
               MarkTermsInTTColl;
               \{----\}
               InFile.InWord;
               \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               InFile.InWord;
               lFrm := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
               // the PerCasesFrm is disjunction of all cases' suppositions,
               // later we must prove that such disjunction is true.
               PerCasesFrm := NewDisj(PerCasesFrm,lFrm^.CopyFormula);
               if lFrm^.FrmSort=ikError then lThesis := NewInCorFrm;
               if lThesis^.FrmSort=ikError then
               begin g.Thesis := NewInCorFrm; FirstDisjunct := NewInCorFrm; goto 1 end;
               // thesis is disjunction, here we get the first disjunct,
               // which is the thesis of this case; it can however get smaller
               // below, by definitional expansion
               \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewNegDis(lThesis),FirstDisjunct,lThesis);
               FirstDisjunct := NewNegDis(FirstDisjunct);
               lThesis := NewNegDis(lThesis);
               g.Thesis := FirstDisjunct^.CopyFormula;
               \{ Tutaj jest wyjatek, bo lFrm jest kopiowana, w innjych zawolaniach
                 \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} tak nie jest.
                 Problem polega na tym, ze w tym wyjatkowym wypadku,
                 niemoliowsc odciecia nie powoduje bledu i dysponowanie musi byc
                 dokladne !
               \}
               \{ There is an exception here because lFrm is copied,
                 this is not the case in other \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} calls.
                 The problem is that in this exceptional case,
                 the impossibility of the cutoff does not cause an error
                 and the handling must be exact!
                \}
               // now try to spread (apply definiens to) and decompose
               // the FirstDisjunct until lFrm (the case) can be chopped
               // ##TODO: spreading is done in \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} too, why twice?
               while not \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1}(lFrm^.CopyFormula, true, lDefs1) do
               begin
                  dispose(lDefs1, Done); lDefs1 := nil;
                  dispose(g.Thesis,Done);
                  \{ \nwlinkedidentc{Chopped}{NW4fRSrE-1YXN9Y-1} nie dysponuje g.Thesis \}
                  lDefNr := \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}(FirstDisjunct,true);
                  if lDefNr >= 0 then lPerCasesDefs^.Up(lDefNr);
                  if FirstDisjunct^.FrmSort = ikError then
                  begin
                     Error(CasePos,53);
                     g.Thesis := NewInCorFrm;
                     lThesis := NewInCorFrm;
                     dispose(lPerCasesDefs, Done);
                     lPerCasesDefs := nil;
                     break;
                  end;
                  \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewNegDis(FirstDisjunct),FirstDisjunct,Thesis_tail);
                  FirstDisjunct := NewNegDis(FirstDisjunct);
                  Thesis_tail := NewNegDis(Thesis_tail);
                  lThesis := NewDisj(Thesis_tail,lThesis);
                  g.Thesis := FirstDisjunct^.CopyFormula;
               end;
               // lPerCasesDefs <> nil means success above
               if Assigned(lPerCasesDefs) then lPerCasesDefs^.Add(lDefs1^);
               if Assigned(lDefs1) then dispose(lDefs1, Done); lDefs1 := nil;
               1:
                  lFrm := NewImpl(lFrm, g.Thesis^.CopyFormula);
               \{$IFDEF ANALYZER_REPORT\}
               // FirstDisjunct is conjunction of  lConditions and g.Thesis, while
               // this block actually proves that lConditions imply g.Thesis -
               // that's why we have to create the thesis above (not used in preparator)
               // ##NOTE: we have three possibilities for dealing with def expansions here:
               //   (1) print them at the case block thesis
               //   (2) print them at the case item (the first item in the case block)
               //   (3) create additional 'case conclusion' skeleton item preceding the
               //       case block, and print it there
               //   (4) print them at the PerCasesJustification
               // we use (4)
               AReport.Out_XElStart0(elBlockThesis);
               AReport.Out_Formula(lFrm);
               AReport.Out_XElEnd(elBlockThesis);
               AReport.Out_XElStart0(elCase);
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elCase);
               AReport.Out_XElStart0(elThesis);
               AReport.Out_Formula(g.Thesis); // thesis after the case
               AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc); 
               AReport.Out_XElEnd(elThesis);
               \{$ENDIF\}
               dispose(lFrm,Done);
               dispose(FirstDisjunct,Done);
               lConditions.Done;
            end;
         ikBlcSuppose:
            begin
               itisCase := false;
               InFile.InPos(CurPos); CasePos := CurPos;
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elSupposeBlock);
               AReport.Out_PosAsAttrs(CurPos);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               lThesis := C.Thesis^.CopyFormula;
               \{----\}
               MarkTermsInTTColl;
               \{----\}
               InFile.InWord;
               \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               InFile.InWord;
               lFrm := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
               // llThesis is the 'real' thesis of this suppose block
               llThesis := NewImpl(lFrm^.CopyFormula, lThesis^.CopyFormula);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elBlockThesis);
               AReport.Out_Formula(llThesis);
               AReport.Out_XElEnd(elBlockThesis);
               AReport.Out_XElStart0(elSuppose);
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elSuppose);
               AReport.Out_XElStart0(elThesis);
               AReport.Out_Formula(lThesis); // thesis after the suppose
               AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc); 
               AReport.Out_XElEnd(elThesis);
               \{$ENDIF\}
               dispose(llThesis, Done);
               PerCasesFrm := NewDisj(PerCasesFrm,lFrm);
               g.Thesis := lThesis;
               lConditions.Done;
               lThesis := lThesis^.CopyFormula;
            end;
      else RuntimeError(2641);
      end;
      DisplayLine(CurPos.Line,ErrorNbr);
      \nwlinkedidentc{Reasoning}{NW4fRSrE-1ByLHM-1};
      if InFile.Current.Kind = ikBlcPerCases
      then \nwlinkedidentc{PerCasesReasoning}{NW4fRSrE-2IcayZ-1}
      else if (g.Thesis^.FrmSort<>ikFrmVerum) and (g.Thesis^.FrmSort<>ikError)
      then Error(CasePos,60);
      mizassert(2310,InFile.Current.Kind = ikMscEndBlock);
      InFile.InPos(CurPos); InFile.InWord;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_EndPos(CurPos);
      if itisCase then AReport.Out_XElEnd(elCaseBlock)
      else AReport.Out_XElEnd(elSupposeBlock);
      \{$ENDIF\}
      dispose(g.Thesis,Done);
      \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(c);
   end;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart0(elPerCases);
   AReport.Out_Propos(0, 0, CurPos, PerCasesFrm);
   AReport.Out_Inference(lInference);
   AReport.Out_XElEnd(elPerCases);
   AReport.Out_XElStart0(elThesis);
   // thesis after the per cases, this is broken now:
   // for Case blocks, it should be the conjunction
   // of cases theses as implications (rather than cases' theses as
   // conjuctions); for Suppose blocks, it should also rather be
   // conjunction of implications (cases' theses)
   AReport.Out_Formula(lThesis);
   if not Assigned(lPerCasesDefs) then
      lPerCasesDefs      := new(NatFuncPtr, InitNatFunc(0,0));
   // definientia used for cases
   AReport.Out_NatFunc(elThesisExpansions, lPerCasesDefs^);
   AReport.Out_XElEnd(elThesis);
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elPerCasesReasoning);
   \{$ENDIF\}
   dispose(lPerCasesDefs, Done);
   dispose(PerCasesFrm,Done);
   lInference.Done;
   if itisCase then
      if lThesis^.FrmSort <> ikError then
         if lThesis^.FrmSort = ikFrmNeg then
         begin if NegFrmPtr(lThesis)^.NegArg^.FrmSort<> ikFrmVerum then ErrImm(54) end
         else  ErrImm(54);
   dispose(lThesis,Done);
end;
\nwindexdefn{\nwixident{PerCasesReasoning}}{PerCasesReasoning}{NW4fRSrE-2IcayZ-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{PerCasesReasoning}}{PerCasesReasoning}}}\nwidentuses{\\{{\nwixident{Chopped}}{Chopped}}\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{Decompose}}{Decompose}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{Reasoning}}{Reasoning}}\\{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}}\nwindexuse{\nwixident{Chopped}}{Chopped}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{Decompose}}{Decompose}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{Reasoning}}{Reasoning}{NW4fRSrE-2IcayZ-1}\nwindexuse{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}{NW4fRSrE-2IcayZ-1}\nwendcode{}\nwbegindocs{238}\nwdocspar
\nwenddocs{}\nwbegincode{239}\sublabel{NW4fRSrE-2oe4Xh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2oe4Xh-1}}}\moddef{Demonstration~{\nwtagstyle{}\subpageref{NW4fRSrE-2oe4Xh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Demonstration}{NW4fRSrE-2oe4Xh-1}(ThesisId,fLabId: integer; fThesis: FrmPtr);
var
   L: LevelRec;
   Thesis_head: FrmPtr;
   ii: integer;
label Finished;
begin
   \{$IFDEF ANALYZER_REPORT\}
   // making things compatible with simplejustification;
   // the position is probably unnecessary
   AReport.Out_Propos(ThesisId, fLabId, CurPos, fThesis);
   AReport.Out_XElStart(elProof);
   if ThesisId <> 0 then
   begin
      AReport.Out_XIntAttr(atNr, ThesisId);
      AReport.Out_XIntAttr(atVid, fLabId);
   end;
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   AReport.Out_XElStart0(elBlockThesis);
   AReport.Out_Formula(fThesis);
   AReport.Out_XElEnd(elBlockThesis);
   \{$ENDIF\}
   L := g;
   L.LocPredNbr := LocPredDef.Count;
   L.LocFuncNbr := LocFuncDef.Count;
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   g.Thesis := fThesis^.CopyFormula;
   \nwlinkedidentc{Reasoning}{NW4fRSrE-1ByLHM-1};
   if InFile.Current.Kind = ikBlcPerCases then
   begin
      \nwlinkedidentc{PerCasesReasoning}{NW4fRSrE-2IcayZ-1};
      InFile.InPos(CurPos); InFile.InWord; // ikMscEndBlock
   end
   else
   begin
      InFile.InPos(CurPos); InFile.InWord; // ikMscEndBlock
      if (g.Thesis^.FrmSort<>ikFrmVerum) and (g.Thesis^.FrmSort<>ikError) then
      begin
         \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(g.Thesis,Thesis_head,g.Thesis);
         for ii := 1 to \nwlinkedidentc{MaxExpansionNbr}{NW4fRSrE-1YXN9Y-1} do
         begin
            if Thesis_head^.FrmSort = ikFrmVerum then goto Finished;
            // ##TODO: this is never used in MML 853, works only when
            //  someone defined a predicate as 'not contradiction', and
            // the test for only the head being true is very fragile and risky.
            // It should be removed, and def expansions are not collected
            // from it, since I do not want to introduce additional
            // overhead for keeping them at block thesis just because of
            // such rubbish.
            \nwlinkedidentc{SpreadAtomicFormula}{NW4fRSrE-1O513Y-1}(Thesis_head,true);
            if Thesis_head^.FrmSort = ikError then break;
            \nwlinkedidentc{Decompose}{NW4fRSrE-omUgm-1}(NewConj(Thesis_head,g.Thesis),Thesis_head,g.Thesis);
         end;
         if not AxiomsAllowed then
            ErrImm(70);
      end;
      Finished:
         dispose(g.Thesis,Done);
   end;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elProof);
   \{$ENDIF\}
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(L);
end;
\nwindexdefn{\nwixident{Demonstration}}{Demonstration}{NW4fRSrE-2oe4Xh-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Demonstration}}{Demonstration}}}\nwidentuses{\\{{\nwixident{Decompose}}{Decompose}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}}\\{{\nwixident{PerCasesReasoning}}{PerCasesReasoning}}\\{{\nwixident{Reasoning}}{Reasoning}}\\{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}}\nwindexuse{\nwixident{Decompose}}{Decompose}{NW4fRSrE-2oe4Xh-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-2oe4Xh-1}\nwindexuse{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}{NW4fRSrE-2oe4Xh-1}\nwindexuse{\nwixident{PerCasesReasoning}}{PerCasesReasoning}{NW4fRSrE-2oe4Xh-1}\nwindexuse{\nwixident{Reasoning}}{Reasoning}{NW4fRSrE-2oe4Xh-1}\nwindexuse{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}{NW4fRSrE-2oe4Xh-1}\nwendcode{}\nwbegindocs{240}\nwdocspar
\nwenddocs{}\nwbegincode{241}\sublabel{NW4fRSrE-4XBdxo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4XBdxo-1}}}\moddef{Change declared constant to bound variable~{\nwtagstyle{}\subpageref{NW4fRSrE-4XBdxo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmLocus: TrmSort := ikTrmBound;
         ikTrmBound: inc(VarNr,g.GenCount);
         ikTrmConstant:
            if (VarNr>g.DemBase) and (FixedVar[VarNr].nSkelConstNr<>0) then
            begin VarNr := FixedVar[VarNr].nSkelConstNr; TrmSort := ikTrmBound end;
         ikTrmIt:
            begin lTrm := fTrm; fTrm := NewVarTrm(ikTrmBound,g.GenCount);
            dispose(lTrm,Done);
            end;
      end;
end;
\nwindexdefn{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}}\nwendcode{}\nwbegindocs{242}\nwdocspar
{\Tt{}RSNENTRY\nwendquote} is defined in generato.pas, which also defines {\Tt{}SkList\nwendquote}
as an {\Tt{}MCollection\nwendquote} of the types of local constants.
\nwenddocs{}\nwbegincode{243}\sublabel{NW4fRSrE-3KnOnX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3KnOnX-1}}}\moddef{Skeletonize list~{\nwtagstyle{}\subpageref{NW4fRSrE-3KnOnX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SkelList}{NW4fRSrE-3KnOnX-1}(FF: char; frst: integer);
var
   lEntry: RSNENTRY;
   k: integer;
   lTyp: TypPtr;
begin
   new(lEntry);
   with lEntry^ do
   begin
      PreviousEntry := g.LastEntry;
      FORM := FF;
      SkList.Init(g.VarNbr-FRST,0);
      SkOrigTyps.Init(g.VarNbr-FRST,0);
      SkIdents.Init(g.VarNbr-FRST);
      SkFrstConstNr := frst;
      for K := FRST+1 to g.VarNbr do
      begin
         lTyp := FixedVar[k].nTyp^.CopyType;
         \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} := false;
         lTyp^.WithInType(CheckLocConst);
         if \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} then
         begin ErrImm(50); dispose(lTyp,Done); lTyp := NewIncorTyp end;
         if lTyp^.TypSort=ikError then begin g.Err := true; exit end;
         SkOrigTyps.Insert(lTyp^.CopyType);
         lTyp^.WithInType(\nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1});
         SkList.Insert(lTyp);
         SkIdents.Insert(FixedVar[k].nIdent);
      end;
   end;
   g.LastEntry := lEntry;
end;
\nwindexdefn{\nwixident{SkelList}}{SkelList}{NW4fRSrE-3KnOnX-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{SkelList}}{SkelList}}}\nwidentuses{\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}\\{{\nwixident{gConstErr}}{gConstErr}}}\nwindexuse{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-3KnOnX-1}\nwindexuse{\nwixident{gConstErr}}{gConstErr}{NW4fRSrE-3KnOnX-1}\nwendcode{}\nwbegindocs{244}\nwdocspar
\nwenddocs{}\nwbegincode{245}\sublabel{NW4fRSrE-4QAXkH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4QAXkH-1}}}\moddef{Skeletonize sentence~{\nwtagstyle{}\subpageref{NW4fRSrE-4QAXkH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}(FF: char; fFrm: FrmPtr);
var
   lEntry: RSNENTRY;
begin
   \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} := false;
   WithInFormula(fFrm,CheckLocConst);
   if \nwlinkedidentc{gConstErr}{NW4fRSrE-3w2GDr-1} then begin ErrImm(68); g.Err := true; exit end;
   if fFrm^.FrmSort=ikError then begin g.Err := true; exit end;
   new(lEntry);
   with lEntry^ do
   begin
      PreviousEntry := g.LastEntry;
      FORM := FF;
      SkSnt := fFrm;
      DSnt := fFrm^.CopyFormula;
      WithInFormula(fFrm,\nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1});
   end;
   g.LastEntry := lEntry;
end;
\nwindexdefn{\nwixident{SkelSnt}}{SkelSnt}{NW4fRSrE-4QAXkH-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{SkelSnt}}{SkelSnt}}}\nwidentuses{\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}\\{{\nwixident{gConstErr}}{gConstErr}}}\nwindexuse{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-4QAXkH-1}\nwindexuse{\nwixident{gConstErr}}{gConstErr}{NW4fRSrE-4QAXkH-1}\nwendcode{}\nwbegindocs{246}\nwdocspar
\nwenddocs{}\nwbegincode{247}\sublabel{NW4fRSrE-3ug0j6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3ug0j6-1}}}\moddef{Diffuse Reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-3ug0j6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DiffReasoning}{NW4fRSrE-3ug0j6-1};
var
   lVarBase, i, lId: integer;
   lTrm: TrmPtr;
   lPos: Position;
   lConditions: MCollection;
   lFrm: FrmPtr;
begin
   while InFile.Current.Kind <> ikMscEndBlock do
   begin
      case InFile.Current.Kind of
         ikItmGeneralization:
            begin
               InFile.InPos(CurPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elLet);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
               for i := \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1}+1 to g.VarNbr do
               begin
                  inc(g.GenCount);
                  FixedVar[i].nSkelConstNr := g.GenCount;
               end;
               \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elLet);
               \{$ENDIF\}
               \nwlinkedidentc{SkelList}{NW4fRSrE-3KnOnX-1}('D',\nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1});
            end;
         ikItmAssumption:
            begin
               InFile.InPos(lPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elAssume);
               \{$ENDIF\}
               InFile.InWord; \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elAssume);
               \{$ENDIF\}
               InFile.InWord;
               lFrm := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
               \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('A',lFrm);
               lConditions.Done;
            end;
         ikItmExAssumption:
            begin
               lVarBase := g.VarNbr;
               InFile.InPos(CurPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elGiven);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
               \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
               InFile.InWord;
               lFrm := \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1}(\nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions));
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propos(0, 0, CurPos, lFrm);
               \{$ENDIF\}      
               \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('A',lFrm);
               \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Propositions(lConditions);
               AReport.Out_XElEnd(elGiven);
               \{$ENDIF\}
               lConditions.Done;
               for i := lVarBase+1 to g.VarNbr do FixedVar[i].nSkelConstNr := 0;
            end;
         ikItmExemplifWithEq:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart(elTakeAsVar);
               AReport.Out_XIntAttr(atNr, g.VarNbr+1);
               AReport.Out_XAttrEnd;
               \{$ENDIF\}
               InFile.InPos(lPos);
               InFile.InWord; //'I'
               lId := InFile.Current.Nr;
               lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1};
               inc(g.VarNbr); mizassert(2521,g.VarNbr<=MaxVarNbr);
               FixedVar[g.VarNbr].nExp := false;
               FixedVar[g.VarNbr].nIdent := lId;
               FixedVar[g.VarNbr].nTyp := GetTrmType(lTrm);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_TypeWithId(FixedVar[g.VarNbr].nTyp,
                                      FixedVar[g.VarNbr].nIdent);
               AReport.Out_Term(lTrm);
               AReport.Out_XElEnd(elTakeAsVar);
               \{$ENDIF\}
               inc(g.GenCount);
               FixedVar[g.VarNbr].nSkelConstNr := g.GenCount;
               \nwlinkedidentc{SkelList}{NW4fRSrE-3KnOnX-1}('C',g.VarNbr-1);
               DisposeTrm(lTrm); InFile.InWord;
            end;
         ikItmSimpleExemplif:  // probably forbidden without equality
            begin
               InFile.InPos(CurPos);
               ErrImm(64);
               g.Err := true;
               lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1};
               DisposeTrm(lTrm); InFile.InWord;
            end;
         ikItmConclusion:
            begin
               \{$IFDEF FRM2THESIS\}
               inConclusion := true;
               \{$ENDIF\}
               InFile.InPos(CurPos);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elConclusion);
               \{$ENDIF\}
               InFile.InWord;
               if InFile.Current.Kind = ikBlcHereby then
                  \nwlinkedidentc{HereBy}{NW4fRSrE-4BQSHp-1}(lFrm)
               else \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1}(lFrm);
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elConclusion);
               \{$ENDIF\}
               \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('B',lFrm);
               \{$IFDEF FRM2THESIS\}
               inConclusion := false;
               \{$ENDIF\}
            end;
         ikBlcPerCases,ikBlcCase,ikBlcSuppose: exit;
      else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
      end;
      DisplayLine(CurPos.Line,ErrorNbr);
   end;
end;
\nwindexdefn{\nwixident{DiffReasoning}}{DiffReasoning}{NW4fRSrE-3ug0j6-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DiffReasoning}}{DiffReasoning}}}\nwidentuses{\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{GetQualifiedList}}{GetQualifiedList}}\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{HereBy}}{HereBy}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{ReadTerm}}{ReadTerm}}\\{{\nwixident{RegularStatement}}{RegularStatement}}\\{{\nwixident{SkelList}}{SkelList}}\\{{\nwixident{SkelSnt}}{SkelSnt}}\\{{\nwixident{Statement}}{Statement}}\\{{\nwixident{WriteQualified}}{WriteQualified}}\\{{\nwixident{xFormula}}{xFormula}}}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{GetQualifiedList}}{GetQualifiedList}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{HereBy}}{HereBy}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{ReadTerm}}{ReadTerm}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{RegularStatement}}{RegularStatement}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{SkelList}}{SkelList}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{SkelSnt}}{SkelSnt}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-3ug0j6-1}\nwindexuse{\nwixident{xFormula}}{xFormula}{NW4fRSrE-3ug0j6-1}\nwendcode{}\nwbegindocs{248}\nwdocspar
\nwenddocs{}\nwbegincode{249}\sublabel{NW4fRSrE-3S612w-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3S612w-1}}}\moddef{New list of universally quantified variables~{\nwtagstyle{}\subpageref{NW4fRSrE-3S612w-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1}(const FL: MCollection;
                     const Ids: IntSequence;
                     fFrm: FrmPtr): FrmPtr;
var
   k: integer;
begin
   if fFrm^.FrmSort=ikError then begin \nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1} := NewInCorFrm; exit end;
   with FL do
      for k := Count-1 downto 0 do
         fFrm := NewUnivI(Ids.Value(k),TypPtr(Items^[k])^.CopyType,fFrm);
   \nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1} := fFrm;
end;
\nwindexdefn{\nwixident{NewUnivList}}{NewUnivList}{NW4fRSrE-3S612w-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NewUnivList}}{NewUnivList}}}\nwendcode{}\nwbegindocs{250}\nwdocspar
\nwenddocs{}\nwbegincode{251}\sublabel{NW4fRSrE-2UbSlH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2UbSlH-1}}}\moddef{Change skeletonized fixed variable to bound variable~{\nwtagstyle{}\subpageref{NW4fRSrE-2UbSlH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{gSkListCount}{NW4fRSrE-2UbSlH-1}, \nwlinkedidentc{gSkFrstConstNr}{NW4fRSrE-2UbSlH-1}: integer;
procedure \nwlinkedidentc{ChangeSkFixedToBound}{NW4fRSrE-2UbSlH-1}(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmBound: inc(VarNr, \nwlinkedidentc{gSkListCount}{NW4fRSrE-2UbSlH-1});
         ikTrmConstant:
            if VarNr> \nwlinkedidentc{gSkFrstConstNr}{NW4fRSrE-2UbSlH-1} then
            begin TrmSort := ikTrmBound; dec(VarNr,\nwlinkedidentc{gSkFrstConstNr}{NW4fRSrE-2UbSlH-1}) end;
      end;
end;
\nwindexdefn{\nwixident{ChangeSkFixedToBound}}{ChangeSkFixedToBound}{NW4fRSrE-2UbSlH-1}\nwindexdefn{\nwixident{gSkListCount}}{gSkListCount}{NW4fRSrE-2UbSlH-1}\nwindexdefn{\nwixident{gSkFrstConstNr}}{gSkFrstConstNr}{NW4fRSrE-2UbSlH-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ChangeSkFixedToBound}}{ChangeSkFixedToBound}}\\{{\nwixident{gSkFrstConstNr}}{gSkFrstConstNr}}\\{{\nwixident{gSkListCount}}{gSkListCount}}}\nwendcode{}\nwbegindocs{252}\nwdocspar
\nwenddocs{}\nwbegincode{253}\sublabel{NW4fRSrE-aOrsk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-aOrsk-1}}}\moddef{New universal list (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-aOrsk-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// version gradually fixing local consts, needed for proper from of subtheses
function \nwlinkedidentc{NewUnivList1}{NW4fRSrE-aOrsk-1}(const FL: MCollection;
                      const Ids: IntSequence;
                      fFrm: FrmPtr;
                      var fFrstConstNr: integer): FrmPtr;
var
   k: integer;
   lTyp: TypPtr;
begin
   if fFrm^.FrmSort=ikError then begin \nwlinkedidentc{NewUnivList1}{NW4fRSrE-aOrsk-1} := NewInCorFrm; exit end;
   \nwlinkedidentc{gSkFrstConstNr}{NW4fRSrE-2UbSlH-1} := fFrstConstNr;
   \nwlinkedidentc{gSkListCount}{NW4fRSrE-2UbSlH-1} := FL.Count;
   WithInFormula(fFrm, \nwlinkedidentc{ChangeSkFixedToBound}{NW4fRSrE-2UbSlH-1});
   with FL do
      for k := Count-1 downto 0 do
      begin
         dec(\nwlinkedidentc{gSkListCount}{NW4fRSrE-2UbSlH-1}); // needed for \nwlinkedidentc{ChangeSkFixedToBound}{NW4fRSrE-2UbSlH-1} in the type
         lTyp := TypPtr(Items^[k])^.CopyType;
         lTyp^.WithinType(\nwlinkedidentc{ChangeSkFixedToBound}{NW4fRSrE-2UbSlH-1});
         fFrm := NewUnivI(Ids.Value(k), lTyp, fFrm);
      end;
   \nwlinkedidentc{NewUnivList1}{NW4fRSrE-aOrsk-1} := fFrm;
end;
\nwindexdefn{\nwixident{NewUnivList1}}{NewUnivList1}{NW4fRSrE-aOrsk-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{NewUnivList1}}{NewUnivList1}}}\nwidentuses{\\{{\nwixident{ChangeSkFixedToBound}}{ChangeSkFixedToBound}}\\{{\nwixident{gSkFrstConstNr}}{gSkFrstConstNr}}\\{{\nwixident{gSkListCount}}{gSkListCount}}}\nwindexuse{\nwixident{ChangeSkFixedToBound}}{ChangeSkFixedToBound}{NW4fRSrE-aOrsk-1}\nwindexuse{\nwixident{gSkFrstConstNr}}{gSkFrstConstNr}{NW4fRSrE-aOrsk-1}\nwindexuse{\nwixident{gSkListCount}}{gSkListCount}{NW4fRSrE-aOrsk-1}\nwendcode{}\nwbegindocs{254}\nwdocspar
\nwenddocs{}\nwbegincode{255}\sublabel{NW4fRSrE-1FcRyw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1FcRyw-1}}}\moddef{Reasoning result~{\nwtagstyle{}\subpageref{NW4fRSrE-1FcRyw-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
function \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1}(fFrm: FrmPtr; var fSubResults: MCollection): FrmPtr;
var
   lEntry: RSNENTRY;
   lFrm: FrmPtr;
begin
   fSubResults.Init(4,4);
   lFrm := fFrm^.CopyFormula;
   if g.Err then begin \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1} := NewInCorFrm; exit end;
   while g.LastEntry <> nil do
      with g.LastEntry^ do
   begin
      fSubResults.Insert(lFrm^.CopyFormula);
      case FORM of
         'A': begin fFrm := NewImpl(SkSnt,fFrm); lFrm := NewImpl(dSnt,lFrm); end;
         'B': begin fFrm := NewConj(SkSnt,fFrm); lFrm := NewConj(dSnt,lFrm); end;
         'C':
            begin
               fFrm := NewNeg(\nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1}(SkList,SkIdents,NewNegDis(fFrm)));
               lFrm := NewNeg(\nwlinkedidentc{NewUnivList1}{NW4fRSrE-aOrsk-1}(SkOrigTyps,SkIdents,NewNegDis(lFrm),SkFrstConstNr));
               SkList.Done; SkIdents.Done; SkOrigTyps.Done;
            end;
         'D':
            begin
               fFrm := \nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1}(SkList,SkIdents, fFrm);
               lFrm := \nwlinkedidentc{NewUnivList1}{NW4fRSrE-aOrsk-1}(SkOrigTyps,SkIdents, lFrm, SkFrstConstNr);
               SkList.Done; SkIdents.Done; SkOrigTyps.Done;
            end;
      else RunTimeError(2008);
      end;
      lEntry := PreviousEntry;
      dispose(g.LastEntry);
      g.LastEntry := lEntry;
   end;
   dispose(lFrm,Done);
   \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1} := fFrm;
end;
\nwindexdefn{\nwixident{ReasResult}}{ReasResult}{NW4fRSrE-1FcRyw-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{ReasResult}}{ReasResult}}}\nwidentuses{\\{{\nwixident{NewUnivList}}{NewUnivList}}\\{{\nwixident{NewUnivList1}}{NewUnivList1}}}\nwindexuse{\nwixident{NewUnivList}}{NewUnivList}{NW4fRSrE-1FcRyw-1}\nwindexuse{\nwixident{NewUnivList1}}{NewUnivList1}{NW4fRSrE-1FcRyw-1}\nwendcode{}\nwbegindocs{256}\nwdocspar
\nwenddocs{}\nwbegincode{257}\sublabel{NW4fRSrE-1g3pia-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1g3pia-1}}}\moddef{Diffuse per cases reasoning~{\nwtagstyle{}\subpageref{NW4fRSrE-1g3pia-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DiffPerCasesReasoning}{NW4fRSrE-1g3pia-1}(var fResult: FrmPtr);
var
   C: LevelRec;
   lConditions,lSubResults: MCollection;
   lFrm,lGuard,lPerCases,lResult,lPerCasesResult,llThesis,llGuard: FrmPtr;
   lInference: InferenceObj;
   z: integer;
begin
   InFile.InPos(CurPos);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elPerCasesReasoning);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   InFile.InWord;
   LoadInferenceObj(lInference);
   InFile.InWord;
   lPerCases := NewNeg(NewVerum);
   C := g;
   C.LocPredNbr := LocPredDef.Count;
   C.LocFuncNbr := LocFuncDef.Count;
   case InFile.Current.Kind of
      ikBlcCase:
         begin lResult := NewNeg(NewVerum);
         \{----\}
         MarkTermsInTTColl;
         \{----\}
         repeat InFile.InPos(CurPos);
         \{$IFDEF ANALYZER_REPORT\}
         AReport.Out_XElStart(elCaseBlock);
         AReport.Out_PosAsAttrs(CurPos);
         AReport.Out_XAttrEnd;
         \{$ENDIF\}
         InFile.InWord;
         \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
         \{$IFDEF ANALYZER_REPORT\}
         AReport.Out_XElStart0(elCase);
         AReport.Out_Propositions(lConditions);
         AReport.Out_XElEnd(elCase);
         \{$ENDIF\}
         InFile.InWord;
         lGuard := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
         lPerCases := NewDisj(lPerCases,lGuard^.CopyFormula);
         g.Err := false; g.LastEntry := nil;
         \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('B',lGuard^.CopyFormula);
         \nwlinkedidentc{DiffReasoning}{NW4fRSrE-3ug0j6-1};
         lFrm := \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1}(NewVerum, lSubResults);
         if InFile.Current.Kind = ikBlcPerCases then
         begin
            \nwlinkedidentc{DiffPerCasesReasoning}{NW4fRSrE-1g3pia-1}(lPerCasesResult);
            if lPerCasesResult^.FrmSort=ikError then C.Err := true
            else lFrm := NewConj(lFrm,lPerCasesResult);
         end;
         InFile.InPos(CurPos); InFile.InWord;
         // llThesis is the 'real' thesis of this case block, i.e.
         // an implication, not conjunction
         llThesis := NewImpl(lGuard, lFrm^.CopyFormula);
         \{$IFDEF ANALYZER_REPORT\}
         AReport.Out_EndPos(CurPos);
         AReport.Out_XElStart0(elBlockThesis);
         for z := lSubResults.Count-1 downto 0 do
         begin
            AReport.Out_XElStart0(elThesis);
            AReport.Out_Formula(lSubResults.Items^[z]);
            AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc);
            AReport.Out_XElEnd(elThesis);
         end;
         AReport.Out_Formula(llThesis);
         // just as Thesis now, stdprep has to produce a proposition
         AReport.Out_XElEnd(elBlockThesis);
         AReport.Out_XElEnd(elCaseBlock);
         \{$ENDIF\}
         lSubResults.Done;
         lConditions.Done;
         dispose(llThesis, Done);
         if lFrm^.FrmSort=ikError then C.Err := true
         else lResult := NewDisj(lResult,lFrm);
         \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(c);
         until InFile.Current.Kind <> ikBlcCase;
         end;
      ikBlcSuppose:
         begin
            lResult := nil;
            \{----\}
            MarkTermsInTTColl;
            \{----\}
            repeat InFile.InPos(CurPos);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elSupposeBlock);
            AReport.Out_PosAsAttrs(CurPos);
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            InFile.InWord;
            \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart0(elSuppose);
            AReport.Out_Propositions(lConditions);
            AReport.Out_XElEnd(elSuppose);
            \{$ENDIF\}
            InFile.InWord;
            lGuard := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
            lPerCases := NewDisj(lPerCases,lGuard^.CopyFormula);
            g.Err := false; g.LastEntry := nil;
            \nwlinkedidentc{DiffReasoning}{NW4fRSrE-3ug0j6-1};
            lFrm := \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1}(NewVerum,lSubResults);
            if InFile.Current.Kind = ikBlcPerCases then
            begin
               \nwlinkedidentc{DiffPerCasesReasoning}{NW4fRSrE-1g3pia-1}(lPerCasesResult);
               if lPerCasesResult^.FrmSort=ikError then C.Err := true
               else lFrm := NewConj(lFrm,lPerCasesResult);
            end;
            InFile.InPos(CurPos); InFile.InWord;
            // llThesis is the 'real' thesis of this suppose block
            llThesis := NewImpl(lGuard, lFrm^.CopyFormula);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_EndPos(CurPos);
            AReport.Out_XElStart0(elBlockThesis);
            // lFrm is the thesis after suppose, hence it's added
            // as the last subresult
            lSubResults.Insert(lFrm);
            for z := lSubResults.Count-1 downto 0 do
            begin
               AReport.Out_XElStart0(elThesis);
               AReport.Out_Formula(lSubResults.Items^[z]);
               AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc);
               AReport.Out_XElEnd(elThesis);
            end;
            AReport.Out_Formula(llThesis);
            // just as Thesis now, stdprep has to produce a proposition
            AReport.Out_XElEnd(elBlockThesis);
            AReport.Out_XElEnd(elSupposeBlock);
            \{$ENDIF\}
            dec(lSubResults.Count); // not to dispose lFrm
            lSubResults.Done;
            lConditions.Done;
            dispose(llThesis, Done);
            if lFrm^.FrmSort=ikError then C.Err := true;
            //     else
            if lResult = nil then lResult := lFrm
            else
            begin
               if not EqFrm(lResult,lFrm) then ErrImm(59);
               dispose(lFrm,Done);
            end;
            \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(c);
            until InFile.Current.Kind <> ikBlcSuppose;
         end;
   else RunTimeError(2493);
   end;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart0(elPerCases);
   AReport.Out_Propos(0, 0, CurPos, lPerCases);
   AReport.Out_Inference(lInference);
   AReport.Out_XElEnd(elPerCases);
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElStart0(elBlockThesis);
   // just as Thesis now, stdprep has to produce a proposition
   // ###TODO: BUG: lResult can be nil here in incorrect percases,
   //          which prevents Out_Formula; fix that
   if Assigned(lResult) then AReport.Out_Formula(lResult)
   else AReport.Out_Formula(NewInCorFrm);
   AReport.Out_XElEnd(elBlockThesis);
   AReport.Out_XElEnd(elPerCasesReasoning);
   \{$ENDIF\}
   dispose(lPerCases,Done);
   lInference.Done;
   fResult := lResult;
end;
\nwindexdefn{\nwixident{DiffPerCasesReasoning}}{DiffPerCasesReasoning}{NW4fRSrE-1g3pia-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DiffPerCasesReasoning}}{DiffPerCasesReasoning}}}\nwidentuses{\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{DiffReasoning}}{DiffReasoning}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{ReasResult}}{ReasResult}}\\{{\nwixident{SkelSnt}}{SkelSnt}}}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-1g3pia-1}\nwindexuse{\nwixident{DiffReasoning}}{DiffReasoning}{NW4fRSrE-1g3pia-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-1g3pia-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-1g3pia-1}\nwindexuse{\nwixident{ReasResult}}{ReasResult}{NW4fRSrE-1g3pia-1}\nwindexuse{\nwixident{SkelSnt}}{SkelSnt}{NW4fRSrE-1g3pia-1}\nwendcode{}\nwbegindocs{258}\nwdocspar
\nwenddocs{}\nwbegincode{259}\sublabel{NW4fRSrE-8Der7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-8Der7-1}}}\moddef{Diffuse statement~{\nwtagstyle{}\subpageref{NW4fRSrE-8Der7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DiffuseStatement}{NW4fRSrE-8Der7-1}(var fResult: FrmPtr; var fSubResults: MCollection);
var
   L: LevelRec;
   lResult: FrmPtr;
begin
   L := g;
   L.LocPredNbr := LocPredDef.Count;
   L.LocFuncNbr := LocFuncDef.Count;
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   g.LastEntry := nil;
   g.Err := false;
   g.GenCount := 0;
   g.DemBase := g.VarNbr;
   Infile.InWord;
   \nwlinkedidentc{DiffReasoning}{NW4fRSrE-3ug0j6-1};
   if InFile.Current.Kind = ikBlcPerCases then
      \nwlinkedidentc{DiffPerCasesReasoning}{NW4fRSrE-1g3pia-1}(lResult)
   else lResult := NewVerum;
   fResult := \nwlinkedidentc{ReasResult}{NW4fRSrE-1FcRyw-1}(lResult, fSubResults);
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(L);
   InFile.InPos(CurPos);
end;
\nwindexdefn{\nwixident{DiffuseStatement}}{DiffuseStatement}{NW4fRSrE-8Der7-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{DiffuseStatement}}{DiffuseStatement}}}\nwidentuses{\\{{\nwixident{DiffPerCasesReasoning}}{DiffPerCasesReasoning}}\\{{\nwixident{DiffReasoning}}{DiffReasoning}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{ReasResult}}{ReasResult}}}\nwindexuse{\nwixident{DiffPerCasesReasoning}}{DiffPerCasesReasoning}{NW4fRSrE-8Der7-1}\nwindexuse{\nwixident{DiffReasoning}}{DiffReasoning}{NW4fRSrE-8Der7-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-8Der7-1}\nwindexuse{\nwixident{ReasResult}}{ReasResult}{NW4fRSrE-8Der7-1}\nwendcode{}\nwbegindocs{260}\nwdocspar
\nwenddocs{}\nwbegincode{261}\sublabel{NW4fRSrE-4BQSHp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4BQSHp-1}}}\moddef{Hereby~{\nwtagstyle{}\subpageref{NW4fRSrE-4BQSHp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{HereBy}{NW4fRSrE-4BQSHp-1}(var fFrm: FrmPtr);
var
   lFrm: FrmPtr;
   lSubResults: MCollection;
   z: integer;
begin
   InFile.InPos(CurPos);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elNow);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   \nwlinkedidentc{DiffuseStatement}{NW4fRSrE-8Der7-1}(lFrm, lSubResults); InFile.InWord;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   // just as Thesis now, stdprep has to produce a proposition
   AReport.Out_XElStart0(elBlockThesis);
   for z := lSubResults.Count-1 downto 0 do
   begin
      AReport.Out_XElStart0(elThesis);
      AReport.Out_Formula(lSubResults.Items^[z]);
      AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc);
      AReport.Out_XElEnd(elThesis);
   end;
   AReport.Out_Formula(lFrm);
   AReport.Out_XElEnd(elBlockThesis);
   AReport.Out_XElEnd(elNow);
   \{$ENDIF\}
   lSubResults.Done;
   fFrm := lFrm;
end;
\nwindexdefn{\nwixident{HereBy}}{HereBy}{NW4fRSrE-4BQSHp-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{HereBy}}{HereBy}}}\nwidentuses{\\{{\nwixident{DiffuseStatement}}{DiffuseStatement}}}\nwindexuse{\nwixident{DiffuseStatement}}{DiffuseStatement}{NW4fRSrE-4BQSHp-1}\nwendcode{}\nwbegindocs{262}\nwdocspar
\nwenddocs{}\nwbegincode{263}\sublabel{NW4fRSrE-3T8oCT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3T8oCT-1}}}\moddef{Justify~{\nwtagstyle{}\subpageref{NW4fRSrE-3T8oCT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
var \nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1}: InferenceObj;

procedure \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(ThesisId, fLabId: integer; fThesis: FrmPtr);
begin
   InFile.InWord;
   case InFile.Current.Kind of
      '"':
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propos(ThesisId, fLabId, CurPos, fThesis);
            \{$ENDIF\}
            LoadInferenceObj(\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1});
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Inference(\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1});
            \{$ENDIF\}
            \nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1}.Done;
            InFile.InWord;
         end;
      ikBlcProof:
         begin
            InFile.InPos(CurPos);
            Infile.InWord;
            \nwlinkedidentc{Demonstration}{NW4fRSrE-2oe4Xh-1}(ThesisId,fLabId,fThesis);
         end;
      else
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propos(ThesisId, fLabId, CurPos, fThesis);
            AReport.Out_XEl1(elSkippedProof);
            \{$ENDIF\}
         end;
   end;
end;
\nwindexdefn{\nwixident{Justify}}{Justify}{NW4fRSrE-3T8oCT-1}\nwindexdefn{\nwixident{gInference}}{gInference}{NW4fRSrE-3T8oCT-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{gInference}}{gInference}}\\{{\nwixident{Justify}}{Justify}}}\nwidentuses{\\{{\nwixident{Demonstration}}{Demonstration}}}\nwindexuse{\nwixident{Demonstration}}{Demonstration}{NW4fRSrE-3T8oCT-1}\nwendcode{}\nwbegindocs{264}\nwdocspar
\nwenddocs{}\nwbegincode{265}\sublabel{NW4fRSrE-4VrAtu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4VrAtu-1}}}\moddef{Regular statement~{\nwtagstyle{}\subpageref{NW4fRSrE-4VrAtu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
// \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1} here can be:
// \nwlinkedidentc{DiffuseStatement}{NW4fRSrE-8Der7-1}, IterativeEquality, or \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1} proved
// by Simplejustification or Proof, or @Proof
procedure \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1}(var fFrm: FrmPtr);
var
   lPred,i,z,lLabId: integer;
   lLabel: Lexem;
   lFrm: FrmPtr;
   lArgs: TrmList;
   LeftSide,lTrm: TrmPtr;
   lIterSteps,lSubResults: MCollection;
   \{$IFDEF FRM2THESIS\}   
   StartPos, EndPos: Position;
   \{$ENDIF\}
label OK;
begin
   lLabel := InFile.Current;
   InFile.InInt(lLabId);
   InFile.InPos(CurPos);
   \{$IFDEF FRM2THESIS\}   
   StartPos := CurPos;
   \{$ENDIF\}
   InFile.InWord;
   if InFile.Current.Kind=ikBlcDiffuse then
   begin
      InFile.InPos(CurPos);
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elNow);
      if lLabel.Nr <> 0 then
      begin 
         AReport.Out_XIntAttr(atNr, lLabel.Nr);
         AReport.Out_XIntAttr(atVid, lLabId);
      end;
      AReport.Out_PosAsAttrs(CurPos);
      AReport.Out_XAttrEnd;
      \{$ENDIF\}
      \nwlinkedidentc{DiffuseStatement}{NW4fRSrE-8Der7-1}(lFrm,lSubResults); InFile.InWord;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_EndPos(CurPos);
      // just as Thesis now, stdprep has to produce a proposition;
      // the temporary theses are printed in reverse order, so that they
      // correspond to the order of skeleton items;
      AReport.Out_XElStart0(elBlockThesis);
      for z := lSubResults.Count-1 downto 0 do
      begin
         AReport.Out_XElStart0(elThesis);
         AReport.Out_Formula(lSubResults.Items^[z]);
         AReport.Out_NatFunc(elThesisExpansions, EmptyNatFunc); 
         AReport.Out_XElEnd(elThesis);
      end;
      AReport.Out_Formula(lFrm);
      AReport.Out_XElEnd(elBlockThesis);
      AReport.Out_XElEnd(elNow);
      \{$ENDIF\}
      lSubResults.Done;
      fFrm := lFrm;
   end
   else
   begin
      lFrm := \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(false);
      InFile.InWord;
      \{$IFDEF FRM2THESIS\}   
      EndPos := CurPos;
      \{$ENDIF\}
      case InFile.Current.Kind of
         '"':
            begin
               LoadInferenceObj(\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1});
               InFile.InWord;
               if InFile.Current.Kind = ikItmIterEquality then
               begin
                  with lFrm^ do
                     if FrmSort=ikFrmPred then
                     begin AdjustFrm(PredFrmPtr(lFrm),lPred,lArgs);
                     if lPred=gBuiltIn[rqEqualsTo] then
                     begin
                        LeftSide := CopyTerm(lArgs^.XTrmPtr);
                        lTrm := CopyTerm(lArgs^.NextTrm^.XTrmPtr);
                        goto OK;
                     end;
                     end;
                  if lFrm^.FrmSort<>ikError then ErrImm(159);     
                  LeftSide := NewIncorTrm; lTrm := NewIncorTrm;
                  OK:
                     dispose(lFrm,Done);
                  lIterSteps.Init(4,4);
                  lIterSteps.Insert(new(IterStepPtr,Init(lTrm,\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1})));
                  repeat
                     InFile.InPos(CurPos);
                     lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1}; InFile.InWord;
                     LoadInferenceObj(\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1});
                     InFile.InWord;
                     lIterSteps.Insert(new(IterStepPtr,Init(lTrm,\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1})));
                  until InFile.Current.Kind <> ikItmIterEquality;
                  \{$IFDEF ANALYZER_REPORT\}
                  AReport.Out_XElStart(elIterEquality);
                  if lLabel.Nr <> 0 then
                  begin 
                     AReport.Out_XIntAttr(atNr, lLabel.Nr);
                     AReport.Out_XIntAttr(atVid, lLabId);
                  end;
                  AReport.Out_PosAsAttrs(CurPos);
                  AReport.Out_XAttrEnd;
                  AReport.Out_Term(LeftSide);
                  for i := 0 to lIterSteps.Count-1 do
                     AReport.Out_IterStep(IterStepPtr(lIterSteps.Items^[i])^);
                  AReport.Out_XElEnd(elIterEquality);
                  \{$ENDIF\}
                  fFrm := NewEqFrm(LeftSide,CopyTerm(lTrm));
                  lIterSteps.Done;
               end
               else
               begin
                  \{$IFDEF ANALYZER_REPORT\}
                  AReport.Out_Propos(lLabel.Nr, lLabId, CurPos, lFrm);
                  AReport.Out_Inference(\nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1});
                  \{$ENDIF\}
                  fFrm := lFrm;
                  
                  \{$IFDEF FRM2THESIS\}
                  
                  \{$IFDEF MDEBUG\}
                  writeln(infofile,'START');
                  write(infofile,'g.Thesis=');
                  if g.Thesis <> nil then InfoFormula(g.Thesis);
                  writeln(infofile,' ');
                  write(infofile,'fFrm=');
                  if fFrm <> nil then InfoFormula(fFrm);
                  writeln(infofile,' ');
                  writeln(infofile,' ');
                  \{$ENDIF\}
                  if g.Thesis <> nil then
                     if not inSchemeInfer then
                        if inConclusion then
                        begin
                           //            if StrictEqFrm(fFrm,g.Thesis) then Error(StartPos,1000); // it's possible to change
                           if g.Thesis^.FrmSort = '%' then Error(StartPos,1001); // unnecessary 'thus thesis;'
                        end;
                  \{$ENDIF\}
                  
                  \nwlinkedidentc{gInference}{NW4fRSrE-3T8oCT-1}.Done;
               end;
            end;
         ikBlcProof:
            begin
               fFrm := lFrm;
               InFile.InPos(CurPos);
               Infile.InWord;
               \nwlinkedidentc{Demonstration}{NW4fRSrE-2oe4Xh-1}(lLabel.Nr,lLabId,lFrm);
            end;
      else
         // old Preparator just accepts such statements - a bit risky
      begin
         \{$IFDEF ANALYZER_REPORT\}
         AReport.Out_Propos(lLabel.Nr, lLabId, CurPos, lFrm);
         AReport.Out_XEl1(elSkippedProof);
         \{$ENDIF\}
         fFrm := lFrm;
      end;
      end;
   end;
end;
\nwindexdefn{\nwixident{RegularStatement}}{RegularStatement}{NW4fRSrE-4VrAtu-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{RegularStatement}}{RegularStatement}}}\nwidentuses{\\{{\nwixident{Demonstration}}{Demonstration}}\\{{\nwixident{DiffuseStatement}}{DiffuseStatement}}\\{{\nwixident{gInference}}{gInference}}\\{{\nwixident{ReadSentence}}{ReadSentence}}\\{{\nwixident{ReadTerm}}{ReadTerm}}\\{{\nwixident{Statement}}{Statement}}}\nwindexuse{\nwixident{Demonstration}}{Demonstration}{NW4fRSrE-4VrAtu-1}\nwindexuse{\nwixident{DiffuseStatement}}{DiffuseStatement}{NW4fRSrE-4VrAtu-1}\nwindexuse{\nwixident{gInference}}{gInference}{NW4fRSrE-4VrAtu-1}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-4VrAtu-1}\nwindexuse{\nwixident{ReadTerm}}{ReadTerm}{NW4fRSrE-4VrAtu-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-4VrAtu-1}\nwendcode{}\nwbegindocs{266}\nwdocspar
\nwenddocs{}\nwbegincode{267}\sublabel{NW4fRSrE-4XKGIt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4XKGIt-1}}}\moddef{Parse a statement~{\nwtagstyle{}\subpageref{NW4fRSrE-4XKGIt-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-2}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
var
   LocBase,i,lVarBase,lId: integer;
   lFrm: FrmPtr;
   lTrm: TrmPtr;
   lConditions: MCollection;
   lTyp: TypPtr;
   lArgs: MList;
   lExpPtr: ExpPtr;
begin
   lVarBase := g.VarNbr;
   case InFile.Current.Kind of
      ikItmPrivConstant:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elSet);
            AReport.Out_XIntAttr(atNr, g.VarNbr+1);
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            InFile.InWord; //'I'
            lId := InFile.Current.Nr;
            lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1}; InFile.InWord;
            inc(g.VarNbr); mizassert(2520,g.VarNbr<=MaxVarNbr);
            FixedVar[g.VarNbr].nIdent := lId;
            FixedVar[g.VarNbr].nExp := true;
            FixedVar[g.VarNbr].nDef := lTrm;
            FixedVar[g.VarNbr].nTyp := CopyTrmType(lTrm);
            \{ To jest chyba tylko do zachowania numeracji lub na wszelki wypadek \}
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Term(lTrm);
            AReport.Out_TypeWithId(FixedVar[g.VarNbr].nTyp,
                                   FixedVar[g.VarNbr].nIdent);
            AReport.Out_XElEnd(elSet);
            \{$ENDIF\}
         end;
      ikItmPrivFunc:
         begin
            \{----\}
            MarkTermsInTTColl;
            \{----\}
            InFile.InWord;
            lId := InFile.Current.Nr;
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefFunc);
            \{$ENDIF\}
            \nwlinkedidentc{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}(lArgs);
            lTrm := \nwlinkedidentc{ReadTerm}{NW4fRSrE-3YycCO-1};
            lTyp := GetTrmType(lTrm);
            if lTyp^.TypSort=ikError then
               lTyp := AnyTyp^.CopyType;
            LocFuncDef.Insert(new(FuncDefPtr,Init(lId,lArgs,lTrm,lTyp)));
            InFile.InWord;
            with LocFuncDef,FuncDefPtr(Items^[Count-1])^ do
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XIntAttr(atNr, Count);
               AReport.Out_XIntAttr(atVid, lId);
               AReport.Out_XAttrEnd;
               AReport.Out_ArgTypes(fPrimaries);
               AReport.Out_Term(fFuncDef);
               AReport.Out_Type(fFuncTyp);
               AReport.Out_XElEnd(elDefFunc);
               \{$ENDIF\}
            end;
            RemoveTermsFromTTColl;
         end;
      ikItmPrivPred:
         begin
            \{----\}
            MarkTermsInTTColl;
            \{----\}
            InFile.InWord;
            lId := InFile.Current.Nr;
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefPred);
            \{$ENDIF\}
            \nwlinkedidentc{AnalizeArgTypeList}{NW4fRSrE-WoH1u-1}(lArgs);
            BoundVarNbr := 0;
            lFrm := \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(false);
            InFile.InWord;
            RemoveTermsFromTTColl;
            LocPredDef.Insert(new(LocPredDefPtr,Init(lId,lArgs,lFrm)));
            \{$IFDEF ANALYZER_REPORT\}
            with LocPredDef,LocPredDefPtr(Items^[Count-1])^ do
            begin
               AReport.Out_XIntAttr(atNr, Count);
               AReport.Out_XIntAttr(atVid, lId);
               AReport.Out_XAttrEnd;
               AReport.Out_ArgTypes(fPrimaries);
               AReport.Out_Formula(fPredDef);
               AReport.Out_XElEnd(elDefPred);
            end;
            \{$ENDIF\}
         end;
      ikItmReconsidering:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elReconsider);
            AReport.Out_XIntAttr(atNr, g.VarNbr+1);
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            LocBase := g.VarNbr;
            InFile.InWord;
            while InFile.Current.Kind <> ';' do
            begin
               inc(g.VarNbr); mizassert(2522,g.VarNbr<=MaxVarNbr);
               BoundVarNbr := 0;
               InFile.InWord;  // 'I'
               FixedVar[g.VarNbr].nIdent := InFile.Current.Nr;
               lExpPtr := LoadTerm;
               lTrm := lExpPtr^.\nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
               if lTrm^.TrmSort=ikTrmQua then lTrm := QuaTrmPtr(lTrm)^.TrmProper;
               FixedVar[g.VarNbr].nExp := false;
               FixedVar[g.VarNbr].nDef := lTrm;
               InFile.InWord;
            end;
            InFile.InWord;
            lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
            \{$IFDEF ANALYZER_REPORT\}
            for i := LocBase+1 to g.VarNbr do
            begin
               AReport.Out_TypeWithId(lTyp, FixedVar[i].nIdent);
               AReport.Out_Term(FixedVar[i].nDef);
            end;
            \{$ENDIF\}
            for i := LocBase+1 to g.VarNbr do
            begin
               FixedVar[i].nTyp := lTyp^.CopyType;
            end;
            lFrm := NewVerum;
            for i := LocBase+1 to g.VarNbr do
            begin
               \{ sa nie kopiowane i beda rozdysponowane razem z formula \}
               \{ are not copied and will be distributed together with the formula \}
               lFrm := NewConj(lFrm,NewQualFrm(FixedVar[i].nDef,TypPtr(lTyp^.CopyType)));
            end;
            dispose(lTyp,Done);
            \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,lFrm);
            dispose(lFrm,Done);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElEnd(elReconsider);
            \{$ENDIF\}
         end;
      ikItmChoice:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elConsider);
            AReport.Out_XIntAttr(atNr, g.VarNbr+1);
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{GetQualifiedList}{NW4fRSrE-lPUBf-1};
            \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
            lFrm := \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1}(\nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions));
            \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,lFrm);
            dispose(lFrm,Done);
            \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propositions(lConditions);
            AReport.Out_XElEnd(elConsider);
            \{$ENDIF\}      
            lConditions.Done;
         end;
      'E':
         begin
            \nwlinkedidentc{RegularStatement}{NW4fRSrE-4VrAtu-1}(lFrm);
            dispose(lFrm,Done);
         end;
   else
   begin
      \{$IFDEF MDEBUG\}
      writeln(InfoFile,InFile.Current.Kind,'|');
      \{$ENDIF\}
      RunTimeError(2070);
   end;
   end;
   for i := lVarBase+1 to g.VarNbr do FixedVar[i].nSkelConstNr := 0;
end;
\nwindexdefn{\nwixident{Statement}}{Statement}{NW4fRSrE-4XKGIt-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-2}}\nwidentdefs{\\{{\nwixident{Statement}}{Statement}}}\nwidentuses{\\{{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}}\\{{\nwixident{Analyze}}{Analyze}}\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{GetQualifiedList}}{GetQualifiedList}}\\{{\nwixident{Justify}}{Justify}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{ReadSentence}}{ReadSentence}}\\{{\nwixident{ReadTerm}}{ReadTerm}}\\{{\nwixident{ReadType}}{ReadType}}\\{{\nwixident{RegularStatement}}{RegularStatement}}\\{{\nwixident{WriteQualified}}{WriteQualified}}\\{{\nwixident{xFormula}}{xFormula}}}\nwindexuse{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{Analyze}}{Analyze}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{GetQualifiedList}}{GetQualifiedList}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{Justify}}{Justify}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{ReadTerm}}{ReadTerm}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{RegularStatement}}{RegularStatement}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-4XKGIt-1}\nwindexuse{\nwixident{xFormula}}{xFormula}{NW4fRSrE-4XKGIt-1}\nwendcode{}\nwbegindocs{268}\nwdocspar
\section{Properties}

\nwenddocs{}\nwbegincode{269}\sublabel{NW4fRSrE-24b9uj-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-3}}}\moddef{Analyzer methods~{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwprevnextdefs{NW4fRSrE-24b9uj-2}{NW4fRSrE-24b9uj-4}\nwenddeflinemarkup
\{--- Start analysis of Properties ---\}
\LA{}Change loci in property~{\nwtagstyle{}\subpageref{NW4fRSrE-9km4y-1}}\RA{}
\LA{}Change loci in sethood property~{\nwtagstyle{}\subpageref{NW4fRSrE-321b6z-1}}\RA{}
\LA{}Swap loci in type~{\nwtagstyle{}\subpageref{NW4fRSrE-zQWZB-1}}\RA{}
\LA{}Parse predicate property~{\nwtagstyle{}\subpageref{NW4fRSrE-3HK6tf-1}}\RA{}
\LA{}Parse functor property~{\nwtagstyle{}\subpageref{NW4fRSrE-1a7Xmh-1}}\RA{}
\LA{}Parse mode property~{\nwtagstyle{}\subpageref{NW4fRSrE-2OQ1CR-1}}\RA{}
\LA{}Set visible (two)~{\nwtagstyle{}\subpageref{NW4fRSrE-3HTkW-1}}\RA{}
\LA{}Set visible (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-Aye6w-1}}\RA{}
\LA{}Process properties~{\nwtagstyle{}\subpageref{NW4fRSrE-18EWMX-1}}\RA{}
\{--- End Properties ---\}
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{270}\nwdocspar

\nwenddocs{}\nwbegincode{271}\sublabel{NW4fRSrE-9km4y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-9km4y-1}}}\moddef{Change loci in property~{\nwtagstyle{}\subpageref{NW4fRSrE-9km4y-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
var \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1},\nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1},\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}, \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}: integer;

procedure \nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmBound: inc(VarNr,gBoundInc);
         ikTrmConstant:
            begin
               if VarNr = \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} then
               begin TrmSort := ikTrmBound; VarNr := gBoundForFirst; exit end;
               if VarNr = \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} then
               begin TrmSort := ikTrmBound; VarNr := gBoundForSecond; exit end;
            end;
         ikTrmIt:
            begin lTrm := fTrm; fTrm := NewVarTrm(ikTrmBound,gBoundForIt);
            dispose(lTrm,Done);
            end;
      end;
end;
\nwindexdefn{\nwixident{ChangeLociInProperty}}{ChangeLociInProperty}{NW4fRSrE-9km4y-1}\nwindexdefn{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-9km4y-1}\nwindexdefn{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-9km4y-1}\nwindexdefn{\nwixident{gFirstArg}}{gFirstArg}{NW4fRSrE-9km4y-1}\nwindexdefn{\nwixident{gSecondArg}}{gSecondArg}{NW4fRSrE-9km4y-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{ChangeLociInProperty}}{ChangeLociInProperty}}\\{{\nwixident{gFirstArg}}{gFirstArg}}\\{{\nwixident{gSecondArg}}{gSecondArg}}\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}}\nwendcode{}\nwbegindocs{272}\nwdocspar
\nwenddocs{}\nwbegincode{273}\sublabel{NW4fRSrE-321b6z-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-321b6z-1}}}\moddef{Change loci in sethood property~{\nwtagstyle{}\subpageref{NW4fRSrE-321b6z-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeLociInPropertySetHood}{NW4fRSrE-321b6z-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmBound: inc(VarNr,gBoundInc);
         ikTrmIt:
            begin
               lTrm := fTrm;
               fTrm := NewVarTrm(ikTrmBound,gBoundForIt);
               dispose(lTrm,Done);
            end;
      end;
end;
\nwindexdefn{\nwixident{ChangeLociInPropertySetHood}}{ChangeLociInPropertySetHood}{NW4fRSrE-321b6z-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{ChangeLociInPropertySetHood}}{ChangeLociInPropertySetHood}}}\nwendcode{}\nwbegindocs{274}\nwdocspar
\nwenddocs{}\nwbegincode{275}\sublabel{NW4fRSrE-zQWZB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-zQWZB-1}}}\moddef{Swap loci in type~{\nwtagstyle{}\subpageref{NW4fRSrE-zQWZB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SwapLociInType}{NW4fRSrE-zQWZB-1}(var fTrm: TrmPtr);
begin
   with VarTrmPtr(fTrm)^ do
      case TrmSort of
         ikTrmConstant:
            begin
               if VarNr = \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} then begin VarNr := \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}; exit end;
               if VarNr = \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} then begin VarNr := \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}; exit end;
            end;
      else
      end;
end;
\nwindexdefn{\nwixident{SwapLociInType}}{SwapLociInType}{NW4fRSrE-zQWZB-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{SwapLociInType}}{SwapLociInType}}}\nwidentuses{\\{{\nwixident{gFirstArg}}{gFirstArg}}\\{{\nwixident{gSecondArg}}{gSecondArg}}}\nwindexuse{\nwixident{gFirstArg}}{gFirstArg}{NW4fRSrE-zQWZB-1}\nwindexuse{\nwixident{gSecondArg}}{gSecondArg}{NW4fRSrE-zQWZB-1}\nwendcode{}\nwbegindocs{276}\nwdocspar
\nwenddocs{}\nwbegincode{277}\sublabel{NW4fRSrE-3HK6tf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3HK6tf-1}}}\moddef{Parse predicate property~{\nwtagstyle{}\subpageref{NW4fRSrE-3HK6tf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(fProp: integer);
begin
   if RedefAntonym then
      case fProp of
         2: fProp := 3;
         3: fProp := 2;
         7: fProp := 8;
         8: fProp := 7;
      end;
   with gProperties do
   begin
      nFirstArg := \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1};
      nSecondArg := \nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1};
      include(Properties,PropertyKind(fProp));
   end;
end;
\nwindexdefn{\nwixident{PredProperty}}{PredProperty}{NW4fRSrE-3HK6tf-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{PredProperty}}{PredProperty}}}\nwidentuses{\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}}\nwindexuse{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-3HK6tf-1}\nwindexuse{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-3HK6tf-1}\nwendcode{}\nwbegindocs{278}\nwdocspar
\nwenddocs{}\nwbegincode{279}\sublabel{NW4fRSrE-1a7Xmh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1a7Xmh-1}}}\moddef{Parse functor property~{\nwtagstyle{}\subpageref{NW4fRSrE-1a7Xmh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(fProp: integer);
begin
   with gProperties do
   begin
      nFirstArg := \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1};
      nSecondArg := \nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1};
      include(Properties,PropertyKind(fProp));
   end;
end;
\nwindexdefn{\nwixident{FuncProperty}}{FuncProperty}{NW4fRSrE-1a7Xmh-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{FuncProperty}}{FuncProperty}}}\nwidentuses{\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}}\nwindexuse{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-1a7Xmh-1}\nwindexuse{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-1a7Xmh-1}\nwendcode{}\nwbegindocs{280}\nwdocspar
\nwenddocs{}\nwbegincode{281}\sublabel{NW4fRSrE-2OQ1CR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2OQ1CR-1}}}\moddef{Parse mode property~{\nwtagstyle{}\subpageref{NW4fRSrE-2OQ1CR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ModeProperty}{NW4fRSrE-2OQ1CR-1}(fProp: integer);
begin
   with gProperties do
   begin
      nFirstArg := 0;
      nSecondArg := 0;
      include(Properties,PropertyKind(fProp));
   end;
end;
\nwindexdefn{\nwixident{ModeProperty}}{ModeProperty}{NW4fRSrE-2OQ1CR-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{ModeProperty}}{ModeProperty}}}\nwendcode{}\nwbegindocs{282}\nwdocspar
\nwenddocs{}\nwbegincode{283}\sublabel{NW4fRSrE-3HTkW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3HTkW-1}}}\moddef{Set visible (two)~{\nwtagstyle{}\subpageref{NW4fRSrE-3HTkW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SetVisible2}{NW4fRSrE-3HTkW-1}(ff: char);
var
   lVisible: IntSequencePtr;
begin
   gStatusOfProperties := 2;
   lVisible := nil;
   case ff of
      'R':
         with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
                                     lVisible := @Visible;
      'K':
         with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                                   lVisible := @Visible;
      else RunTimeError(2999);
   end;
   if lVisible^.fCount = 2 then
   begin
      gStatusOfProperties := 3;
      \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1} := lVisible^.fList^[0];
      \nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1} := lVisible^.fList^[1];
      if (\nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1} = 0) or (\nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1} = 0) then exit;
      \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} := LocusAsConst[\nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1}];
      \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} := LocusAsConst[\nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1}];
      if StrictEqTyp(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp,FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp) then
      begin
         gStatusOfProperties := 4;
      \{ Przy absolutnej permisywnosci bedzie mozna opuscic
        warunek. Trzeba jednak wymagac aby zalozenie, takze
        ukryte, tzn. koniunkcja negacji dozorow, jezeli
        brak "otherwise" byla symetryczna.
      \}
      \{ If you are absolutely permissive, you will be able to skip
        the condition. However, it is necessary to require that the assumption, also
        hidden, i.e. the conjunction of the negation of supervisions, if
        there is no "otherwise", is symmetric.
      \}
         if gNonPermissive then
            if (gDefiniens = nil) or (gDefiniens^.nOtherwise <> nil) then
               gStatusOfProperties := 1;
      end;
   end;
end;
\nwindexdefn{\nwixident{SetVisible2}}{SetVisible2}{NW4fRSrE-3HTkW-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{SetVisible2}}{SetVisible2}}}\nwidentuses{\\{{\nwixident{gFirstArg}}{gFirstArg}}\\{{\nwixident{gSecondArg}}{gSecondArg}}\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}}\nwindexuse{\nwixident{gFirstArg}}{gFirstArg}{NW4fRSrE-3HTkW-1}\nwindexuse{\nwixident{gSecondArg}}{gSecondArg}{NW4fRSrE-3HTkW-1}\nwindexuse{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-3HTkW-1}\nwindexuse{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-3HTkW-1}\nwendcode{}\nwbegindocs{284}\nwdocspar
\nwenddocs{}\nwbegincode{285}\sublabel{NW4fRSrE-Aye6w-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-Aye6w-1}}}\moddef{Set visible (one)~{\nwtagstyle{}\subpageref{NW4fRSrE-Aye6w-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{SetVisible1}{NW4fRSrE-Aye6w-1}(ff: char);
begin
   gStatusOfProperties := 2;
   if ff <> 'K' then RunTimeError(2999);
   with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
   if Visible.fCount = 1 then
   begin
      gStatusOfProperties := 3;
      \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1} := Visible.fList^[0]; \nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1} := 0;
      if \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1} = 0 then exit;
      \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} := LocusAsConst[\nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1}];
      \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} := 0;
      gStatusOfProperties := 4;
      if gNonPermissive then
         if (gDefiniens = nil) or (gDefiniens^.nOtherwise <> nil) then
            gStatusOfProperties := 1;
   end;
end;
\nwindexdefn{\nwixident{SetVisible1}}{SetVisible1}{NW4fRSrE-Aye6w-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{SetVisible1}}{SetVisible1}}}\nwidentuses{\\{{\nwixident{gFirstArg}}{gFirstArg}}\\{{\nwixident{gSecondArg}}{gSecondArg}}\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}}\nwindexuse{\nwixident{gFirstArg}}{gFirstArg}{NW4fRSrE-Aye6w-1}\nwindexuse{\nwixident{gSecondArg}}{gSecondArg}{NW4fRSrE-Aye6w-1}\nwindexuse{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-Aye6w-1}\nwindexuse{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-Aye6w-1}\nwendcode{}\nwbegindocs{286}\nwdocspar
\nwenddocs{}\nwbegincode{287}\sublabel{NW4fRSrE-18EWMX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-18EWMX-1}}}\moddef{Process properties~{\nwtagstyle{}\subpageref{NW4fRSrE-18EWMX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-3}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}(ff: char);
var
   lPropCond: FrmPtr;
   function TheFormula(fBoundInc,fIt,fBound1,fBound2: integer): FrmPtr;
   var
      lFrm,lOth,llFrm: FrmPtr;
      z: integer;
   begin
      if gDefiniens = nil then
      begin
         \{ Jezeli gDefiniens = nil, to to musi byc redefinicja, inaczej
           jedyna formula, ktora mozna wyprodukowac jest bledna.
         \}
         \{ If gDefiniens = nil, then this must be a redefinition, otherwise
           the only formula that can be produced is incorrect. \}
         if gRedef then
            with Notat[noPredicate], PatternPtr(Items^[Count+fExtCount-1])^ do
            lFrm := NewPredFrm(ikFrmPred,gWhichOne,\nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(fPrimTypes.Count),Count+fExtCount)
         else lFrm := NewIncorFrm;
      end
      else
         with gDefiniens^ do
      begin
         mizassert(2601,nOtherwise <> nil);
         lFrm := NewVerum; lOth := NewVerum;
         with nPartialDefinientia do
            for z := 0 to Count-1 do
               with PartDefPtr(Items^[z])^ do
            begin
               lOth := NewConj(lOth,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
               case DefSort of
                  'm': llFrm := FrmPtr(nPartDefiniens)^.CopyFormula;
                  'e': llFrm := NewEqFrm(NewItTrm,CopyTerm(TrmPtr(nPartDefiniens)));
               else RunTimeError(2511);
               end;
               lFrm := NewConj(lFrm,NewImpl(FrmPtr(nGuard)^.CopyFormula,llFrm));
            end;
         case DefSort of
            'm': llFrm := FrmPtr(gDefiniens^.nOtherwise)^.CopyFormula;
            'e': llFrm := NewEqFrm(NewItTrm,CopyTerm(TrmPtr(gDefiniens^.nOtherwise)));
         else RunTimeError(2512);
         end;
         lFrm := NewConj(lFrm,NewImpl(lOth,llFrm));
      end;
      gBoundInc := fBoundInc;
      gBoundForFirst := fBound1; gBoundForSecond := fBound2;
      gBoundForIt := fIt;
      WithinFormula(lFrm,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
      TheFormula := lFrm;
   end;
   
   function Reflexivity:FrmPtr;
   begin
      if not RedefAntonym then
         Reflexivity := 
            NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                     TheFormula(1,1,1,1))
      else Reflexivity := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewNegDis(TheFormula(1,1,1,1)));
   end;
   
   function Irreflexivity:FrmPtr;
   begin
      if not RedefAntonym then
         Irreflexivity := 
            NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                     NewNegDis(TheFormula(1,1,1,1)))
      else Irreflexivity := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  TheFormula(1,1,1,1));
   end;
   
   function Symmetry: FrmPtr;
   begin
      if not RedefAntonym then Symmetry := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(TheFormula(2,1,1,2),
                                   TheFormula(2,1,2,1))))
      else Symmetry := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(NewNegDis(TheFormula(2,1,1,2)),
                                   NewNegDis(TheFormula(2,1,2,1)))));
   end;
   
   function Asymmetry: FrmPtr;
   begin
      if not RedefAntonym then Asymmetry := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(TheFormula(2,1,1,2),
                                   NewNegDis(TheFormula(2,1,2,1)))))
      else Asymmetry := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(NewNegDis(TheFormula(2,1,1,2)),
                                   TheFormula(2,1,2,1))));
   end;
   
   function Connectedness: FrmPtr;
   begin
      if not RedefAntonym then Connectedness := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(NewNegDis(TheFormula(2,1,1,2)),
                                   TheFormula(2,1,2,1))))
      else Connectedness := 
         NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                  NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                           NewImpl(TheFormula(2,1,1,2),
                                   NewNegDis(TheFormula(2,1,2,1)))));
   end;
   
var
   gPropPos: Position;
   
   function Commutativity: FrmPtr;
   var lTrm1,lTrm2:TrmPtr; lLength:integer;
   lTypPtr: TypPtr;
   begin
      with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                                lLength := fPrimTypes.Count;
      \{ Konieczna jest kontrola typu: czy przy przestawieniu argumentow
        sie przypadkiem typ ItTyp nie zmienia.
        Informacja od Grzegorza.
      \}
      \{ It is necessary to check the type: whether the ItTyp type changes
        when the arguments are changed. Information from Grzegorz. \}
      lTypPtr := ItTyp^.CopyType;
      lTypPtr^.WithinType(\nwlinkedidentc{SwapLociInType}{NW4fRSrE-zQWZB-1});
      if not EqTyp(ItTyp,lTypPtr) then Error(gPropPos,84);
      dispose(lTypPtr,Done);
      
      if gDefiniens = nil then
         \{ Wyjatek z ogolnych regul. Uproszczona formula ! \}
         \{Exception from general regulations. Simplified formula! \}
         if gRedef then
         begin
            gBoundInc := 2;
            gBoundForFirst := 1; gBoundForSecond := 2;
            lTrm1 := NewFuncTrm(gWhichOne,\nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(lLength));
            WithinTerm(lTrm1,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
            gBoundForFirst := 2; gBoundForSecond := 1;
            lTrm2 := NewFuncTrm(gWhichOne,\nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(lLength));
            WithinTerm(lTrm2,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
            Commutativity := 
               NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                        NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                                 NewEqFrm(lTrm1,lTrm2)));
         end
         else Commutativity := NewIncorFrm
         else
            Commutativity := 
               NewUniv(ItTyp^.CopyType,
                       NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                                NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                                         NewImpl(TheFormula(3,1,2,3),TheFormula(3,1,3,2)))));
   end;
   
   function Idempotence: FrmPtr;
   var lVisible1,lFirstArg:Integer;
   begin
      with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                                lVisible1 := Visible.fList^[0];
      lFirstArg := LocusAsConst[lVisible1];
      if not ItTyp^.IsWiderThan(FixedVar[lFirstArg].nTyp^.CopyType) then
      begin
         Idempotence := NewIncorFrm;
         Error(gPropPos,78);
         exit;
      end;
      if gRedef then
      begin
         Idempotence := NewIncorFrm;
         Error(gPropPos,89);
      end
      else
         if gDefiniens = nil then Idempotence := NewIncorFrm
         else
            Idempotence := NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,
                                    FixedVar[lFirstArg].nTyp^.CopyType,TheFormula(1,1,1,1));
   end;
   
   function Involutiveness: FrmPtr;
   var lVisible1,lFirstArg:Integer;
   begin
      with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                                lVisible1 := Visible.fList^[0];
      lFirstArg := LocusAsConst[lVisible1];
      if not EqTyp(ItTyp,FixedVar[lFirstArg].nTyp) then
      begin
         Involutiveness := NewIncorFrm;
         Error(gPropPos,85);
         exit;
      end;
      if gRedef then
      begin
         Involutiveness := NewIncorFrm;
         Error(gPropPos,89);
      end
      else
         if gDefiniens = nil then Involutiveness := NewIncorFrm
         else
            Involutiveness := NewUniv(ItTyp^.CopyType,NewUniv(ItTyp^.CopyType,
                                                              NewImpl(TheFormula(2,1,2,0),TheFormula(2,2,1,0))));
   end;
   
   function Projectivity: FrmPtr;
   var lVisible1,lFirstArg:Integer;
   lTyp:TypPtr;
   begin
      with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
                                lVisible1 := Visible.fList^[0];
      lFirstArg := LocusAsConst[lVisible1];
      lTyp := ItTyp^.CopyType;
      if lTyp^.TypSort <> ikError then
         lTyp := FixedVar[lFirstArg].nTyp^.WideningOf(lTyp);
      if (lTyp = nil) or (lTyp^.TypSort = ikError) or
            not lTyp^.EqRadices(FixedVar[lFirstArg].nTyp) or
            not FixedVar[lFirstArg].nTyp^.LowerCluster^.IsSubsetOf(lTyp^.UpperCluster,EqAttr)
      then
      begin
         Projectivity := NewIncorFrm;
         Error(gPropPos,85);
         if lTyp <> nil then dispose(lTyp,Done);
         exit;
      end;
      dispose(lTyp,Done);
      if gRedef then
      begin
         Projectivity := NewIncorFrm;
         Error(gPropPos,89);
      end
      else
         if gDefiniens = nil then Projectivity := NewIncorFrm
         else
            Projectivity := NewUniv(ItTyp^.CopyType,NewUniv(FixedVar[lFirstArg].nTyp^.CopyType,
                                                            NewImpl(TheFormula(2,1,2,0),TheFormula(2,1,1,0))));
   end;
   
   function Associativity: FrmPtr;
   var lTrm1,lTrm2:TrmPtr;
   lLength:integer;
   begin
      ErrImm(77);
      Associativity := NewIncorFrm;
      exit;
      with Notat[noFunctor], PatternPtr(Items^[Count+fExtCount-1])^ do
      begin
         lLength := fPrimTypes.Count;
      end;
      if (\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} = 0) or (\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} = 0) then
      begin
         Associativity := NewIncorFrm;
         Error(gPropPos,85);
         exit;
      end;
      if not EqTyp(ItTyp,FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp) and
            not EqTyp(ItTyp,FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp)  then
      begin
         Associativity := NewIncorFrm;
         Error(gPropPos,85);
         exit;
      end;
      if gDefiniens = nil then
         if gRedef then
         begin gBoundInc := 2;
         gBoundForFirst := 1; gBoundForSecond := 2;
         lTrm1 := NewFuncTrm(gWhichOne,\nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(lLength));
         WithinTerm(lTrm1,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
         gBoundForFirst := 2; gBoundForSecond := 1;
         lTrm2 := NewFuncTrm(gWhichOne,\nwlinkedidentc{LociList}{NW4fRSrE-1OwTRj-1}(lLength));
         WithinTerm(lTrm2,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
         Associativity := 
            NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                     NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                              NewEqFrm(lTrm1,lTrm2)));
         //for x,x,z st holds F(F(x,y),z) = F(x,F(y,z))
         end
         else Associativity := NewIncorFrm
         else
            Associativity := 
               NewUniv(ItTyp^.CopyType,
                       NewUnivI(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                                NewUnivI(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nIdent,TypPtr(FixedVar[\nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1}].nTyp^.CopyType),
                                         NewImpl(TheFormula(3,1,2,3),TheFormula(3,1,3,2)))));
      
      // function TheFormula(fBoundInc,fIt,fBound1,fBound2:integer):FrmPtr;
      //for it,xy,yz,x,x,z st P[it,xy,z] & P[xy,x,y] & P[yz,y,z]
      //  holds P[it,x,yz]
      
   end;
   
   function Transitivity: FrmPtr;
   begin
      ErrImm(77);
      Transitivity := NewIncorFrm;
   end;
   
   function Sethood: FrmPtr;
   var
      lFrm,lOth,llFrm: FrmPtr;
      z: integer;
   begin
      if gDefiniens = nil then
      begin
         lFrm := NewIncorFrm;
      end
      else
         with gDefiniens^ do
      begin
         gBoundInc := 2;
         gBoundForFirst := 0; gBoundForSecond := 0;
         gBoundForIt := 2;
         if nPartialDefinientia.Count = 0 then
         begin
            mizassert(2591,nOtherwise <> nil);
            lFrm := FrmPtr(gDefiniens^.nOtherwise)^.CopyFormula;
            WithinFormula(lFrm, \nwlinkedidentc{ChangeLociInPropertySetHood}{NW4fRSrE-321b6z-1});
            lFrm := NewExis(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                           gBuiltIn[rqSetMode],nil),
                            NewUniv(ItTyp^.CopyType,
                                    NewImpl(lFrm,
                                            NewPredFrm(ikFrmPred,gBuiltIn[rqBelongsTo],
                                                       NewTrmList(NewVarTrm(ikTrmBound,2),
                                                                  NewTrmList(NewVarTrm(ikTrmBound,1),nil)),0))));
         end
         else
         begin
            mizassert(2592,nOtherwise <> nil);
            lFrm := nil; lOth := NewVerum;
            with nPartialDefinientia do
               for z := 0 to Count-1 do
                  with PartDefPtr(Items^[z])^ do
               begin
                  lOth := NewConj(lOth,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
                  llFrm := FrmPtr(nPartDefiniens)^.CopyFormula;
                  WithinFormula(llFrm,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
                  llFrm := NewExis(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                                  gBuiltIn[rqSetMode],nil),
                                   NewUniv(ItTyp^.CopyType,
                                           NewImpl(llFrm,
                                                   NewPredFrm(ikFrmPred,gBuiltIn[rqBelongsTo],
                                                              NewTrmList(NewVarTrm(ikTrmBound,2),
                                                                         NewTrmList(NewVarTrm(ikTrmBound,1),nil)),0))));
                  llFrm := NewConj(FrmPtr(nGuard)^.CopyFormula,llFrm);
                  if lFrm = nil
                  then lFrm := llFrm
                  else lFrm := NewDisj(lFrm,NewConj(FrmPtr(nGuard)^.CopyFormula,llFrm));
               end;
            llFrm := FrmPtr(gDefiniens^.nOtherwise)^.CopyFormula;
            WithinFormula(llFrm,\nwlinkedidentc{ChangeLociInProperty}{NW4fRSrE-9km4y-1});
            llFrm := NewExis(NewStandardTyp(ikTypMode,NewEmptyCluster,NewEmptyCluster,
                                            gBuiltIn[rqSetMode],nil),
                             NewUniv(ItTyp^.CopyType,
                                     NewImpl(llFrm,
                                             NewPredFrm(ikFrmPred,gBuiltIn[rqBelongsTo],
                                                        NewTrmList(NewVarTrm(ikTrmBound,2),
                                                                   NewTrmList(NewVarTrm(ikTrmBound,1),nil)),0))));
            lFrm := NewDisj(lFrm,NewConj(lOth,llFrm));
         end;
      end;
      SetHood := lFrm;
   end;
   
begin  \{--- \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1} ---\}
   while InFile.Current.Kind = 'X' do
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart0(elJustifiedProperty);
      AReport.Out_XEl1(Prop2XmlElem[ PropertyKind(InFile.Current.Nr)]);
      \{$ENDIF\}
      gStatusOfProperties := 0;
      case ff of
         'R','K':
            if InFile.Current.Nr in [1..9] then \nwlinkedidentc{SetVisible2}{NW4fRSrE-3HTkW-1}(ff) else
               if InFile.Current.Nr in [10,11] then \nwlinkedidentc{SetVisible1}{NW4fRSrE-Aye6w-1}(ff)
               else if InFile.Current.Nr in [12] then
                  gStatusOfProperties := 1;
         'M':
            if InFile.Current.Nr in [12] then
            begin
               \nwlinkedidentc{gVisible1}{NW4fRSrE-9km4y-1} := 0;
               \nwlinkedidentc{gVisible2}{NW4fRSrE-9km4y-1} := 0;
               \nwlinkedidentc{gFirstArg}{NW4fRSrE-9km4y-1} := 0;
               \nwlinkedidentc{gSecondArg}{NW4fRSrE-9km4y-1} := 0;
               if gRedef then
                  gStatusOfProperties := 5
               else gStatusOfProperties := 1;
            end
            else;
      end;
      gPropertiesOcc := true;
      case gStatusOfProperties of
         0:
            begin
               lPropCond := NewIncorFrm;
               InFile.InPos(CurPos);
            end;
         1:
            begin InFile.InPos(CurPos); gPropPos := CurPos;
            case InFile.Current.Nr of
               0: lPropCond := NewIncorFrm;
               1:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(1);  lPropCond := Symmetry end;
               2:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(2);  lPropCond := Reflexivity end;
               3:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(3);  lPropCond := Irreflexivity end;
               4:  begin \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(4);  lPropCond := Associativity end;
               5:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(5);  lPropCond := Transitivity end;
               6:  begin \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(6);  lPropCond := Commutativity end;
               7:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(7);  lPropCond := Connectedness end;
               8:  begin \nwlinkedidentc{PredProperty}{NW4fRSrE-3HK6tf-1}(8);  lPropCond := Asymmetry end;
               9:  begin \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(9);  lPropCond := Idempotence end;
               10: begin \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(10); lPropCond := Involutiveness end;
               11: begin \nwlinkedidentc{FuncProperty}{NW4fRSrE-1a7Xmh-1}(11); lPropCond := Projectivity end;
               12: begin \nwlinkedidentc{ModeProperty}{NW4fRSrE-2OQ1CR-1}(12); lPropCond := SetHood end;
            else RunTimeError(2013);
            end;
            end;
      else
      begin lPropCond := NewIncorFrm;
      InFile.InPos(CurPos);
      case gStatusOfProperties of
         2: if InFile.Current.Nr in [1,2,3,5,7,8] then ErrImm(81) else
               if InFile.Current.Nr in [6,9] then ErrImm(82) else
                  if InFile.Current.Nr in [10,11] then ErrImm(83) else RuntimeError(2999);
         3: ErrImm(79);
         4: ErrImm(80);
         5: ErrImm(77);
      end;
      end;
      end;
      \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,lPropCond);
      dispose(lPropCond,Done);
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElEnd(elJustifiedProperty);
      \{$ENDIF\}
   end;
end;
\nwindexdefn{\nwixident{ProcessProperties}}{ProcessProperties}{NW4fRSrE-18EWMX-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-3}}\nwidentdefs{\\{{\nwixident{ProcessProperties}}{ProcessProperties}}}\nwidentuses{\\{{\nwixident{ChangeLociInProperty}}{ChangeLociInProperty}}\\{{\nwixident{ChangeLociInPropertySetHood}}{ChangeLociInPropertySetHood}}\\{{\nwixident{FuncProperty}}{FuncProperty}}\\{{\nwixident{gFirstArg}}{gFirstArg}}\\{{\nwixident{gSecondArg}}{gSecondArg}}\\{{\nwixident{gVisible1}}{gVisible1}}\\{{\nwixident{gVisible2}}{gVisible2}}\\{{\nwixident{Justify}}{Justify}}\\{{\nwixident{LociList}}{LociList}}\\{{\nwixident{ModeProperty}}{ModeProperty}}\\{{\nwixident{PredProperty}}{PredProperty}}\\{{\nwixident{SetVisible1}}{SetVisible1}}\\{{\nwixident{SetVisible2}}{SetVisible2}}\\{{\nwixident{SwapLociInType}}{SwapLociInType}}}\nwindexuse{\nwixident{ChangeLociInProperty}}{ChangeLociInProperty}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{ChangeLociInPropertySetHood}}{ChangeLociInPropertySetHood}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{FuncProperty}}{FuncProperty}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{gFirstArg}}{gFirstArg}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{gSecondArg}}{gSecondArg}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{gVisible1}}{gVisible1}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{gVisible2}}{gVisible2}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{Justify}}{Justify}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{LociList}}{LociList}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{ModeProperty}}{ModeProperty}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{PredProperty}}{PredProperty}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{SetVisible1}}{SetVisible1}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{SetVisible2}}{SetVisible2}{NW4fRSrE-18EWMX-1}\nwindexuse{\nwixident{SwapLociInType}}{SwapLociInType}{NW4fRSrE-18EWMX-1}\nwendcode{}\nwbegindocs{288}\nwdocspar
\section{Parsing Definitions}

\nwenddocs{}\nwbegincode{289}\sublabel{NW4fRSrE-24b9uj-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-4}}}\moddef{Analyzer methods~{\nwtagstyle{}\subpageref{NW4fRSrE-24b9uj-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-SJwsI-1}}\nwprevnextdefs{NW4fRSrE-24b9uj-3}{\relax}\nwenddeflinemarkup
\LA{}Parse parametrization~{\nwtagstyle{}\subpageref{NW4fRSrE-4I8XVV-1}}\RA{}
\LA{}Determine meaning~{\nwtagstyle{}\subpageref{NW4fRSrE-S8NVf-1}}\RA{}
\LA{}Determine meaning for equation~{\nwtagstyle{}\subpageref{NW4fRSrE-P18Rc-1}}\RA{}
\LA{}Parse ``CC'' Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-1MoVf-1}}\RA{}
\LA{}Parse ``BB'' Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-9XR3h-1}}\RA{}
\LA{}Change declared constants to loci~{\nwtagstyle{}\subpageref{NW4fRSrE-dAzIv-1}}\RA{}
\LA{}Create Definientia~{\nwtagstyle{}\subpageref{NW4fRSrE-37tZpY-1}}\RA{}
\LA{}Analyze definitional theorems~{\nwtagstyle{}\subpageref{NW4fRSrE-3zzjWM-1}}\RA{}
\LA{}Parse definitions~{\nwtagstyle{}\subpageref{NW4fRSrE-2qhgrW-1}}\RA{}
\LA{}Round up item~{\nwtagstyle{}\subpageref{NW4fRSrE-4bfqVL-1}}\RA{}
\LA{}Parse a registration~{\nwtagstyle{}\subpageref{NW4fRSrE-y2T7a-1}}\RA{}
\LA{}Parse notation~{\nwtagstyle{}\subpageref{NW4fRSrE-2ABHYV-1}}\RA{}
\LA{}Parse a scheme block~{\nwtagstyle{}\subpageref{NW4fRSrE-2pbBPs-1}}\RA{}
\LA{}Analyze reduction-like theorem~{\nwtagstyle{}\subpageref{NW4fRSrE-2c2VWg-1}}\RA{}
\LA{}Parse a theorem~{\nwtagstyle{}\subpageref{NW4fRSrE-2bBUbD-1}}\RA{}
\LA{}Parse section~{\nwtagstyle{}\subpageref{NW4fRSrE-2EOET6-1}}\RA{}
\LA{}Parse cancelled item~{\nwtagstyle{}\subpageref{NW4fRSrE-3nSQUb-1}}\RA{}
\LA{}Load SGN environment file(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-KkIxc-1}}\RA{}
\LA{}Dispose analyze~{\nwtagstyle{}\subpageref{NW4fRSrE-1OBgEQ-1}}\RA{}
\LA{}Analyze~{\nwtagstyle{}\subpageref{NW4fRSrE-1Bkikv-1}}\RA{}
\nwused{\\{NW4fRSrE-SJwsI-1}}\nwendcode{}\nwbegindocs{290}\nwdocspar

\nwenddocs{}\nwbegincode{291}\sublabel{NW4fRSrE-4I8XVV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4I8XVV-1}}}\moddef{Parse parametrization~{\nwtagstyle{}\subpageref{NW4fRSrE-4I8XVV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Parametrization}{NW4fRSrE-4I8XVV-1};
var
   i,lNbr: integer;
   lTyp: TypPtr;
begin
   \nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1} := g.VarNbr;
   InFile.InPos(CurPos);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elLet);
   AReport.Out_XIntAttr(atNr, g.VarNbr+1);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   InFile.InWord;
   while InFile.Current.Kind='Q' do
   begin
      lNbr := g.VarNbr;
      inc(g.VarNbr,InFile.Current.Nr);
      if g.VarNbr-gDefBase > \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} then
         OverflowError(937);
      for i := 1 to InFile.Current.Nr do
      begin
         InFile.InWord; // 'I'
         FixedVar[lNbr+i].nIdent := InFile.Current.Nr;
      end;
      gFraenkelTermAllowed := false;
      lTyp := \nwlinkedidentc{ReadType}{NW4fRSrE-2owkOX-1};
      gFraenkelTermAllowed := true;
      for i := lNbr+1 to g.VarNbr do
      begin
         if lTyp^.TypSort<>IkError then
         begin
            if i=g.VarNbr then
               FixedVar[i].nTyp := lTyp
            else FixedVar[i].nTyp := lTyp^.CopyType
         end
         else FixedVar[i].nTyp := NewIncorTyp;
         FixedVar[i].nExp := false;
      end;
      //   dispose(lTyp,Done);
      InFile.InWord;
   end;
   \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
   \nwlinkedidentc{ParamDecl}{NW4fRSrE-29B9Op-1}(\nwlinkedidentc{gFixedBase}{NW4fRSrE-FAqx7-1});
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElEnd(elLet);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{Parametrization}}{Parametrization}{NW4fRSrE-4I8XVV-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Parametrization}}{Parametrization}}}\nwidentuses{\\{{\nwixident{gFixedBase}}{gFixedBase}}\\{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}\\{{\nwixident{ParamDecl}}{ParamDecl}}\\{{\nwixident{ReadType}}{ReadType}}\\{{\nwixident{WriteQualified}}{WriteQualified}}}\nwindexuse{\nwixident{gFixedBase}}{gFixedBase}{NW4fRSrE-4I8XVV-1}\nwindexuse{\nwixident{gMaxArgNbr}}{gMaxArgNbr}{NW4fRSrE-4I8XVV-1}\nwindexuse{\nwixident{ParamDecl}}{ParamDecl}{NW4fRSrE-4I8XVV-1}\nwindexuse{\nwixident{ReadType}}{ReadType}{NW4fRSrE-4I8XVV-1}\nwindexuse{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-4I8XVV-1}\nwendcode{}\nwbegindocs{292}\nwdocspar
\nwenddocs{}\nwbegincode{293}\sublabel{NW4fRSrE-S8NVf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-S8NVf-1}}}\moddef{Determine meaning~{\nwtagstyle{}\subpageref{NW4fRSrE-S8NVf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
function \nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1}(fDef: DefPtr;
                 Definiendum: FrmPtr): FrmPtr;
var
   dFrm2,dFrm: FrmPtr;
   z: integer;
begin
   with fDef^ do
   begin
      dFrm := NewVerum;
      mizassert(2597,DefSort='m');
      if nOtherwise <> nil then dFrm2 := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            if fDef^.nOtherWise<>nil then
               dFrm2 := NewConj(dFrm2,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
            dFrm := NewConj(dFrm,
                            NewImpl(FrmPtr(nGuard),
                                    NewBicond(Definiendum^.CopyFormula,FrmPtr(nPartDefiniens))));
         end;
      if nOtherWise<>nil then
         dFrm := NewConj(dFrm,
                         NewImpl(dFrm2,NewBicond(Definiendum^.CopyFormula,FrmPtr(nOtherWise))));
   end;
   dispose(Definiendum,Done);
   with fDef^.nPartialDefinientia do
   begin
      for z := 0 to Count-1 do dispose(PartDefPtr(Items^[z]));
      DeleteAll; Done;
   end;
   dispose(fDef);
   WithInFormula(dFrm,\nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1});
   \nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1} := dFrm;
end;
\nwindexdefn{\nwixident{Meaning}}{Meaning}{NW4fRSrE-S8NVf-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Meaning}}{Meaning}}}\nwidentuses{\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}}\nwindexuse{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-S8NVf-1}\nwendcode{}\nwbegindocs{294}\nwdocspar
\nwenddocs{}\nwbegincode{295}\sublabel{NW4fRSrE-P18Rc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-P18Rc-1}}}\moddef{Determine meaning for equation~{\nwtagstyle{}\subpageref{NW4fRSrE-P18Rc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
function \nwlinkedidentc{MeaningEq}{NW4fRSrE-P18Rc-1}(fDef: DefPtr;
                   Definiendum: TrmPtr): FrmPtr;
var
   dFrm2,dFrm: FrmPtr;
   z: integer;
begin
   with fDef^ do
   begin
      dFrm := NewVerum;
      mizassert(2598,DefSort='e');
      if nOtherwise <> nil then dFrm2 := NewVerum;
      with nPartialDefinientia do
         for z := 0 to Count-1 do
            with PartDefPtr(Items^[z])^ do
         begin
            if fDef^.nOtherWise<>nil then
               dFrm2 := NewConj(dFrm2,NewNegDis(FrmPtr(nGuard)^.CopyFormula));
            dFrm := NewConj(dFrm,
                            NewImpl(FrmPtr(nGuard)^.CopyFormula,
                                    NewEqFrm(CopyTerm(Definiendum),CopyTerm(TrmPtr(nPartDefiniens)))));
         end;
      if nOtherWise<>nil then
         dFrm := NewConj(dFrm,
                         NewImpl(dFrm2,
                                 NewEqFrm(CopyTerm(Definiendum),CopyTerm(TrmPtr(nOtherWise)))));
   end;
   dispose(fDef,Done);
   WithInFormula(dFrm,\nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1});
   \nwlinkedidentc{MeaningEq}{NW4fRSrE-P18Rc-1} := dFrm;
end;
\nwindexdefn{\nwixident{MeaningEq}}{MeaningEq}{NW4fRSrE-P18Rc-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{MeaningEq}}{MeaningEq}}}\nwidentuses{\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}}\nwindexuse{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-P18Rc-1}\nwendcode{}\nwbegindocs{296}\nwdocspar
\nwenddocs{}\nwbegincode{297}\sublabel{NW4fRSrE-1MoVf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1MoVf-1}}}\moddef{Parse ``CC'' Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-1MoVf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
function \nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1}: TrmList;
var
   lTrmList: TrmList;
   Previous: ^TrmList;
   k: integer;
begin
   Previous := addr(lTrmList);
   for k := g.DemBase+1 to g.VarNbr do
      if FixedVar[k].nSkelConstNr<>0 then
      begin
         new(Previous^);
         Previous^^.XTrmPtr := NewVarTrm(ikTrmConstant,k);
         Previous := addr(Previous^^.NextTrm);
      end;
   Previous^ := nil;
   \nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1} := lTrmList;
end;
\nwindexdefn{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}{NW4fRSrE-1MoVf-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}}}\nwendcode{}\nwbegindocs{298}\nwdocspar
\nwenddocs{}\nwbegincode{299}\sublabel{NW4fRSrE-9XR3h-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-9XR3h-1}}}\moddef{Parse ``BB'' Formal arguments~{\nwtagstyle{}\subpageref{NW4fRSrE-9XR3h-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
function \nwlinkedidentc{BB_FormalArgs}{NW4fRSrE-9XR3h-1}: TrmList;
var
   ltl: TrmList;
begin
   ltl := \nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1};
   \nwlinkedidentc{BB_FormalArgs}{NW4fRSrE-9XR3h-1} := ltl;
   while ltl<>nil do with ltl^ do
   begin WithInTerm(XTrmPtr,\nwlinkedidentc{ChangeDeclConstToBound}{NW4fRSrE-4XBdxo-1}); ltl := NextTrm end;
end;
\nwindexdefn{\nwixident{BB{\_}FormalArgs}}{BB:unFormalArgs}{NW4fRSrE-9XR3h-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{BB{\_}FormalArgs}}{BB:unFormalArgs}}}\nwidentuses{\\{{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}}\\{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}}\nwindexuse{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}{NW4fRSrE-9XR3h-1}\nwindexuse{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}{NW4fRSrE-9XR3h-1}\nwendcode{}\nwbegindocs{300}\nwdocspar
\nwenddocs{}\nwbegincode{301}\sublabel{NW4fRSrE-dAzIv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-dAzIv-1}}}\moddef{Change declared constants to loci~{\nwtagstyle{}\subpageref{NW4fRSrE-dAzIv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1}(var fTrm: TrmPtr);
var
   lTrm: TrmPtr;
begin
   with VarTrmPtr(fTrm)^ do
      case  TrmSort of
         ikTrmConstant:
            if (VarNr>g.DemBase) and (FixedVar[VarNr].nSkelConstNr<>0) then
            begin TrmSort := ikTrmLocus; VarNr := FixedVar[VarNr].nSkelConstNr end;
         ikTrmIt:
            begin lTrm := fTrm; fTrm := NewVarTrm(ikTrmLocus,g.GenCount);
            dispose(lTrm,Done);
            end;
      end;
end;
\nwindexdefn{\nwixident{ChangeDeclConstToLoci}}{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{ChangeDeclConstToLoci}}{ChangeDeclConstToLoci}}}\nwendcode{}\nwbegindocs{302}\nwdocspar
\nwenddocs{}\nwbegincode{303}\sublabel{NW4fRSrE-37tZpY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-37tZpY-1}}}\moddef{Create Definientia~{\nwtagstyle{}\subpageref{NW4fRSrE-37tZpY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
var \nwlinkedidentc{gDefThNr}{NW4fRSrE-37tZpY-1}: integer = 0;   // count (also canceled) deftheorems
procedure \nwlinkedidentc{CreateDefinientia}{NW4fRSrE-37tZpY-1};
   procedure CreateDefiniens(Item: \nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1});
   var
      aFrm: FrmPtr;
      lEntry: RsnEntry;
      lPartialPart: MCollection;
      lOtherWise,lPartDef: PObject;
      lGuard: FrmPtr;
      lKind: Char;
      lNr,lLabId,z: integer;
   begin
      with Item^ do
      begin
         // the deftheorem will be created also for canceled
         if (DDef = nil) and (nConstructor.Kind = ':') then inc(\nwlinkedidentc{gDefThNr}{NW4fRSrE-37tZpY-1});
         if DDef <> nil then
         begin
            g.GenCount := SkIt; lLabId := SkLabId;
            inc(\nwlinkedidentc{gDefThNr}{NW4fRSrE-37tZpY-1});  // the deftheorem will be created also for canceled
            \{ Poniewaz bardziej dokladne informacje sa potrzebne dla
              konstrukcji twierdzenia definicyjnego, jest to chyba dobre
              miejsce, zeby je tutaj zmienic. \}
            \{ Since more detailed information is needed for
              the construction of the definitional theorem, this is probably a good
              place to change it here. \}
            lKind := nConstructor.Kind;
            lNr := nConstructor.Nr;
            case lKind of
               'M','R','V','K':
                  with ConstrPtr(Constr[ ConstructorKind(lKind)].Items^[lNr])^ do
                              if fWhichConstrNr<>0 then lNr := fWhichConstrNr;
               //        \{ dla funktorow nie tworzymy definiensow \}
                         \{ we do not create definitions for functors \}
               ':': exit;
            end;
            \{ ------------------------ \}
            aFrm := NewVerum; lEntry := nPrefix;
            while LEntry <> nil do with LEntry^ do
            begin
               if Form='A' then aFrm := NewConj(DSnt^.CopyFormula,aFrm);
               LEntry := PreviousEntry;
            end;
            WithInFormula(aFrm,\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
            with DDef^ do
            begin lPartialPart.Init(nPartialDefinientia.Count,0);
            with nPartialDefinientia do
               for z := 0 to Count-1 do
                  with PartDefPtr(Items^[z])^ do
               begin
                  case DefSort of
                     'm':
                        begin
                           lPartDef := FrmPtr(nPartDefiniens)^.CopyFormula;
                           WithInFormula(FrmPtr(lPartDef),\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
                        end;
                     'e':
                        begin
                           lPartDef := CopyTerm(TrmPtr(nPartDefiniens));
                           WithInTerm(TrmPtr(lPartDef),\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
                        end;
                  else RunTimeError(2515);
                  end;
                  lGuard := FrmPtr(nGuard)^.CopyFormula;
                  WithInFormula(lGuard,\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
                  lPartialPart.Insert(new(PartDefPtr, Init(lPartDef,lGuard)));
               end;
            lOtherWise := nil;
            if nOtherWise <> nil then
            begin
               case DefSort of
                  'm':
                     begin
                        lOtherWise := FrmPtr(nOtherWise)^.CopyFormula;
                        WithInFormula(FrmPtr(lOtherWise),\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
                     end;
                  'e':
                     begin
                        lOtherWise := CopyTerm(TrmPtr(nOtherWise));
                        WithInTerm(TrmPtr(lOtherWise),\nwlinkedidentc{ChangeDeclConstToLoci}{NW4fRSrE-dAzIv-1});
                     end;
               else RunTimeError(2516);
               end;
            end;
            Definientia.Insert(
               new(DefiniensPtr,
                   Init(lKind,lNr,\nwlinkedidentc{gDefThNr}{NW4fRSrE-37tZpY-1},lLabId,ArticleID,nPrimaryList,nEssentials,aFrm,
                        new(DefPtr,Init(DefSort,lPartialPart,lOtherwise)))));
            \{                   
                                EqDefinientia.Insert(
                                new(DefiniensPtr,
                                Init(lKind,lNr,\nwlinkedidentc{gDefThNr}{NW4fRSrE-37tZpY-1},lLabId,ArticleID,nPrimaryList,nEssentials,aFrm,
                                new(DefPtr,Init(DefSort,lPartialPart,lOtherwise)))));
\}                   
            end;
         end;
      end;
   end;
var
   z,lDefBase: integer;
begin
   lDefBase := Definientia.Count;
   with \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1} do
      for z := 0 to Count-1 do
         CreateDefiniens(\nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1}(Items^[z]));
   with Definientia do
      for z := lDefBase to Count-1 do
         with DefiniensPtr(Items^[z])^ do
            if Definiens<>nil then
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_Definiens(DefiniensPtr(Items^[z])^, z+1);
               \{$ENDIF\}
            end;
end;
\nwindexdefn{\nwixident{CreateDefinientia}}{CreateDefinientia}{NW4fRSrE-37tZpY-1}\nwindexdefn{\nwixident{gDefThNr}}{gDefThNr}{NW4fRSrE-37tZpY-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{CreateDefinientia}}{CreateDefinientia}}\\{{\nwixident{gDefThNr}}{gDefThNr}}}\nwidentuses{\\{{\nwixident{ChangeDeclConstToLoci}}{ChangeDeclConstToLoci}}\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefNodePtr}}{DefNodePtr}}}\nwindexuse{\nwixident{ChangeDeclConstToLoci}}{ChangeDeclConstToLoci}{NW4fRSrE-37tZpY-1}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-37tZpY-1}\nwindexuse{\nwixident{DefNodePtr}}{DefNodePtr}{NW4fRSrE-37tZpY-1}\nwendcode{}\nwbegindocs{304}\nwdocspar
\nwenddocs{}\nwbegincode{305}\sublabel{NW4fRSrE-3zzjWM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3zzjWM-1}}}\moddef{Analyze definitional theorems~{\nwtagstyle{}\subpageref{NW4fRSrE-3zzjWM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DefinitionalTheorems}{NW4fRSrE-3zzjWM-1};
   procedure ProcessDefinition(Item:\nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1});
   var
      lSkDef: DefPtr;
      lFrm,lFrm1: FrmPtr;
      nAttrNr: integer;
      lArgs,A :TrmList;
      NewType,lTyp: TypPtr;
      Sample: TrmPtr;
      ldefEntry: RSNENTRY;
      lDefProp: PropositionPtr;
   begin
      with Item^ do
      begin
         lDefProp := nil;
         g.VarNbr := SkVarNbr;
         if DDef<>nil then
         begin
            lSkDef := DDef;
            g.GenCount := SkIt;
            case nConstructor.Kind of
               'R': lFrm := \nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1}(lSkDef,NewPredFrm(ikFrmPred,nConstructor.Nr,\nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1},0));
               'V':
                  if  nConstructor.Nr = 0 then
                     lFrm := NewInCorFrm
                  else
                  begin
                     lFrm1 := NewPredFrm(ikFrmAttr,nConstructor.Nr,\nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1},0);
                     AdjustAttrFrm(PredFrmPtr(lFrm1),nAttrNr,A);
                     lFrm := \nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1}(lSkDef,NewPredFrm(ikFrmAttr,nAttrNr,CopyTermList(A),0));
                     dispose(lFrm1,Done);
                  end;
               'K':
                  begin Sample := NewFuncTrm(nConstructor.Nr,\nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1});
                  if nMeansOccurs = 'e' then
                  begin dec(g.GenCount);
                  lFrm := \nwlinkedidentc{MeaningEq}{NW4fRSrE-P18Rc-1}(lSkDef,Sample);
                  inc(g.GenCount);
                  end
                  else
                  begin
                     lArgs := \nwlinkedidentc{BB_FormalArgs}{NW4fRSrE-9XR3h-1};
                     lTyp := ConstrTypPtr(Constr[coFunctor].Items^[nConstructor.Nr])^.fConstrTyp^.InstTyp(lArgs);
                     DisposeTrmList(lArgs);
                     lFrm := NewUniv(lTyp,\nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1}(lSkDef,NewEqFrm(NewItTrm,Sample)));
                  end;
                  end;
               'M':
                  with ConstrTypPtr(Constr[coMode].Items^[nConstructor.Nr])^ do
               begin
                  NewType := 
                     NewStandardTyp(ikTypMode,NewEmptyCluster,
                                    InstCluster(fConstrTyp^.UpperCluster,\nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1}),
                                    nConstructor.Nr,\nwlinkedidentc{CC_FormalArgs}{NW4fRSrE-1MoVf-1});
                  lArgs := \nwlinkedidentc{BB_FormalArgs}{NW4fRSrE-9XR3h-1};
                  lTyp := fConstrTyp^.InstTyp(lArgs);
                  DisposeTrmList(lArgs);
                  lFrm := NewUniv(lTyp,\nwlinkedidentc{Meaning}{NW4fRSrE-S8NVf-1}(lSkDef,NewQualFrm(NewItTrm,NewType)));
               end;
            end;
            ldefEntry := nPrefix;
            while ldefEntry <> nil do with ldefEntry^ do
            begin
               case Form of
                  'D': lFrm := \nwlinkedidentc{NewUnivList}{NW4fRSrE-3S612w-1}(SkList,SkIdents,lFrm);
                  'A': lFrm := NewImpl(SkSnt^.CopyFormula,lFrm);
               else RunTimeError(2010);
               end;
               ldefEntry := PreviousEntry;
            end;
            lDefProp := new(PropositionPtr, Init(SkId, SkLabId, lFrm, CurPos));
         end
         else if nConstructor.Kind = ':'
                    \{ Przetwarzanie "canceled" \} \{ Processing "canceled" \}
         then lDefProp := new(PropositionPtr, Init(0, 0, NewVerum, CurPos));
         if Assigned(lDefProp) then
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefTheorem);
            with AReport, nConstructor do
                             if Kind in [ 'K','M','R','V'] then
                             begin
                                Out_XAttr(atConstrKind, Kind);
                                Out_XIntAttr(atConstrNr, Transf(ConstructorKind(Kind), Nr));
                             end;
            AReport.Out_XAttrEnd;
            AReport.Out_Proposition(lDefProp);
            AReport.Out_XElEnd(elDefTheorem);
            \{$ENDIF\}
            dispose(lDefProp, Done);
         end;
      end;
   end;
var
   z: integer;
begin
   with \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1} do
      for z := 0 to Count-1 do
         ProcessDefinition(\nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1}(Items^[z]));
   \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Done;
end;
\nwindexdefn{\nwixident{DefinitionalTheorems}}{DefinitionalTheorems}{NW4fRSrE-3zzjWM-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{DefinitionalTheorems}}{DefinitionalTheorems}}}\nwidentuses{\\{{\nwixident{BB{\_}FormalArgs}}{BB:unFormalArgs}}\\{{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}}\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefNodePtr}}{DefNodePtr}}\\{{\nwixident{Meaning}}{Meaning}}\\{{\nwixident{MeaningEq}}{MeaningEq}}\\{{\nwixident{NewUnivList}}{NewUnivList}}}\nwindexuse{\nwixident{BB{\_}FormalArgs}}{BB:unFormalArgs}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{DefNodePtr}}{DefNodePtr}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{Meaning}}{Meaning}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{MeaningEq}}{MeaningEq}{NW4fRSrE-3zzjWM-1}\nwindexuse{\nwixident{NewUnivList}}{NewUnivList}{NW4fRSrE-3zzjWM-1}\nwendcode{}\nwbegindocs{306}\nwdocspar
\nwenddocs{}\nwbegincode{307}\sublabel{NW4fRSrE-2qhgrW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2qhgrW-1}}}\moddef{Parse definitions~{\nwtagstyle{}\subpageref{NW4fRSrE-2qhgrW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Definition}{NW4fRSrE-2qhgrW-1};
var
   lDeclBase,lVarBase,i,pVarNbr: integer;
   lConditions: MCollection;
   lFrm: FrmPtr;
   lPos: Position;
   lEntry: RSNENTRY;
   lNotatExtCount: array[NotationKind] of integer;
   nk: NotationKind;
   \{$IFDEF ANALYZER_REPORT\}
   procedure Do_Patterns;
   var
      k: integer;
      nk1: NotationKind;
   begin
      for nk1 := Low(NotationKind) to High(NotationKind) do
         with Notat[nk1] do
            for k := Count + lNotatExtCount[nk1] to Count + fExtCount - 1 do
               AReport.Out_Pattern(Items^[k], k+1);
   end;
   \{$ENDIF\}
begin
   InFile.InPos(CurPos);
   \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   d := g;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocPredNbr := LocPredDef.Count;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocFuncNbr := LocFuncDef.Count;
   \nwlinkedidentc{OpenDef}{NW4fRSrE-3bvXko-1};
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elDefinitionBlock);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   g.LastEntry := nil; g.GenCount := 0; g.DemBase := g.VarNbr;
   \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Init(2,4);
   while InFile.Current.Kind <> ikMscEndBlock do
   begin gRedef := false;
   fillchar(gCorrCond[1],SizeOf(gCorrCond)-SizeOf(pointer),0);
   ItTyp := nil;
   for nk := Low(NotationKind) to High(NotationKind) do
      lNotatExtCount[nk] := Notat[nk].fExtCount;
   \{ Inicjalizacje do obslugi konstruktorow i definiensu\}
   \{ Initializations for handling constructors and definiens\}
   gWhichOne := 0;
   gSuperfluous := 0; \{ dla definicji zostaje 0, dla redefinicji jest wyliczana \}
                      \{ for definition it remains 0, for redefinition it is calculated \}
   gPropertiesOcc := false;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.MeansOccurs := ' ';
   case InFile.Current.Kind of
      ikItmGeneralization:
         begin
            lDeclBase := g.VarNbr;
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{Parametrization}{NW4fRSrE-4I8XVV-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{SkelList}{NW4fRSrE-3KnOnX-1}('D',lDeclBase);
         end;
      \{ Przy przyjeciu restrykcyjnej koncepcji dla typow lokusow nie ma sensu
        uzywac tej samej procedury dla generalizacji i parametryzacji.
      \}
      \{ When adopting a restrictive concept for locus types, it does not make sense
        to use the same procedure for generalization and parameterization. \}
      ikItmAssumption:
         begin
            gNonPermissive := false;
            InFile.InPos(lPos);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart0(elAssume);
            \{$ENDIF\}
            InFile.InWord;
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propositions(lConditions);
            AReport.Out_XElEnd(elAssume);
            \{$ENDIF\}
            InFile.InWord;
            lFrm := \nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions);
            \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('A',lFrm);
            lConditions.Done;
         end;
      ikItmExAssumption:
         begin
            gNonPermissive := false;
            lVarBase := g.VarNbr;
            InFile.InPos(CurPos);
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elGiven);
            AReport.Out_XIntAttr(atNr, g.VarNbr+1);
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{GetConstQualifiedList}{NW4fRSrE-4MdvhM-1};
            \nwlinkedidentc{ReadPropositions}{NW4fRSrE-aW1Nc-1}(lConditions);
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            InFile.InWord;
            lFrm := \nwlinkedidentc{xFormula}{NW4fRSrE-3ZW69r-1}(\nwlinkedidentc{ConjugatePropositions}{NW4fRSrE-2UfBO8-1}(lConditions));
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propos(0, 0, CurPos, lFrm);
            \{$ENDIF\}
            \nwlinkedidentc{SkelSnt}{NW4fRSrE-4QAXkH-1}('A',lFrm);
            \nwlinkedidentc{WriteQualified}{NW4fRSrE-1GXbPG-1};
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_Propositions(lConditions);
            AReport.Out_XElEnd(elGiven);
            \{$ENDIF\}
            lConditions.Done;
            for i := lVarBase+1 to g.VarNbr do FixedVar[i].nSkelConstNr := 0;
         end;
      ikItmDefMode:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'M');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefModePattern}{NW4fRSrE-24hAJs-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Modow
            \{ Please note: processing of incorrect properties, there are no properties for Mods yet \}
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('M');
            \nwlinkedidentc{InsertMode}{NW4fRSrE-jEwY5-1};
            \nwlinkedidentc{DefModeTail}{NW4fRSrE-3xpn6K-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmRedefMode:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'M');
            AReport.Out_XAttr(atRedefinition, 'true');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{RedefModePattern}{NW4fRSrE-2hqWv9-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Modow
            \{ Please note: processing of incorrect properties, there are no properties for Mods yet \}
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('M');
            if (gSuperFluous <> 0) or gSpecified then \nwlinkedidentc{InsertMode}{NW4fRSrE-jEwY5-1};
            \nwlinkedidentc{DefModeTail}{NW4fRSrE-3xpn6K-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmDefExpandMode:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'M');
            AReport.Out_XAttr(atExpandable, 'true');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefExpandableMode}{NW4fRSrE-1u93O4-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            // ##TODO: this \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1} seems useless
            // wydaje sie potrzebna na potrzeby obslugi blednych sytuacji
            \{ seems to be needed to handle error situations \}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Modow
            \{ Please note: processing of incorrect properties, there are no properties for Mods yet \}
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('M');
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmDefPrAttr:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'V');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefPredAttributePattern}{NW4fRSrE-45Cbij-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Atrybutow
            \{ Please note: processing of incorrect properties, there are no properties for Attributes yet \}
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('V');
            \nwlinkedidentc{InsertPredAttribute}{NW4fRSrE-1gwegT-1};
            \nwlinkedidentc{DefAttrTail}{NW4fRSrE-mZ8N3-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmRedefPrAttr:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'V');
            AReport.Out_XAttr(atRedefinition, 'true');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{RedefPredAttributePattern}{NW4fRSrE-2VOwe7-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Atrybutow
            \{ Please note: processing of incorrect properties, there are no properties for Attributes yet \}
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('V');
            if gSuperFluous <> 0 then
               \nwlinkedidentc{InsertPredAttribute}{NW4fRSrE-1gwegT-1};
            \nwlinkedidentc{DefAttrTail}{NW4fRSrE-mZ8N3-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmDefPred:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'R');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefPredPattern}{NW4fRSrE-36ZjPM-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('R');
            \nwlinkedidentc{InsertPredicate}{NW4fRSrE-1Nd4jW-1};
            \nwlinkedidentc{DefPredTail}{NW4fRSrE-2uTf5M-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmDefFunc:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'K');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefFuncPattern}{NW4fRSrE-138Ush-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('K');
            \nwlinkedidentc{InsertFunctor}{NW4fRSrE-1nPKhC-1};
            \nwlinkedidentc{DefFuncTail}{NW4fRSrE-2BYsiX-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmRedefPred:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'R');
            AReport.Out_XAttr(atRedefinition, 'true');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{RedefPredPattern}{NW4fRSrE-3QTOh1-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('R');
            if (gSuperFluous <> 0) or gPropertiesOcc then \nwlinkedidentc{InsertPredicate}{NW4fRSrE-1Nd4jW-1};
            \nwlinkedidentc{DefPredTail}{NW4fRSrE-2uTf5M-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmRedefFunc:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'K');
            AReport.Out_XAttr(atRedefinition, 'true');
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{RedefFuncPattern}{NW4fRSrE-3o0u5v-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            \{$IFDEF ANALYZER_REPORT\}
            \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('K');
            if (gSuperFluous <> 0) or gSpecified or gPropertiesOcc then \nwlinkedidentc{InsertFunctor}{NW4fRSrE-1nPKhC-1};
            \nwlinkedidentc{DefFuncTail}{NW4fRSrE-2BYsiX-1};
            \nwlinkedidentc{WriteDefiniens}{NW4fRSrE-4OXFUo-1};
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmDefStruct:
         begin
            \{$IFDEF ANALYZER_REPORT\}
            AReport.Out_XElStart(elDefinition);
            AReport.Out_XAttr(atKind, 'G');
            AReport.Out_XAttrEnd;
            \{$ENDIF\}
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{DefStruct}{NW4fRSrE-XUFqn-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            // No sense for structures
            //     \nwlinkedidentc{WriteDefiniensLabel}{NW4fRSrE-3w2GDr-1};
            // ##TODO: this \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1} seems useless, and makes praphan
            //         ugly, because we have to take special care of it there
            //   Uwaga obsluga blednych correctness
            \{ Note handling incorrect correctness \}
            \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
            //   Uwaga obrobka blednych properties, na razie nie ma properties dla Atrybutow
            \nwlinkedidentc{ProcessProperties}{NW4fRSrE-18EWMX-1}('G');
            \{$IFDEF ANALYZER_REPORT\}
            Do_Patterns;
            AReport.Out_XElEnd(elDefinition);
            \{$ENDIF\}
         end;
      ikItmCanceled:
         begin
            InFile.InWord;
            case InFile.Current.Kind of
               ikDefTheoremCanceled:
                  begin
                     \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.Kind := ':';
                     \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Insert(new(\nwlinkedidentc{DefNodePtr}{NW4fRSrE-4Jho5-1}, Init(' ',':',0,0,nil,nil)));
                  end;
               ikTheoremCanceled:
                  ErrImm(278);
               ikSchemeCanceled:
                  ErrImm(279);
            end;
            InFile.InWord;
         end
   else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
   end;
   if ItTyp<> nil then dispose(ItTyp,Done);
   DisplayLine(CurPos.Line,ErrorNbr);
   end;
   InFile.InPos(CurPos); InFile.InWord;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elDefinitionBlock);
   \{$ENDIF\}
   \nwlinkedidentc{CreateDefinientia}{NW4fRSrE-37tZpY-1};
   pVarNbr := g.VarNbr;
   \nwlinkedidentc{DefinitionalTheorems}{NW4fRSrE-3zzjWM-1};
   g.VarNbr := pVarNbr;
   while g.LastEntry <> nil do
   begin
      lEntry := g.LastEntry^.PreviousEntry;
      with g.LastEntry^ do
         case FORM of
            'A','B': begin dispose(SkSnt,Done); dispose(dSnt,Done) end;
            'C','D': begin SkList.Done; SkIdents.Done; SkOrigTyps.Done; end;
         end;
      dispose(g.LastEntry);
      g.LastEntry := lEntry;
   end;
   DisposeTrmList(\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}); \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   \nwlinkedidentc{CloseDef}{NW4fRSrE-713M3-1};
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(d);
end;
\nwindexdefn{\nwixident{Definition}}{Definition}{NW4fRSrE-2qhgrW-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Definition}}{Definition}}}\nwidentuses{\\{{\nwixident{CloseDef}}{CloseDef}}\\{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}\\{{\nwixident{Correctness}}{Correctness}}\\{{\nwixident{CreateDefinientia}}{CreateDefinientia}}\\{{\nwixident{D}}{D}}\\{{\nwixident{DefAttrTail}}{DefAttrTail}}\\{{\nwixident{DefExpandableMode}}{DefExpandableMode}}\\{{\nwixident{DefFuncPattern}}{DefFuncPattern}}\\{{\nwixident{DefFuncTail}}{DefFuncTail}}\\{{\nwixident{DefinitionalTheorems}}{DefinitionalTheorems}}\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefModePattern}}{DefModePattern}}\\{{\nwixident{DefModeTail}}{DefModeTail}}\\{{\nwixident{DefNodePtr}}{DefNodePtr}}\\{{\nwixident{DefPredAttributePattern}}{DefPredAttributePattern}}\\{{\nwixident{DefPredPattern}}{DefPredPattern}}\\{{\nwixident{DefPredTail}}{DefPredTail}}\\{{\nwixident{DefStruct}}{DefStruct}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}}\\{{\nwixident{InsertFunctor}}{InsertFunctor}}\\{{\nwixident{InsertMode}}{InsertMode}}\\{{\nwixident{InsertPredAttribute}}{InsertPredAttribute}}\\{{\nwixident{InsertPredicate}}{InsertPredicate}}\\{{\nwixident{OpenDef}}{OpenDef}}\\{{\nwixident{Parametrization}}{Parametrization}}\\{{\nwixident{ProcessProperties}}{ProcessProperties}}\\{{\nwixident{ReadPropositions}}{ReadPropositions}}\\{{\nwixident{RedefFuncPattern}}{RedefFuncPattern}}\\{{\nwixident{RedefModePattern}}{RedefModePattern}}\\{{\nwixident{RedefPredAttributePattern}}{RedefPredAttributePattern}}\\{{\nwixident{RedefPredPattern}}{RedefPredPattern}}\\{{\nwixident{SkelList}}{SkelList}}\\{{\nwixident{SkelSnt}}{SkelSnt}}\\{{\nwixident{Statement}}{Statement}}\\{{\nwixident{WriteDefiniens}}{WriteDefiniens}}\\{{\nwixident{WriteDefiniensLabel}}{WriteDefiniensLabel}}\\{{\nwixident{WriteQualified}}{WriteQualified}}\\{{\nwixident{xFormula}}{xFormula}}}\nwindexuse{\nwixident{CloseDef}}{CloseDef}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{ConjugatePropositions}}{ConjugatePropositions}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{Correctness}}{Correctness}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{CreateDefinientia}}{CreateDefinientia}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{D}}{D}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefAttrTail}}{DefAttrTail}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefExpandableMode}}{DefExpandableMode}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefFuncPattern}}{DefFuncPattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefFuncTail}}{DefFuncTail}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefinitionalTheorems}}{DefinitionalTheorems}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefModePattern}}{DefModePattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefModeTail}}{DefModeTail}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefNodePtr}}{DefNodePtr}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefPredAttributePattern}}{DefPredAttributePattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefPredPattern}}{DefPredPattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefPredTail}}{DefPredTail}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DefStruct}}{DefStruct}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{InsertFunctor}}{InsertFunctor}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{InsertMode}}{InsertMode}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{InsertPredAttribute}}{InsertPredAttribute}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{InsertPredicate}}{InsertPredicate}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{OpenDef}}{OpenDef}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{Parametrization}}{Parametrization}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{ProcessProperties}}{ProcessProperties}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{ReadPropositions}}{ReadPropositions}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{RedefFuncPattern}}{RedefFuncPattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{RedefModePattern}}{RedefModePattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{RedefPredAttributePattern}}{RedefPredAttributePattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{RedefPredPattern}}{RedefPredPattern}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{SkelList}}{SkelList}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{SkelSnt}}{SkelSnt}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{WriteDefiniens}}{WriteDefiniens}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{WriteDefiniensLabel}}{WriteDefiniensLabel}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{WriteQualified}}{WriteQualified}{NW4fRSrE-2qhgrW-1}\nwindexuse{\nwixident{xFormula}}{xFormula}{NW4fRSrE-2qhgrW-1}\nwendcode{}\nwbegindocs{308}\nwdocspar
\nwenddocs{}\nwbegincode{309}\sublabel{NW4fRSrE-4bfqVL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-4bfqVL-1}}}\moddef{Round up item~{\nwtagstyle{}\subpageref{NW4fRSrE-4bfqVL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
// ##TODO: this very much resembles RoundUpTrmType, try to avoid
//         such copying of code.
// ##TODO: why do we use even the clusters from Count to fExtCount-1 here???
//         It seems fairly inconsistent with other usage of them in analizer.
//         Insert all clusters immediatelly as in preparator,
//         to get rid of the mess.
procedure \nwlinkedidentc{RoundUpItem}{NW4fRSrE-4bfqVL-1}(Item: TTPairPtr);
var
   i,lLeft,lRight: integer;
   lKey: FClusterObj;
   lClusterPtr: AttrCollectionPtr;
label Inconsistent;
begin
   with Item^ do
   begin
      lClusterPtr := CopyCluster(nTyp^.UpperCluster);
      lKey.nClusterTerm := nTrm;
      if FunctorCluster.FindInterval(@lKey, lLeft, lRight) then
         for i := lLeft to lRight do
         begin
            RoundUpWith(FunctorCluster.AtIndex(i),nTrm,nTyp,lClusterPtr);
            \{ Powinno sie tutaj zglosic blad !\}
            \{You should report a bug here!\}
            if not lClusterPtr^.fConsistent then goto Inconsistent;
         end;
      for i := FunctorCluster.Count to FunctorCluster.Count + FunctorCluster.fExtCount-1 do
      begin
         RoundUpWith(FunctorCluster.Items^[i],nTrm,nTyp,lClusterPtr);
         \{ Powinno sie tutaj zglosic blad !\}
         \{You should report a bug here!\}
         if not lClusterPtr^.fConsistent then goto Inconsistent;
      end;
      Inconsistent:
         dispose(nTyp^.UpperCluster,Done);
      nTyp^.UpperCluster := lClusterPtr;
   end;
end;
\nwindexdefn{\nwixident{RoundUpItem}}{RoundUpItem}{NW4fRSrE-4bfqVL-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{RoundUpItem}}{RoundUpItem}}}\nwendcode{}\nwbegindocs{310}\nwdocspar
\nwenddocs{}\nwbegincode{311}\sublabel{NW4fRSrE-y2T7a-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-y2T7a-1}}}\moddef{Parse a registration~{\nwtagstyle{}\subpageref{NW4fRSrE-y2T7a-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Registration}{NW4fRSrE-y2T7a-1};
var
   lDeclBase,i,z,pVarNbr: integer;
   lRoundUpClusters: boolean;
begin
   InFile.InPos(CurPos);
   \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} := 2*MaxArgNbr;
   \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   d := g;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocPredNbr := LocPredDef.Count;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocFuncNbr := LocFuncDef.Count;
   \nwlinkedidentc{OpenDef}{NW4fRSrE-3bvXko-1};
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elRegistrationBlock);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   g.GenCount := 0;
   g.DemBase := g.VarNbr;
   \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Init(2,4);
   while InFile.Current.Kind <> ikMscEndBlock do
   begin
      fillchar(gCorrCond[1],SizeOf(gCorrCond)-SizeOf(pointer),0);
      ItTyp := nil;
      \{ Inicjalizacje do obslugi konstruktorow i definiensu\}
      \{ Initializations for handling constructors and definiens\}
      case InFile.Current.Kind of
         ikItmGeneralization:
            begin
               lDeclBase := g.VarNbr;
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Parametrization}{NW4fRSrE-4I8XVV-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
            end;
\{ Przy przyjeciu restrykcyjnej koncepcji dla typow lokusow nie ma sensu
  uzywac tej samej procedury dla generalizacji i parametryzacji.
\}
\{ When adopting a restrictive concept for locus types, it does not make sense
  to use the same procedure for generalization and parameterization.
\}
         ikItmCluRegistered:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefExistentialCluster}{NW4fRSrE-sMl51-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elRegistration);
               \{$ENDIF\}
            end;
         ikItmCluConditional:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefConditionalCluster}{NW4fRSrE-1gUvy2-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elRegistration);
               \{$ENDIF\}
            end;
         ikItmCluFunctor:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefFunctorCluster}{NW4fRSrE-mgVCP-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elRegistration);
               \{$ENDIF\}
               \{ R e t r o s p e k t y w n e   z a o k r a g l a n i e   t y p o w \}
               with gTermCollection do
                  for z := 0 to Count-1 do \nwlinkedidentc{RoundUpItem}{NW4fRSrE-4bfqVL-1}(TTPairPtr(Items^[z]));
            end;
         // ###TODO: why canceled clusters??? This may probably cause BUGS!
         ikIdFunctors:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elIdentifyRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefIdentify}{NW4fRSrE-2RxeIl-1}(ikTrmFunctor);
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elIdentifyRegistration);
               \{$ENDIF\}
            end;
         ikIdPredicates:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elIdentifyRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefIdentify}{NW4fRSrE-2RxeIl-1}(ikFrmPred);
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elIdentifyRegistration);
               \{$ENDIF\}
            end;
         ikIdAttributes:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elIdentifyRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefIdentify}{NW4fRSrE-2RxeIl-1}(ikFrmAttr);
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elIdentifyRegistration);
               \{$ENDIF\}
            end;
         ikReduceFunctors:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elReductionRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefReduction}{NW4fRSrE-4eg3tM-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Correctness}{NW4fRSrE-11hqoE-1};
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elReductionRegistration);
               \{$ENDIF\}
            end;
         ikProperty:
            begin
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElStart0(elPropertyRegistration);
               \{$ENDIF\}
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{DefProperty}{NW4fRSrE-2NEGZf-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(0,0,\nwlinkedidentc{gPropertyCond}{NW4fRSrE-2NEGZf-1});
               \{$IFDEF ANALYZER_REPORT\}
               AReport.Out_XElEnd(elPropertyRegistration);
               \{$ENDIF\}
            end
      else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
      end;
      if ItTyp<> nil then dispose(ItTyp,Done);
      DisplayLine(CurPos.Line,ErrorNbr);
   end;
   InFile.InPos(CurPos); InFile.InWord;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elRegistrationBlock);
   \{$ENDIF\}
   lRoundUpClusters := (ConditionalCluster.fExtCount > 0)
      or (FunctorCluster.fExtCount > 0);
   DisposeTrmList(\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}); \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   \nwlinkedidentc{CloseDef}{NW4fRSrE-713M3-1};
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(d);
   \nwlinkedidentc{gMaxArgNbr}{NW4fRSrE-WoH1u-1} := MaxArgNbr;
   if lRoundUpClusters then
   begin
      NonZeroTyp^.RoundUp;
      for i := 0 to RegisteredCluster.Count-1 do
         with RClusterPtr(RegisteredCluster.Items^[i])^ do
      begin
         move(nPrimaryList.Items^,LocArgTyp[1],nPrimaryList.Count*sizeof(pointer));
         nConsequent.Upper^.RoundUpWith(nClusterType);
         gTermCollection.FreeAll;
      end;
   end;
   RemoveTermsFromTTColl;
end;
\nwindexdefn{\nwixident{Registration}}{Registration}{NW4fRSrE-y2T7a-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Registration}}{Registration}}}\nwidentuses{\\{{\nwixident{CloseDef}}{CloseDef}}\\{{\nwixident{Correctness}}{Correctness}}\\{{\nwixident{D}}{D}}\\{{\nwixident{DefConditionalCluster}}{DefConditionalCluster}}\\{{\nwixident{DefExistentialCluster}}{DefExistentialCluster}}\\{{\nwixident{DefFunctorCluster}}{DefFunctorCluster}}\\{{\nwixident{DefIdentify}}{DefIdentify}}\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DefProperty}}{DefProperty}}\\{{\nwixident{DefReduction}}{DefReduction}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}\\{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}\\{{\nwixident{gPropertyCond}}{gPropertyCond}}\\{{\nwixident{Justify}}{Justify}}\\{{\nwixident{OpenDef}}{OpenDef}}\\{{\nwixident{Parametrization}}{Parametrization}}\\{{\nwixident{RoundUpItem}}{RoundUpItem}}\\{{\nwixident{Statement}}{Statement}}}\nwindexuse{\nwixident{CloseDef}}{CloseDef}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{Correctness}}{Correctness}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{D}}{D}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefConditionalCluster}}{DefConditionalCluster}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefExistentialCluster}}{DefExistentialCluster}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefFunctorCluster}}{DefFunctorCluster}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefIdentify}}{DefIdentify}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefProperty}}{DefProperty}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DefReduction}}{DefReduction}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{gMaxArgNbr}}{gMaxArgNbr}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{gPropertyCond}}{gPropertyCond}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{Justify}}{Justify}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{OpenDef}}{OpenDef}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{Parametrization}}{Parametrization}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{RoundUpItem}}{RoundUpItem}{NW4fRSrE-y2T7a-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-y2T7a-1}\nwendcode{}\nwbegindocs{312}\nwdocspar
\nwenddocs{}\nwbegincode{313}\sublabel{NW4fRSrE-2ABHYV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2ABHYV-1}}}\moddef{Parse notation~{\nwtagstyle{}\subpageref{NW4fRSrE-2ABHYV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Notation}{NW4fRSrE-2ABHYV-1};
var
   lDeclBase,pVarNbr: integer;
   nk: NotationKind;
begin
   InFile.InPos(CurPos);
   \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   d := g;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocPredNbr := LocPredDef.Count;
   \nwlinkedidentc{D}{NW4fRSrE-3bvXko-1}.LocFuncNbr := LocFuncDef.Count;
   \nwlinkedidentc{OpenDef}{NW4fRSrE-3bvXko-1};
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elNotationBlock);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   g.LastEntry := nil;
   g.GenCount := 0;
   g.DemBase := g.VarNbr;
   \nwlinkedidentc{DefinitionList}{NW4fRSrE-VhUFe-1}.Init(2,4);
   while InFile.Current.Kind <> ikMscEndBlock do
   begin
      ItTyp := nil;
      nk := noForgetFunctor; // used as the uninitialised value for patterns here
      \{ Inicjalizacje do obslugi konstruktorow i definiensu\}
      \{ Initializations for handling constructors and definiens\}
      gWhichOne := 0;
      gSuperfluous := 0; \{ dla definicji zostaje 0, dla redefinicji jest wyliczana \}
                         \{ for definition it remains 0, for redefinition it is calculated \}
      case InFile.Current.Kind of
         ikItmGeneralization:
            begin lDeclBase := g.VarNbr;
            gExportableItem := true;
            gConstInExportableItemOcc := false;
            \nwlinkedidentc{Parametrization}{NW4fRSrE-4I8XVV-1};
            gExportableItem := false;
            gConstInExportableItemOcc := false;
            end;
         \{ Przy przyjeciu restrykcyjnej koncepcji dla typow lokusow nie ma sensu
           uzywac tej samej procedury dla generalizacji i parametryzacji.
         \}
         \{ When adopting a restrictive concept for locus types, it does not make sense
           to use the same procedure for generalization and parameterization. \}
         ikItmDefMode:
            begin
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{NotatModePattern}{NW4fRSrE-3lavOg-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               nk := noMode;
            end;
         ikItmDefPred:
            begin
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{NotatPredPattern}{NW4fRSrE-ZDOZa-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               nk := noPredicate;
            end;
         // ###TODO: ikItmDefAttr and ikItmRedefAttr are no longer used in anal,
         //           it may be a dead code in parser too - fix it
         ikItmDefPrAttr:
            begin
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{NotatPredAttributePattern}{NW4fRSrE-3AWSsC-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               nk := noAttribute;
            end;
         ikItmDefFunc:
            begin
               gExportableItem := true;
               gConstInExportableItemOcc := false;
               \nwlinkedidentc{NotatFuncPattern}{NW4fRSrE-49kkDZ-1};
               gExportableItem := false;
               gConstInExportableItemOcc := false;
               nk := noFunctor;
            end;
         // ten Staement jest dla celow Errors Recovery na przypadek bledow syntaktycznych
         \{ This \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1} is for Errors Recovery purposes in case of syntactic errors \}
      else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
      end;
      if ItTyp<> nil then dispose(ItTyp,Done);
      DisplayLine(CurPos.Line,ErrorNbr);
      \{$IFDEF ANALYZER_REPORT\}
      if nk <> noForgetFunctor then
         with Notat[nk] do
            AReport.Out_Pattern(Items^[Count + fExtCount - 1],
                                Count + fExtCount);
      \{$ENDIF\}
   end;
   InFile.InPos(CurPos); InFile.InWord;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elNotationBlock);
   \{$ENDIF\}
   DisposeTrmList(\nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1}); \nwlinkedidentc{gDefiniendumArgs}{NW4fRSrE-4KFoj-1} := nil;
   \nwlinkedidentc{CloseDef}{NW4fRSrE-713M3-1};
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(d);
end;
\nwindexdefn{\nwixident{Notation}}{Notation}{NW4fRSrE-2ABHYV-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Notation}}{Notation}}}\nwidentuses{\\{{\nwixident{CloseDef}}{CloseDef}}\\{{\nwixident{D}}{D}}\\{{\nwixident{DefinitionList}}{DefinitionList}}\\{{\nwixident{DisposeLevel}}{DisposeLevel}}\\{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}\\{{\nwixident{NotatFuncPattern}}{NotatFuncPattern}}\\{{\nwixident{NotatModePattern}}{NotatModePattern}}\\{{\nwixident{NotatPredAttributePattern}}{NotatPredAttributePattern}}\\{{\nwixident{NotatPredPattern}}{NotatPredPattern}}\\{{\nwixident{OpenDef}}{OpenDef}}\\{{\nwixident{Parametrization}}{Parametrization}}\\{{\nwixident{Statement}}{Statement}}}\nwindexuse{\nwixident{CloseDef}}{CloseDef}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{D}}{D}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{DefinitionList}}{DefinitionList}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{NotatFuncPattern}}{NotatFuncPattern}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{NotatModePattern}}{NotatModePattern}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{NotatPredAttributePattern}}{NotatPredAttributePattern}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{NotatPredPattern}}{NotatPredPattern}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{OpenDef}}{OpenDef}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{Parametrization}}{Parametrization}{NW4fRSrE-2ABHYV-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-2ABHYV-1}\nwendcode{}\nwbegindocs{314}\nwdocspar
\nwenddocs{}\nwbegincode{315}\sublabel{NW4fRSrE-2pbBPs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2pbBPs-1}}}\moddef{Parse a scheme block~{\nwtagstyle{}\subpageref{NW4fRSrE-2pbBPs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Scheme}{NW4fRSrE-2pbBPs-1};
var
   kk: integer;
begin
   InFile.InPos(CurPos);
   \{----\}
   MarkTermsInTTColl;
   \{----\}
   gExportableItem := true;
   gConstInExportableItemOcc := false;
   \nwlinkedidentc{SchemeBody}{NW4fRSrE-4O6RPc-1};
   gExportableItem := false;
   gConstInExportableItemOcc := false;
   Infile.InWord;
   \nwlinkedidentc{Demonstration}{NW4fRSrE-2oe4Xh-1}(0,0,\nwlinkedidentc{gSchemeThesis}{NW4fRSrE-4O6RPc-1});
   dispose(\nwlinkedidentc{gSchemeThesis}{NW4fRSrE-4O6RPc-1},Done);
   CurSchFuncTyp.Done;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_EndPos(CurPos);
   AReport.Out_XElEnd(elSchemeBlock);
   \{$ENDIF\}
   for kk := 1 to \nwlinkedidentc{CurSchFuncNbr}{NW4fRSrE-4O6RPc-1} do SchFuncArity[kk].nArity.Done;
   for kk := 1 to \nwlinkedidentc{gSchPredNbr}{NW4fRSrE-4O6RPc-1} do SchPredArity[kk].nArity.Done;
   RemoveTermsFromTTColl;
end;
\nwindexdefn{\nwixident{Scheme}}{Scheme}{NW4fRSrE-2pbBPs-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Scheme}}{Scheme}}}\nwidentuses{\\{{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}}\\{{\nwixident{Demonstration}}{Demonstration}}\\{{\nwixident{gSchemeThesis}}{gSchemeThesis}}\\{{\nwixident{gSchPredNbr}}{gSchPredNbr}}\\{{\nwixident{SchemeBody}}{SchemeBody}}}\nwindexuse{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}{NW4fRSrE-2pbBPs-1}\nwindexuse{\nwixident{Demonstration}}{Demonstration}{NW4fRSrE-2pbBPs-1}\nwindexuse{\nwixident{gSchemeThesis}}{gSchemeThesis}{NW4fRSrE-2pbBPs-1}\nwindexuse{\nwixident{gSchPredNbr}}{gSchPredNbr}{NW4fRSrE-2pbBPs-1}\nwindexuse{\nwixident{SchemeBody}}{SchemeBody}{NW4fRSrE-2pbBPs-1}\nwendcode{}\nwbegindocs{316}\nwdocspar
\nwenddocs{}\nwbegincode{317}\sublabel{NW4fRSrE-2c2VWg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2c2VWg-1}}}\moddef{Analyze reduction-like theorem~{\nwtagstyle{}\subpageref{NW4fRSrE-2c2VWg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
\{$IFDEF THEOREM2REDUCTION\}
var \nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1}: text;
const fileTh2RedName = 'th2red.txt';
var \nwlinkedidentc{ThNr}{NW4fRSrE-2c2VWg-1}: word;

function \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1}(f: FrmPtr): boolean;
var
   lPredNr: integer;
   lArgs: TrmList;
begin
   case f^.FrmSort of
      ikFrmPred:
         begin
            AdjustFrm(PredFrmPtr(f),lPredNr,lArgs);
            if lPredNr = gBuiltIn[rqEqualsTo] then
               \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1} := 
                  ReductionAllowed(lArgs^.XTrmPtr,lArgs^.NextTrm^.XTrmPtr) or
                  ReductionAllowed(lArgs^.NextTrm^.XTrmPtr,lArgs^.XTrmPtr)
            else \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1} := false;
         end;
      ikFrmUniv: \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1} := \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1}(UnivFrmPtr(f)^.Scope);
      //  ikFrmNeg: \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1} := \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1}(NegFrmPtr(f)^.NegArg);
   else \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1} := false;
   end;
end;
\{$ENDIF\}
\nwindexdefn{\nwixident{ReductionLikeTheorem}}{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1}\nwindexdefn{\nwixident{fileTh2Red}}{fileTh2Red}{NW4fRSrE-2c2VWg-1}\nwindexdefn{\nwixident{ThNr}}{ThNr}{NW4fRSrE-2c2VWg-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{fileTh2Red}}{fileTh2Red}}\\{{\nwixident{ReductionLikeTheorem}}{ReductionLikeTheorem}}\\{{\nwixident{ThNr}}{ThNr}}}\nwendcode{}\nwbegindocs{318}\nwdocspar
\nwenddocs{}\nwbegincode{319}\sublabel{NW4fRSrE-2bBUbD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2bBUbD-1}}}\moddef{Parse a theorem~{\nwtagstyle{}\subpageref{NW4fRSrE-2bBUbD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Theorem}{NW4fRSrE-2bBUbD-1};
var
   lFrm: FrmPtr;
   lLabNr,lLabId: integer;
begin
   InFile.InPos(CurPos);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElStart(elJustifiedTheorem);
   AReport.Out_PosAsAttrs(CurPos);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   InFile.InWord;
   lLabNr := InFile.Current.Nr;
   InFile.InInt(lLabId);
   InFile.InPos(CurPos);
   InFile.InWord;
   gExportableItem := true;
   gConstInExportableItemOcc := false;
   lFrm := \nwlinkedidentc{ReadSentence}{NW4fRSrE-2YZvDi-1}(false);
   \{$IFDEF THEOREM2REDUCTION\}
   if \nwlinkedidentc{ReductionLikeTheorem}{NW4fRSrE-2c2VWg-1}(lFrm) then
   begin
      ErrImm(701);
      if \nwlinkedidentc{ThNr}{NW4fRSrE-2c2VWg-1} = 1 then writeln(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1},MizFileName);
      writeln(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1},CurPos.Line, ' ',CurPos.Col, ' ', 701);
      inc(\nwlinkedidentc{ThNr}{NW4fRSrE-2c2VWg-1});
   end;
   \{$ENDIF\}
   gExportableItem := false;
   gConstInExportableItemOcc := false;
   \nwlinkedidentc{Justify}{NW4fRSrE-3T8oCT-1}(lLabNr,lLabId,lFrm);
   dispose(lFrm,Done);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElEnd(elJustifiedTheorem);
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{Theorem}}{Theorem}{NW4fRSrE-2bBUbD-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Theorem}}{Theorem}}}\nwidentuses{\\{{\nwixident{fileTh2Red}}{fileTh2Red}}\\{{\nwixident{Justify}}{Justify}}\\{{\nwixident{ReadSentence}}{ReadSentence}}\\{{\nwixident{ReductionLikeTheorem}}{ReductionLikeTheorem}}\\{{\nwixident{ThNr}}{ThNr}}}\nwindexuse{\nwixident{fileTh2Red}}{fileTh2Red}{NW4fRSrE-2bBUbD-1}\nwindexuse{\nwixident{Justify}}{Justify}{NW4fRSrE-2bBUbD-1}\nwindexuse{\nwixident{ReadSentence}}{ReadSentence}{NW4fRSrE-2bBUbD-1}\nwindexuse{\nwixident{ReductionLikeTheorem}}{ReductionLikeTheorem}{NW4fRSrE-2bBUbD-1}\nwindexuse{\nwixident{ThNr}}{ThNr}{NW4fRSrE-2bBUbD-1}\nwendcode{}\nwbegindocs{320}\nwdocspar
\nwenddocs{}\nwbegincode{321}\sublabel{NW4fRSrE-2EOET6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-2EOET6-1}}}\moddef{Parse section~{\nwtagstyle{}\subpageref{NW4fRSrE-2EOET6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Section}{NW4fRSrE-2EOET6-1};
begin
   InFile.InPos(CurPos);
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XEl1(elSection);
   \{$ENDIF\}
   InFile.InWord;
end;
\nwindexdefn{\nwixident{Section}}{Section}{NW4fRSrE-2EOET6-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Section}}{Section}}}\nwendcode{}\nwbegindocs{322}\nwdocspar
\nwenddocs{}\nwbegincode{323}\sublabel{NW4fRSrE-3nSQUb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-3nSQUb-1}}}\moddef{Parse cancelled item~{\nwtagstyle{}\subpageref{NW4fRSrE-3nSQUb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Canceled}{NW4fRSrE-3nSQUb-1};
var
   lThProp: PropositionPtr;
begin
   InFile.InWord;
   if InFile.Current.Kind = ikTheoremCanceled then
   begin
      lThProp := new(PropositionPtr, Init(0, 0, NewVerum, CurPos));
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elJustifiedTheorem);
      AReport.Out_PosAsAttrs(CurPos);
      AReport.Out_XAttrEnd;
      AReport.Out_Proposition(lThProp);
      AReport.Out_XEl1(elSkippedProof);
      AReport.Out_XElEnd(elJustifiedTheorem);
      \{$ENDIF\}
      dispose(lThProp, Done);
   end
   else
   begin
      \{$IFDEF ANALYZER_REPORT\}
      AReport.Out_XElStart(elCanceled);
      AReport.Out_XAttr(atKind, InFile.Current.Kind);
      AReport.Out_XElEnd0;
      \{$ENDIF\}
   end;
   InFile.InWord;
end;
\nwindexdefn{\nwixident{Canceled}}{Canceled}{NW4fRSrE-3nSQUb-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Canceled}}{Canceled}}}\nwendcode{}\nwbegindocs{324}\nwdocspar
\nwenddocs{}\nwbegincode{325}\sublabel{NW4fRSrE-KkIxc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-KkIxc-1}}}\moddef{Load SGN environment file(?)~{\nwtagstyle{}\subpageref{NW4fRSrE-KkIxc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{LoadSGN}{NW4fRSrE-KkIxc-1};
var
   Antonym: boolean;
   lPattern: PatternPtr;
   lInEnvFile: InEnvFilePtr;
   nk: NotationKind;
begin
   FileExam(EnvFileName+'.eno');
   lInEnvFile := new(InEnvFilePtr,OpenFile(EnvFileName+'.eno'));
   with lInEnvFile^ do
   begin
      NextElementState;
      XMLASSERT(nElKind = elNotations);
      NextElementState;
      for nk := Low(NotationKind) to High(NotationKind) do
         Notat[ nk].Init(MaxNotatNbr(nk));
      while not (nState = eEnd) do
      begin
         XMLASSERT(nElKind = elPattern);
         lPattern := In_Pattern;
         Notat[lPattern^.fKind].Insert(lPattern);
         gTermCollection.FreeAll;
      end;
   end;
   dispose(lInEnvFile,Done);
   for nk := Low(NotationKind) to High(NotationKind) do
      NotatBase[nk] := Notat[nk].Count;
end;
\nwindexdefn{\nwixident{LoadSGN}}{LoadSGN}{NW4fRSrE-KkIxc-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{LoadSGN}}{LoadSGN}}}\nwendcode{}\nwbegindocs{326}\nwdocspar
\nwenddocs{}\nwbegincode{327}\sublabel{NW4fRSrE-1OBgEQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1OBgEQ-1}}}\moddef{Dispose analyze~{\nwtagstyle{}\subpageref{NW4fRSrE-1OBgEQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{DisposeAnalyze}{NW4fRSrE-1OBgEQ-1};
var
   nk: NotationKind;
   gg: LevelRec;
begin
   Definientia.Done;
   gIdentifications.Done;
   gReductions.Done;
   gPropertiesList.Done;
   for nk := Low(NotationKind) to High(NotationKind) do
      Notat[nk].Done;
   DisposeConstructors;
   dispose(AnyTyp,Done);
   with gg do
   begin
      VarNbr := 0;
      LocPredNbr := 0;
      LocFuncNbr := 0;
   end;
   \nwlinkedidentc{DisposeLevel}{NW4fRSrE-14nyvU-1}(gg);
   gTermCollection.Done;
   \{-writeln(InfoFile,'Koniec analizatora, MemAvail=',MemAvail);
    InfoHeap;-\}
end;
\nwindexdefn{\nwixident{DisposeAnalyze}}{DisposeAnalyze}{NW4fRSrE-1OBgEQ-1}\eatline
\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{DisposeAnalyze}}{DisposeAnalyze}}}\nwidentuses{\\{{\nwixident{DisposeLevel}}{DisposeLevel}}}\nwindexuse{\nwixident{DisposeLevel}}{DisposeLevel}{NW4fRSrE-1OBgEQ-1}\nwendcode{}\nwbegindocs{328}\nwdocspar
\nwenddocs{}\nwbegincode{329}\sublabel{NW4fRSrE-1Bkikv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4fRSrE-1Bkikv-1}}}\moddef{Analyze~{\nwtagstyle{}\subpageref{NW4fRSrE-1Bkikv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4fRSrE-24b9uj-4}}\nwenddeflinemarkup
procedure \nwlinkedidentc{Analyze}{NW4fRSrE-1Bkikv-1};
var
   kk: integer;
   c: ConstructorsKind;
begin
   \{$IFDEF THEOREM2REDUCTION\}   
   Assign(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1},fileTh2RedName);
   if MFileExists(fileTh2RedName) then Append(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1}) else Rewrite(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1});
   \nwlinkedidentc{ThNr}{NW4fRSrE-2c2VWg-1} := 1;
   \{$ENDIF\}
   \{\}
   Load_EnvConstructors;
   gAttrCollected := false;
   \{\}
   for c := Low(ConstructorsKind) to High(ConstructorsKind) do
      ConstrBase[c]      := Constr[c].Count;
   RegClusterBase := RegisteredCluster.Count;
   FuncClusterBase := FunctorCluster.Count;
   CondClusterBase := ConditionalCluster.Count;
   \nwlinkedidentc{gDefNode}{NW4fRSrE-3w2GDr-1}.fPrimaries.Init(0,1);
   AnyTyp := new(TypPtr,Init(ikTypMode,NewEmptyCluster,NewEmptyCluster,gBuiltIn[rqAny],Nil));
   ResNbr := 0;
   with g do begin VarNbr := 0; LocPredNbr := 0; LocFuncNbr := 0 end;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.OpenFileWithXSL(MizFileName+'.xml');
   AReport.Out_XElStart(elArticle);
   AReport.Out_XAttr(atAid, ArticleID);
   AReport.Out_XMizQuotedAttr(atMizfiles, MizFiles);
   AReport.Out_XAttrEnd;
   \{$ENDIF\}
   \nwlinkedidentc{LoadSGN}{NW4fRSrE-KkIxc-1};
   \{ obsluga nieoczekiwanych warunkow \}
   \{ handling unexpected conditions \}
   gCorrCond[0] := NewIncorFrm;
   Definientia.Init(20);
   if Verifying then LoadDefinitions;
   gIdentifications.Init(0);
   gReductions.Init(0);
   gPropertiesList.Init(0);
   LoadPropertiesReg;
   RegPropertiesBase := gPropertiesList.Count;
   InFile.OpenFile(MizFileName+'.par');
   InFile.InWord;
   \{$IFDEF ANALYZER_REPORT\}
   DoCtrans := false; DoStrans := false;
   \{$ENDIF\}
   while InFile.Current.Kind<>'!' do
   begin
      case InFile.Current.Kind of
         ikBlcSection: \nwlinkedidentc{Section}{NW4fRSrE-2EOET6-1};
         ikBlcDefinition: \nwlinkedidentc{Definition}{NW4fRSrE-2qhgrW-1};
         ikBlcRegistration: \nwlinkedidentc{Registration}{NW4fRSrE-y2T7a-1};
         ikBlcNotation: \nwlinkedidentc{Notation}{NW4fRSrE-2ABHYV-1};
         ikItmReservation: \nwlinkedidentc{Reservation}{NW4fRSrE-4G4xQr-1};
         ikBlcScheme: \nwlinkedidentc{Scheme}{NW4fRSrE-2pbBPs-1};
         ikItmTheorem: \nwlinkedidentc{Theorem}{NW4fRSrE-2bBUbD-1};
         ikItmCanceled: \nwlinkedidentc{Canceled}{NW4fRSrE-3nSQUb-1};
      else \nwlinkedidentc{Statement}{NW4fRSrE-4XKGIt-1};
      end;
      \{$IFDEF ANALYZER_REPORT\}
      AReport.OutNewLine;
      \{$ENDIF\}
      DisplayLine(CurPos.Line,ErrorNbr);
   end;
   Infile.Done;
   \{$IFDEF ANALYZER_REPORT\}
   AReport.Out_XElEnd(elArticle);
   AReport.Done;
   \{$ENDIF\}
   dispose(gCorrCond[0],Done);
   for kk := 1 to ResNbr do dispose(ReservedVar[kk],Done);
   \{$IFDEF THEOREM2REDUCTION\}
   Close(\nwlinkedidentc{fileTh2Red}{NW4fRSrE-2c2VWg-1});
   \{$ENDIF\}
end;
\nwindexdefn{\nwixident{Analyze}}{Analyze}{NW4fRSrE-1Bkikv-1}\eatline

\nwused{\\{NW4fRSrE-24b9uj-4}}\nwidentdefs{\\{{\nwixident{Analyze}}{Analyze}}}\nwidentuses{\\{{\nwixident{Canceled}}{Canceled}}\\{{\nwixident{Definition}}{Definition}}\\{{\nwixident{fileTh2Red}}{fileTh2Red}}\\{{\nwixident{gDefNode}}{gDefNode}}\\{{\nwixident{LoadSGN}}{LoadSGN}}\\{{\nwixident{Notation}}{Notation}}\\{{\nwixident{Registration}}{Registration}}\\{{\nwixident{Reservation}}{Reservation}}\\{{\nwixident{Scheme}}{Scheme}}\\{{\nwixident{Section}}{Section}}\\{{\nwixident{Statement}}{Statement}}\\{{\nwixident{Theorem}}{Theorem}}\\{{\nwixident{ThNr}}{ThNr}}}\nwindexuse{\nwixident{Canceled}}{Canceled}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Definition}}{Definition}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{fileTh2Red}}{fileTh2Red}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{gDefNode}}{gDefNode}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{LoadSGN}}{LoadSGN}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Notation}}{Notation}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Registration}}{Registration}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Reservation}}{Reservation}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Scheme}}{Scheme}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Section}}{Section}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Statement}}{Statement}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{Theorem}}{Theorem}{NW4fRSrE-1Bkikv-1}\nwindexuse{\nwixident{ThNr}}{ThNr}{NW4fRSrE-1Bkikv-1}\nwendcode{}

\nwixlogsorted{c}{{Add items to a cluster}{NW4fRSrE-3yW3eS-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3yW3eS-1}}}%
\nwixlogsorted{c}{{Analyze}{NW4fRSrE-1Bkikv-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-1Bkikv-1}}}%
\nwixlogsorted{c}{{Analyze argument type list}{NW4fRSrE-WoH1u-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-WoH1u-1}}}%
\nwixlogsorted{c}{{Analyze cluster}{NW4fRSrE-3mJ75Q-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3mJ75Q-1}}}%
\nwixlogsorted{c}{{Analyze definitional theorems}{NW4fRSrE-3zzjWM-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-3zzjWM-1}}}%
\nwixlogsorted{c}{{Analyze reduction-like theorem}{NW4fRSrE-2c2VWg-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2c2VWg-1}}}%
\nwixlogsorted{c}{{Analyze selector}{NW4fRSrE-CKGCk-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-CKGCk-1}}}%
\nwixlogsorted{c}{{Analyze sentence}{NW4fRSrE-41aiR1-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-41aiR1-1}}}%
\nwixlogsorted{c}{{Analyze term}{NW4fRSrE-31Gox1-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-31Gox1-1}}}%
\nwixlogsorted{c}{{Analyzer implementation}{NW4fRSrE-SJwsI-1}{\nwixu{NW4fRSrE-1hWBF8-1}\nwixd{NW4fRSrE-SJwsI-1}}}%
\nwixlogsorted{c}{{Analyzer interface}{NW4fRSrE-3aG0Hi-1}{\nwixu{NW4fRSrE-1hWBF8-1}\nwixd{NW4fRSrE-3aG0Hi-1}}}%
\nwixlogsorted{c}{{Analyzer methods}{NW4fRSrE-24b9uj-1}{\nwixu{NW4fRSrE-SJwsI-1}\nwixd{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-24b9uj-4}}}%
\nwixlogsorted{c}{{Append locus}{NW4fRSrE-2jU5qo-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-2jU5qo-1}}}%
\nwixlogsorted{c}{{Change bound variable and iterate}{NW4fRSrE-2cKzYF-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-2cKzYF-1}}}%
\nwixlogsorted{c}{{Change bound variable to declaration(?)}{NW4fRSrE-41YgVE-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-41YgVE-1}}}%
\nwixlogsorted{c}{{Change bound variables and iterate (one)}{NW4fRSrE-1XvsOm-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-1XvsOm-1}}}%
\nwixlogsorted{c}{{Change bound variables and iterate (two)}{NW4fRSrE-1k6dgM-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-1k6dgM-1}}}%
\nwixlogsorted{c}{{Change declared constant to bound variable}{NW4fRSrE-4XBdxo-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4XBdxo-1}}}%
\nwixlogsorted{c}{{Change declared constants to loci}{NW4fRSrE-dAzIv-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-dAzIv-1}}}%
\nwixlogsorted{c}{{Change fixed variables to bound variables}{NW4fRSrE-FAqx7-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-FAqx7-1}}}%
\nwixlogsorted{c}{{Change loci in property}{NW4fRSrE-9km4y-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-9km4y-1}}}%
\nwixlogsorted{c}{{Change loci in sethood property}{NW4fRSrE-321b6z-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-321b6z-1}}}%
\nwixlogsorted{c}{{Change skeletonized fixed variable to bound variable}{NW4fRSrE-2UbSlH-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2UbSlH-1}}}%
\nwixlogsorted{c}{{Change to constructor}{NW4fRSrE-1IRHWc-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-1IRHWc-1}}}%
\nwixlogsorted{c}{{Check access}{NW4fRSrE-1YfrP8-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1YfrP8-1}}}%
\nwixlogsorted{c}{{Check all loci are accessible in term}{NW4fRSrE-38WzsA-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-38WzsA-1}}}%
\nwixlogsorted{c}{{Check all loci are accessible in type}{NW4fRSrE-3K8iTi-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3K8iTi-1}}}%
\nwixlogsorted{c}{{Check for compatible arguments}{NW4fRSrE-4KFoj-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-4KFoj-1}}}%
\nwixlogsorted{c}{{Check Loci constants}{NW4fRSrE-1fVrrm-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1fVrrm-1}}}%
\nwixlogsorted{c}{{Check loci constants in definiens}{NW4fRSrE-4KbSDF-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4KbSDF-1}}}%
\nwixlogsorted{c}{{Chop assumption}{NW4fRSrE-447LJp-1}{\nwixd{NW4fRSrE-447LJp-1}}}%
\nwixlogsorted{c}{{Chop conclusion}{NW4fRSrE-1vzwMI-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1vzwMI-1}}}%
\nwixlogsorted{c}{{Chop variables}{NW4fRSrE-4LBoA7-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4LBoA7-1}}}%
\nwixlogsorted{c}{{Chopping definientia(?)}{NW4fRSrE-1YXN9Y-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1YXN9Y-1}}}%
\nwixlogsorted{c}{{Close a definition}{NW4fRSrE-713M3-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-713M3-1}}}%
\nwixlogsorted{c}{{Coherence}{NW4fRSrE-1tzT4S-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-1tzT4S-1}}}%
\nwixlogsorted{c}{{Collect loci}{NW4fRSrE-1MmOtr-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1MmOtr-1}}}%
\nwixlogsorted{c}{{Compatibility}{NW4fRSrE-sLbTR-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-sLbTR-1}}}%
\nwixlogsorted{c}{{Conjugate a list of propositions}{NW4fRSrE-2UfBO8-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-2UfBO8-1}}}%
\nwixlogsorted{c}{{Consistency}{NW4fRSrE-40T82k-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-40T82k-1}}}%
\nwixlogsorted{c}{{Constructor for \code{}DefNode\edoc{}}{NW4fRSrE-VhUFe-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-VhUFe-1}}}%
\nwixlogsorted{c}{{Constructor formal arguments}{NW4fRSrE-qSnfu-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-qSnfu-1}}}%
\nwixlogsorted{c}{{Copy formula with fresh bound variables}{NW4fRSrE-1DN1eC-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-1DN1eC-1}}}%
\nwixlogsorted{c}{{Correctness conditions}{NW4fRSrE-26ZHbS-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-26ZHbS-1}}}%
\nwixlogsorted{c}{{Create a list of terms}{NW4fRSrE-2ffINP-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2ffINP-1}}}%
\nwixlogsorted{c}{{Create Definientia}{NW4fRSrE-37tZpY-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-37tZpY-1}}}%
\nwixlogsorted{c}{{Create list of constant terms}{NW4fRSrE-a1Spe-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-a1Spe-1}}}%
\nwixlogsorted{c}{{Create list of loci}{NW4fRSrE-11oteT-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-11oteT-1}}}%
\nwixlogsorted{c}{{Declare state variables for analyzer}{NW4fRSrE-3XFrHZ-1}{\nwixu{NW4fRSrE-SJwsI-1}\nwixd{NW4fRSrE-3XFrHZ-1}}}%
\nwixlogsorted{c}{{Declare types for analyzer}{NW4fRSrE-4Jho5-1}{\nwixu{NW4fRSrE-SJwsI-1}\nwixd{NW4fRSrE-4Jho5-1}}}%
\nwixlogsorted{c}{{Decompose formula}{NW4fRSrE-omUgm-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-omUgm-1}}}%
\nwixlogsorted{c}{{Define a structure}{NW4fRSrE-XUFqn-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-XUFqn-1}}}%
\nwixlogsorted{c}{{Define conditional cluster}{NW4fRSrE-1gUvy2-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1gUvy2-1}}}%
\nwixlogsorted{c}{{Define constants for analyzer}{NW4fRSrE-3qWqPm-1}{\nwixu{NW4fRSrE-SJwsI-1}\nwixd{NW4fRSrE-3qWqPm-1}}}%
\nwixlogsorted{c}{{Define existential cluster}{NW4fRSrE-sMl51-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-sMl51-1}}}%
\nwixlogsorted{c}{{Define functorial cluster}{NW4fRSrE-mgVCP-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-mgVCP-1}}}%
\nwixlogsorted{c}{{Define identify}{NW4fRSrE-2RxeIl-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2RxeIl-1}}}%
\nwixlogsorted{c}{{Define property}{NW4fRSrE-2NEGZf-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2NEGZf-1}}}%
\nwixlogsorted{c}{{Define reduction}{NW4fRSrE-4eg3tM-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4eg3tM-1}}}%
\nwixlogsorted{c}{{Definition predicate pattern}{NW4fRSrE-36ZjPM-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-36ZjPM-1}}}%
\nwixlogsorted{c}{{Demonstration}{NW4fRSrE-2oe4Xh-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2oe4Xh-1}}}%
\nwixlogsorted{c}{{Determine abstract notation number}{NW4fRSrE-23RESF-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-23RESF-1}}}%
\nwixlogsorted{c}{{Determine meaning}{NW4fRSrE-S8NVf-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-S8NVf-1}}}%
\nwixlogsorted{c}{{Determine meaning for equation}{NW4fRSrE-P18Rc-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-P18Rc-1}}}%
\nwixlogsorted{c}{{Diffuse per cases reasoning}{NW4fRSrE-1g3pia-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1g3pia-1}}}%
\nwixlogsorted{c}{{Diffuse Reasoning}{NW4fRSrE-3ug0j6-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3ug0j6-1}}}%
\nwixlogsorted{c}{{Diffuse statement}{NW4fRSrE-8Der7-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-8Der7-1}}}%
\nwixlogsorted{c}{{Dispose analyze}{NW4fRSrE-1OBgEQ-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-1OBgEQ-1}}}%
\nwixlogsorted{c}{{Dispose level}{NW4fRSrE-14nyvU-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-14nyvU-1}}}%
\nwixlogsorted{c}{{Existence}{NW4fRSrE-4TUJX-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-4TUJX-1}}}%
\nwixlogsorted{c}{{Find pattern}{NW4fRSrE-1yastl-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1yastl-1}}}%
\nwixlogsorted{c}{{Formal arguments}{NW4fRSrE-Eqhkd-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-Eqhkd-1}}}%
\nwixlogsorted{c}{{Get constant qualified list}{NW4fRSrE-4MdvhM-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-4MdvhM-1}}}%
\nwixlogsorted{c}{{Get pattern}{NW4fRSrE-mDy4S-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-mDy4S-1}}}%
\nwixlogsorted{c}{{Get qualified list}{NW4fRSrE-lPUBf-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-lPUBf-1}}}%
\nwixlogsorted{c}{{Handle formula scheme predicate}{NW4fRSrE-4T3rLo-1}{\nwixu{NW4fRSrE-4O6RPc-1}\nwixd{NW4fRSrE-4T3rLo-1}}}%
\nwixlogsorted{c}{{Handle term scheme functor}{NW4fRSrE-1uiOLv-1}{\nwixu{NW4fRSrE-4O6RPc-1}\nwixd{NW4fRSrE-1uiOLv-1}}}%
\nwixlogsorted{c}{{Hereby}{NW4fRSrE-4BQSHp-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4BQSHp-1}}}%
\nwixlogsorted{c}{{Import common libraries for analyzer}{NW4fRSrE-3rQeqV-1}{\nwixu{NW4fRSrE-SJwsI-1}\nwixd{NW4fRSrE-3rQeqV-1}}}%
\nwixlogsorted{c}{{Initialize access}{NW4fRSrE-41gYk7-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-41gYk7-1}}}%
\nwixlogsorted{c}{{Initialize loci for cluster}{NW4fRSrE-1W2kMW-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1W2kMW-1}}}%
\nwixlogsorted{c}{{Insert a mode}{NW4fRSrE-jEwY5-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-jEwY5-1}}}%
\nwixlogsorted{c}{{Insert functor}{NW4fRSrE-1nPKhC-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1nPKhC-1}}}%
\nwixlogsorted{c}{{Insert predicate}{NW4fRSrE-1Nd4jW-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1Nd4jW-1}}}%
\nwixlogsorted{c}{{Insert predicate or attribute}{NW4fRSrE-1gwegT-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1gwegT-1}}}%
\nwixlogsorted{c}{{Is \code{}Position\edoc{} in the collection?}{NW4fRSrE-3MC2qH-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3MC2qH-1}}}%
\nwixlogsorted{c}{{Justify}{NW4fRSrE-3T8oCT-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3T8oCT-1}}}%
\nwixlogsorted{c}{{kernel/analyzer.pas}{NW4fRSrE-1hWBF8-1}{\nwixd{NW4fRSrE-1hWBF8-1}}}%
\nwixlogsorted{c}{{Load SGN environment file(?)}{NW4fRSrE-KkIxc-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-KkIxc-1}}}%
\nwixlogsorted{c}{{Make list of loci variables}{NW4fRSrE-1OwTRj-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-1OwTRj-1}}}%
\nwixlogsorted{c}{{Mark term as taken}{NW4fRSrE-3IjlED-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3IjlED-1}}}%
\nwixlogsorted{c}{{New in correlate definition}{NW4fRSrE-42RyEy-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-42RyEy-1}}}%
\nwixlogsorted{c}{{New list of universally quantified variables}{NW4fRSrE-3S612w-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3S612w-1}}}%
\nwixlogsorted{c}{{New universal list (one)}{NW4fRSrE-aOrsk-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-aOrsk-1}}}%
\nwixlogsorted{c}{{Notation predicate pattern}{NW4fRSrE-ZDOZa-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-ZDOZa-1}}}%
\nwixlogsorted{c}{{Open a definition}{NW4fRSrE-3bvXko-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-3bvXko-1}}}%
\nwixlogsorted{c}{{Parameter declaration}{NW4fRSrE-29B9Op-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-29B9Op-1}}}%
\nwixlogsorted{c}{{Parse ``BB'' Formal arguments}{NW4fRSrE-9XR3h-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-9XR3h-1}}}%
\nwixlogsorted{c}{{Parse ``CC'' Formal arguments}{NW4fRSrE-1MoVf-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-1MoVf-1}}}%
\nwixlogsorted{c}{{Parse a registration}{NW4fRSrE-y2T7a-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-y2T7a-1}}}%
\nwixlogsorted{c}{{Parse a reservation}{NW4fRSrE-4G4xQr-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4G4xQr-1}}}%
\nwixlogsorted{c}{{Parse a scheme block}{NW4fRSrE-2pbBPs-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2pbBPs-1}}}%
\nwixlogsorted{c}{{Parse a statement}{NW4fRSrE-4XKGIt-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4XKGIt-1}}}%
\nwixlogsorted{c}{{Parse a theorem}{NW4fRSrE-2bBUbD-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2bBUbD-1}}}%
\nwixlogsorted{c}{{Parse cancelled item}{NW4fRSrE-3nSQUb-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-3nSQUb-1}}}%
\nwixlogsorted{c}{{Parse coherence in equals definition}{NW4fRSrE-3pxze-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-3pxze-1}}}%
\nwixlogsorted{c}{{Parse correctness conditions}{NW4fRSrE-11hqoE-1}{\nwixd{NW4fRSrE-11hqoE-1}}}%
\nwixlogsorted{c}{{Parse definition of an expandable mode}{NW4fRSrE-1u93O4-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1u93O4-1}}}%
\nwixlogsorted{c}{{Parse definition of attribute --- tail}{NW4fRSrE-mZ8N3-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-mZ8N3-1}}}%
\nwixlogsorted{c}{{Parse definition of functor --- tail}{NW4fRSrE-2BYsiX-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2BYsiX-1}}}%
\nwixlogsorted{c}{{Parse definition of mode --- tail}{NW4fRSrE-3xpn6K-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3xpn6K-1}}}%
\nwixlogsorted{c}{{Parse definition of predicate --- tail}{NW4fRSrE-2uTf5M-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2uTf5M-1}}}%
\nwixlogsorted{c}{{Parse definitions}{NW4fRSrE-2qhgrW-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2qhgrW-1}}}%
\nwixlogsorted{c}{{Parse functor definition pattern}{NW4fRSrE-138Ush-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-138Ush-1}}}%
\nwixlogsorted{c}{{Parse functor property}{NW4fRSrE-1a7Xmh-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-1a7Xmh-1}}}%
\nwixlogsorted{c}{{Parse mode pattern for notation}{NW4fRSrE-3lavOg-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3lavOg-1}}}%
\nwixlogsorted{c}{{Parse mode pattern in definition}{NW4fRSrE-24hAJs-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-24hAJs-1}}}%
\nwixlogsorted{c}{{Parse mode pattern in redefinition}{NW4fRSrE-2hqWv9-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2hqWv9-1}}}%
\nwixlogsorted{c}{{Parse mode property}{NW4fRSrE-2OQ1CR-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-2OQ1CR-1}}}%
\nwixlogsorted{c}{{Parse notation}{NW4fRSrE-2ABHYV-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2ABHYV-1}}}%
\nwixlogsorted{c}{{Parse notation in a predicate or attribute pattern}{NW4fRSrE-3AWSsC-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3AWSsC-1}}}%
\nwixlogsorted{c}{{Parse notation in functor pattern}{NW4fRSrE-49kkDZ-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-49kkDZ-1}}}%
\nwixlogsorted{c}{{Parse parametrization}{NW4fRSrE-4I8XVV-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-4I8XVV-1}}}%
\nwixlogsorted{c}{{Parse pattern for predicate or attribute redefinition}{NW4fRSrE-2VOwe7-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2VOwe7-1}}}%
\nwixlogsorted{c}{{Parse pattern in functor redefinition}{NW4fRSrE-3o0u5v-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3o0u5v-1}}}%
\nwixlogsorted{c}{{Parse predicate or attribute pattern in definition}{NW4fRSrE-45Cbij-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-45Cbij-1}}}%
\nwixlogsorted{c}{{Parse predicate property}{NW4fRSrE-3HK6tf-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-3HK6tf-1}}}%
\nwixlogsorted{c}{{Parse redefinition specification}{NW4fRSrE-ti2Op-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-ti2Op-1}}}%
\nwixlogsorted{c}{{Parse section}{NW4fRSrE-2EOET6-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-2EOET6-1}}}%
\nwixlogsorted{c}{{Parse specification}{NW4fRSrE-2NGLeB-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2NGLeB-1}}}%
\nwixlogsorted{c}{{Parse uniqueness condition}{NW4fRSrE-3FE2SD-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-3FE2SD-1}}}%
\nwixlogsorted{c}{{Partial uniqueness condition}{NW4fRSrE-1ZhYjH-1}{\nwixu{NW4fRSrE-26ZHbS-1}\nwixd{NW4fRSrE-1ZhYjH-1}}}%
\nwixlogsorted{c}{{Per cases reasoning}{NW4fRSrE-2IcayZ-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2IcayZ-1}}}%
\nwixlogsorted{c}{{Process properties}{NW4fRSrE-18EWMX-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-18EWMX-1}}}%
\nwixlogsorted{c}{{Read a sentence}{NW4fRSrE-2YZvDi-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-2YZvDi-1}}}%
\nwixlogsorted{c}{{Read a term}{NW4fRSrE-3YycCO-1}{\nwixd{NW4fRSrE-3YycCO-1}}}%
\nwixlogsorted{c}{{Read definiens}{NW4fRSrE-2xdcsX-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2xdcsX-1}}}%
\nwixlogsorted{c}{{Read pattern}{NW4fRSrE-2CtgW3-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-2CtgW3-1}}}%
\nwixlogsorted{c}{{Read propositions}{NW4fRSrE-aW1Nc-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-aW1Nc-1}}}%
\nwixlogsorted{c}{{Read type}{NW4fRSrE-2owkOX-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-2owkOX-1}}}%
\nwixlogsorted{c}{{Read visible}{NW4fRSrE-3Z12i6-1}{\nwixd{NW4fRSrE-3Z12i6-1}}}%
\nwixlogsorted{c}{{Reasoning}{NW4fRSrE-1ByLHM-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1ByLHM-1}}}%
\nwixlogsorted{c}{{Reasoning result}{NW4fRSrE-1FcRyw-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1FcRyw-1}}}%
\nwixlogsorted{c}{{Redefine predicate pattern}{NW4fRSrE-3QTOh1-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3QTOh1-1}}}%
\nwixlogsorted{c}{{Regular statement}{NW4fRSrE-4VrAtu-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4VrAtu-1}}}%
\nwixlogsorted{c}{{Renew Const}{NW4fRSrE-8NgkM-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-8NgkM-1}}}%
\nwixlogsorted{c}{{Renew primaries}{NW4fRSrE-3PpPH3-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-3PpPH3-1}}}%
\nwixlogsorted{c}{{Round up item}{NW4fRSrE-4bfqVL-1}{\nwixu{NW4fRSrE-24b9uj-4}\nwixd{NW4fRSrE-4bfqVL-1}}}%
\nwixlogsorted{c}{{Scheme body}{NW4fRSrE-4O6RPc-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-4O6RPc-1}}}%
\nwixlogsorted{c}{{Set Loci occurrences}{NW4fRSrE-c8C2Z-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-c8C2Z-1}}}%
\nwixlogsorted{c}{{Set structure}{NW4fRSrE-vj17M-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-vj17M-1}}}%
\nwixlogsorted{c}{{Set visible (one)}{NW4fRSrE-Aye6w-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-Aye6w-1}}}%
\nwixlogsorted{c}{{Set visible (two)}{NW4fRSrE-3HTkW-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-3HTkW-1}}}%
\nwixlogsorted{c}{{Skeletonize list}{NW4fRSrE-3KnOnX-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-3KnOnX-1}}}%
\nwixlogsorted{c}{{Skeletonize sentence}{NW4fRSrE-4QAXkH-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4QAXkH-1}}}%
\nwixlogsorted{c}{{Spread atomic formula}{NW4fRSrE-1O513Y-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-1O513Y-1}}}%
\nwixlogsorted{c}{{Spread local predicates}{NW4fRSrE-35R9Kt-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-35R9Kt-1}}}%
\nwixlogsorted{c}{{Swap loci in type}{NW4fRSrE-zQWZB-1}{\nwixu{NW4fRSrE-24b9uj-3}\nwixd{NW4fRSrE-zQWZB-1}}}%
\nwixlogsorted{c}{{Write definiens}{NW4fRSrE-4OXFUo-1}{\nwixu{NW4fRSrE-24b9uj-2}\nwixd{NW4fRSrE-4OXFUo-1}}}%
\nwixlogsorted{c}{{Write definiens label}{NW4fRSrE-3w2GDr-1}{\nwixd{NW4fRSrE-3w2GDr-1}}}%
\nwixlogsorted{c}{{Write qualified}{NW4fRSrE-1GXbPG-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-1GXbPG-1}}}%
\nwixlogsorted{c}{{xFormula(?)}{NW4fRSrE-3ZW69r-1}{\nwixu{NW4fRSrE-24b9uj-1}\nwixd{NW4fRSrE-3ZW69r-1}}}%
\nwixlogsorted{i}{{\nwixident{{\_}IdentifyData}}{:unIdentifyData}}%
\nwixlogsorted{i}{{\nwixident{AbsNotatNr}}{AbsNotatNr}}%
\nwixlogsorted{i}{{\nwixident{AddToCluster}}{AddToCluster}}%
\nwixlogsorted{i}{{\nwixident{AllLociAccessibleInTrm}}{AllLociAccessibleInTrm}}%
\nwixlogsorted{i}{{\nwixident{AllLociAccessibleInTyp}}{AllLociAccessibleInTyp}}%
\nwixlogsorted{i}{{\nwixident{AnalizeArgTypeList}}{AnalizeArgTypeList}}%
\nwixlogsorted{i}{{\nwixident{Analyze}}{Analyze}}%
\nwixlogsorted{i}{{\nwixident{AnalyzeCluster}}{AnalyzeCluster}}%
\nwixlogsorted{i}{{\nwixident{AnalyzeSelector}}{AnalyzeSelector}}%
\nwixlogsorted{i}{{\nwixident{AnalyzeSnt}}{AnalyzeSnt}}%
\nwixlogsorted{i}{{\nwixident{AnalyzeTerm}}{AnalyzeTerm}}%
\nwixlogsorted{i}{{\nwixident{AppendLocus}}{AppendLocus}}%
\nwixlogsorted{i}{{\nwixident{BB{\_}FormalArgs}}{BB:unFormalArgs}}%
\nwixlogsorted{i}{{\nwixident{C{\_}FormalArgs}}{C:unFormalArgs}}%
\nwixlogsorted{i}{{\nwixident{Canceled}}{Canceled}}%
\nwixlogsorted{i}{{\nwixident{CC{\_}FormalArgs}}{CC:unFormalArgs}}%
\nwixlogsorted{i}{{\nwixident{ChangeBoundAndIt}}{ChangeBoundAndIt}}%
\nwixlogsorted{i}{{\nwixident{ChangeBoundAndIt1}}{ChangeBoundAndIt1}}%
\nwixlogsorted{i}{{\nwixident{ChangeBoundAndIt2}}{ChangeBoundAndIt2}}%
\nwixlogsorted{i}{{\nwixident{ChangeBoundToDecl}}{ChangeBoundToDecl}}%
\nwixlogsorted{i}{{\nwixident{ChangeDeclConstToBound}}{ChangeDeclConstToBound}}%
\nwixlogsorted{i}{{\nwixident{ChangeDeclConstToLoci}}{ChangeDeclConstToLoci}}%
\nwixlogsorted{i}{{\nwixident{ChangeFixedToBound}}{ChangeFixedToBound}}%
\nwixlogsorted{i}{{\nwixident{ChangeLociInProperty}}{ChangeLociInProperty}}%
\nwixlogsorted{i}{{\nwixident{ChangeLociInPropertySetHood}}{ChangeLociInPropertySetHood}}%
\nwixlogsorted{i}{{\nwixident{ChangeSkFixedToBound}}{ChangeSkFixedToBound}}%
\nwixlogsorted{i}{{\nwixident{ChangeToConst}}{ChangeToConst}}%
\nwixlogsorted{i}{{\nwixident{CheckAccess}}{CheckAccess}}%
\nwixlogsorted{i}{{\nwixident{CheckLocConstInDefiniens}}{CheckLocConstInDefiniens}}%
\nwixlogsorted{i}{{\nwixident{CheckLocConts}}{CheckLocConts}}%
\nwixlogsorted{i}{{\nwixident{ChopAssum}}{ChopAssum}}%
\nwixlogsorted{i}{{\nwixident{ChopConcl}}{ChopConcl}}%
\nwixlogsorted{i}{{\nwixident{Chopped}}{Chopped}}%
\nwixlogsorted{i}{{\nwixident{ChopVars}}{ChopVars}}%
\nwixlogsorted{i}{{\nwixident{CloseDef}}{CloseDef}}%
\nwixlogsorted{i}{{\nwixident{Coherence}}{Coherence}}%
\nwixlogsorted{i}{{\nwixident{CoherenceEq}}{CoherenceEq}}%
\nwixlogsorted{i}{{\nwixident{CollectLoci}}{CollectLoci}}%
\nwixlogsorted{i}{{\nwixident{Compatibility}}{Compatibility}}%
\nwixlogsorted{i}{{\nwixident{CompatibleArgs}}{CompatibleArgs}}%
\nwixlogsorted{i}{{\nwixident{ConjugatePropositions}}{ConjugatePropositions}}%
\nwixlogsorted{i}{{\nwixident{Consistency}}{Consistency}}%
\nwixlogsorted{i}{{\nwixident{ConstrError}}{ConstrError}}%
\nwixlogsorted{i}{{\nwixident{Correctness}}{Correctness}}%
\nwixlogsorted{i}{{\nwixident{CreateConstList}}{CreateConstList}}%
\nwixlogsorted{i}{{\nwixident{CreateDefinientia}}{CreateDefinientia}}%
\nwixlogsorted{i}{{\nwixident{CreateLociList}}{CreateLociList}}%
\nwixlogsorted{i}{{\nwixident{CreateTrmList}}{CreateTrmList}}%
\nwixlogsorted{i}{{\nwixident{CurSchFuncNbr}}{CurSchFuncNbr}}%
\nwixlogsorted{i}{{\nwixident{D}}{D}}%
\nwixlogsorted{i}{{\nwixident{Decompose}}{Decompose}}%
\nwixlogsorted{i}{{\nwixident{DefAttrTail}}{DefAttrTail}}%
\nwixlogsorted{i}{{\nwixident{DefConditionalCluster}}{DefConditionalCluster}}%
\nwixlogsorted{i}{{\nwixident{DefExistentialCluster}}{DefExistentialCluster}}%
\nwixlogsorted{i}{{\nwixident{DefExpandableMode}}{DefExpandableMode}}%
\nwixlogsorted{i}{{\nwixident{DefFuncPattern}}{DefFuncPattern}}%
\nwixlogsorted{i}{{\nwixident{DefFuncTail}}{DefFuncTail}}%
\nwixlogsorted{i}{{\nwixident{DefFunctorCluster}}{DefFunctorCluster}}%
\nwixlogsorted{i}{{\nwixident{DefIdentify}}{DefIdentify}}%
\nwixlogsorted{i}{{\nwixident{Definition}}{Definition}}%
\nwixlogsorted{i}{{\nwixident{DefinitionalTheorems}}{DefinitionalTheorems}}%
\nwixlogsorted{i}{{\nwixident{DefinitionList}}{DefinitionList}}%
\nwixlogsorted{i}{{\nwixident{DefModePattern}}{DefModePattern}}%
\nwixlogsorted{i}{{\nwixident{DefModeTail}}{DefModeTail}}%
\nwixlogsorted{i}{{\nwixident{DefNode}}{DefNode}}%
\nwixlogsorted{i}{{\nwixident{DefNode.Init}}{DefNode.Init}}%
\nwixlogsorted{i}{{\nwixident{DefNodePtr}}{DefNodePtr}}%
\nwixlogsorted{i}{{\nwixident{DefPredAttributePattern}}{DefPredAttributePattern}}%
\nwixlogsorted{i}{{\nwixident{DefPredPattern}}{DefPredPattern}}%
\nwixlogsorted{i}{{\nwixident{DefPredTail}}{DefPredTail}}%
\nwixlogsorted{i}{{\nwixident{DefProperty}}{DefProperty}}%
\nwixlogsorted{i}{{\nwixident{DefReduction}}{DefReduction}}%
\nwixlogsorted{i}{{\nwixident{DefStruct}}{DefStruct}}%
\nwixlogsorted{i}{{\nwixident{Demonstration}}{Demonstration}}%
\nwixlogsorted{i}{{\nwixident{DiffPerCasesReasoning}}{DiffPerCasesReasoning}}%
\nwixlogsorted{i}{{\nwixident{DiffReasoning}}{DiffReasoning}}%
\nwixlogsorted{i}{{\nwixident{DiffuseStatement}}{DiffuseStatement}}%
\nwixlogsorted{i}{{\nwixident{DisposeAnalyze}}{DisposeAnalyze}}%
\nwixlogsorted{i}{{\nwixident{DisposeLevel}}{DisposeLevel}}%
\nwixlogsorted{i}{{\nwixident{Existence}}{Existence}}%
\nwixlogsorted{i}{{\nwixident{fileTh2Red}}{fileTh2Red}}%
\nwixlogsorted{i}{{\nwixident{FindPattern}}{FindPattern}}%
\nwixlogsorted{i}{{\nwixident{FormalArgs}}{FormalArgs}}%
\nwixlogsorted{i}{{\nwixident{FuncProperty}}{FuncProperty}}%
\nwixlogsorted{i}{{\nwixident{gConstErr}}{gConstErr}}%
\nwixlogsorted{i}{{\nwixident{gDefArgsError}}{gDefArgsError}}%
\nwixlogsorted{i}{{\nwixident{gDefiniendumArgs}}{gDefiniendumArgs}}%
\nwixlogsorted{i}{{\nwixident{gDefNode}}{gDefNode}}%
\nwixlogsorted{i}{{\nwixident{gDefThNr}}{gDefThNr}}%
\nwixlogsorted{i}{{\nwixident{gEssentials}}{gEssentials}}%
\nwixlogsorted{i}{{\nwixident{GetConstQualifiedList}}{GetConstQualifiedList}}%
\nwixlogsorted{i}{{\nwixident{GetPattern}}{GetPattern}}%
\nwixlogsorted{i}{{\nwixident{GetQualifiedList}}{GetQualifiedList}}%
\nwixlogsorted{i}{{\nwixident{gFirstArg}}{gFirstArg}}%
\nwixlogsorted{i}{{\nwixident{gFixedBase}}{gFixedBase}}%
\nwixlogsorted{i}{{\nwixident{gInference}}{gInference}}%
\nwixlogsorted{i}{{\nwixident{gLociSet}}{gLociSet}}%
\nwixlogsorted{i}{{\nwixident{gMaxArgNbr}}{gMaxArgNbr}}%
\nwixlogsorted{i}{{\nwixident{gPrimLength}}{gPrimLength}}%
\nwixlogsorted{i}{{\nwixident{gPropertyCond}}{gPropertyCond}}%
\nwixlogsorted{i}{{\nwixident{gSchemeThesis}}{gSchemeThesis}}%
\nwixlogsorted{i}{{\nwixident{gSchPredNbr}}{gSchPredNbr}}%
\nwixlogsorted{i}{{\nwixident{gSecondArg}}{gSecondArg}}%
\nwixlogsorted{i}{{\nwixident{gSelectorNr}}{gSelectorNr}}%
\nwixlogsorted{i}{{\nwixident{gSelectRepresentation}}{gSelectRepresentation}}%
\nwixlogsorted{i}{{\nwixident{gSkFrstConstNr}}{gSkFrstConstNr}}%
\nwixlogsorted{i}{{\nwixident{gSkListCount}}{gSkListCount}}%
\nwixlogsorted{i}{{\nwixident{gVisible1}}{gVisible1}}%
\nwixlogsorted{i}{{\nwixident{gVisible2}}{gVisible2}}%
\nwixlogsorted{i}{{\nwixident{HereBy}}{HereBy}}%
\nwixlogsorted{i}{{\nwixident{InitAccess}}{InitAccess}}%
\nwixlogsorted{i}{{\nwixident{InitLociForCluster}}{InitLociForCluster}}%
\nwixlogsorted{i}{{\nwixident{InsertFunctor}}{InsertFunctor}}%
\nwixlogsorted{i}{{\nwixident{InsertMode}}{InsertMode}}%
\nwixlogsorted{i}{{\nwixident{InsertPredAttribute}}{InsertPredAttribute}}%
\nwixlogsorted{i}{{\nwixident{InsertPredicate}}{InsertPredicate}}%
\nwixlogsorted{i}{{\nwixident{Justify}}{Justify}}%
\nwixlogsorted{i}{{\nwixident{LoadSGN}}{LoadSGN}}%
\nwixlogsorted{i}{{\nwixident{LociList}}{LociList}}%
\nwixlogsorted{i}{{\nwixident{MaxExpansionNbr}}{MaxExpansionNbr}}%
\nwixlogsorted{i}{{\nwixident{Meaning}}{Meaning}}%
\nwixlogsorted{i}{{\nwixident{MeaningEq}}{MeaningEq}}%
\nwixlogsorted{i}{{\nwixident{ModeProperty}}{ModeProperty}}%
\nwixlogsorted{i}{{\nwixident{NewGuard}}{NewGuard}}%
\nwixlogsorted{i}{{\nwixident{NewInCorDef}}{NewInCorDef}}%
\nwixlogsorted{i}{{\nwixident{NewUnivList}}{NewUnivList}}%
\nwixlogsorted{i}{{\nwixident{NewUnivList1}}{NewUnivList1}}%
\nwixlogsorted{i}{{\nwixident{NotatFuncPattern}}{NotatFuncPattern}}%
\nwixlogsorted{i}{{\nwixident{Notation}}{Notation}}%
\nwixlogsorted{i}{{\nwixident{NotatModePattern}}{NotatModePattern}}%
\nwixlogsorted{i}{{\nwixident{NotatPredAttributePattern}}{NotatPredAttributePattern}}%
\nwixlogsorted{i}{{\nwixident{NotatPredPattern}}{NotatPredPattern}}%
\nwixlogsorted{i}{{\nwixident{OpenDef}}{OpenDef}}%
\nwixlogsorted{i}{{\nwixident{ParamDecl}}{ParamDecl}}%
\nwixlogsorted{i}{{\nwixident{Parametrization}}{Parametrization}}%
\nwixlogsorted{i}{{\nwixident{PartUniCond}}{PartUniCond}}%
\nwixlogsorted{i}{{\nwixident{PerCasesReasoning}}{PerCasesReasoning}}%
\nwixlogsorted{i}{{\nwixident{PosInCollection}}{PosInCollection}}%
\nwixlogsorted{i}{{\nwixident{PredProperty}}{PredProperty}}%
\nwixlogsorted{i}{{\nwixident{ProcessProperties}}{ProcessProperties}}%
\nwixlogsorted{i}{{\nwixident{ReadDefiniens}}{ReadDefiniens}}%
\nwixlogsorted{i}{{\nwixident{ReadPattern}}{ReadPattern}}%
\nwixlogsorted{i}{{\nwixident{ReadPropositions}}{ReadPropositions}}%
\nwixlogsorted{i}{{\nwixident{ReadSentence}}{ReadSentence}}%
\nwixlogsorted{i}{{\nwixident{ReadTerm}}{ReadTerm}}%
\nwixlogsorted{i}{{\nwixident{ReadType}}{ReadType}}%
\nwixlogsorted{i}{{\nwixident{ReadVisible}}{ReadVisible}}%
\nwixlogsorted{i}{{\nwixident{Reasoning}}{Reasoning}}%
\nwixlogsorted{i}{{\nwixident{ReasResult}}{ReasResult}}%
\nwixlogsorted{i}{{\nwixident{RedefFuncPattern}}{RedefFuncPattern}}%
\nwixlogsorted{i}{{\nwixident{RedefModePattern}}{RedefModePattern}}%
\nwixlogsorted{i}{{\nwixident{RedefPredAttributePattern}}{RedefPredAttributePattern}}%
\nwixlogsorted{i}{{\nwixident{RedefPredPattern}}{RedefPredPattern}}%
\nwixlogsorted{i}{{\nwixident{ReductionLikeTheorem}}{ReductionLikeTheorem}}%
\nwixlogsorted{i}{{\nwixident{Registration}}{Registration}}%
\nwixlogsorted{i}{{\nwixident{RegularStatement}}{RegularStatement}}%
\nwixlogsorted{i}{{\nwixident{RenewConst}}{RenewConst}}%
\nwixlogsorted{i}{{\nwixident{RenewPrimaries}}{RenewPrimaries}}%
\nwixlogsorted{i}{{\nwixident{Reservation}}{Reservation}}%
\nwixlogsorted{i}{{\nwixident{RoundUpItem}}{RoundUpItem}}%
\nwixlogsorted{i}{{\nwixident{Scheme}}{Scheme}}%
\nwixlogsorted{i}{{\nwixident{SchemeBody}}{SchemeBody}}%
\nwixlogsorted{i}{{\nwixident{Section}}{Section}}%
\nwixlogsorted{i}{{\nwixident{SetLociOcc}}{SetLociOcc}}%
\nwixlogsorted{i}{{\nwixident{SetStruct}}{SetStruct}}%
\nwixlogsorted{i}{{\nwixident{SetTaken}}{SetTaken}}%
\nwixlogsorted{i}{{\nwixident{SetVisible1}}{SetVisible1}}%
\nwixlogsorted{i}{{\nwixident{SetVisible2}}{SetVisible2}}%
\nwixlogsorted{i}{{\nwixident{SkelList}}{SkelList}}%
\nwixlogsorted{i}{{\nwixident{SkelSnt}}{SkelSnt}}%
\nwixlogsorted{i}{{\nwixident{Specification}}{Specification}}%
\nwixlogsorted{i}{{\nwixident{SpreadAtomicFormula}}{SpreadAtomicFormula}}%
\nwixlogsorted{i}{{\nwixident{SpreadLocPred}}{SpreadLocPred}}%
\nwixlogsorted{i}{{\nwixident{Statement}}{Statement}}%
\nwixlogsorted{i}{{\nwixident{SwapLociInType}}{SwapLociInType}}%
\nwixlogsorted{i}{{\nwixident{Theorem}}{Theorem}}%
\nwixlogsorted{i}{{\nwixident{ThNr}}{ThNr}}%
\nwixlogsorted{i}{{\nwixident{Uniqueness}}{Uniqueness}}%
\nwixlogsorted{i}{{\nwixident{WriteDefiniens}}{WriteDefiniens}}%
\nwixlogsorted{i}{{\nwixident{WriteDefiniensLabel}}{WriteDefiniensLabel}}%
\nwixlogsorted{i}{{\nwixident{WriteQualified}}{WriteQualified}}%
\nwixlogsorted{i}{{\nwixident{xFormula}}{xFormula}}%

